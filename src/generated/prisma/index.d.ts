
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model auditaction
 * 
 */
export type auditaction = $Result.DefaultSelection<Prisma.$auditactionPayload>
/**
 * Model auditlog
 * 
 */
export type auditlog = $Result.DefaultSelection<Prisma.$auditlogPayload>
/**
 * Model badge
 * 
 */
export type badge = $Result.DefaultSelection<Prisma.$badgePayload>
/**
 * Model checkpoint
 * 
 */
export type checkpoint = $Result.DefaultSelection<Prisma.$checkpointPayload>
/**
 * Model location
 * 
 */
export type location = $Result.DefaultSelection<Prisma.$locationPayload>
/**
 * Model locationtype
 * 
 */
export type locationtype = $Result.DefaultSelection<Prisma.$locationtypePayload>
/**
 * Model permission
 * 
 */
export type permission = $Result.DefaultSelection<Prisma.$permissionPayload>
/**
 * Model question
 * 
 */
export type question = $Result.DefaultSelection<Prisma.$questionPayload>
/**
 * Model questionoption
 * 
 */
export type questionoption = $Result.DefaultSelection<Prisma.$questionoptionPayload>
/**
 * Model quiz
 * 
 */
export type quiz = $Result.DefaultSelection<Prisma.$quizPayload>
/**
 * Model review
 * 
 */
export type review = $Result.DefaultSelection<Prisma.$reviewPayload>
/**
 * Model role
 * 
 */
export type role = $Result.DefaultSelection<Prisma.$rolePayload>
/**
 * Model rolepermission
 * 
 */
export type rolepermission = $Result.DefaultSelection<Prisma.$rolepermissionPayload>
/**
 * Model sessions
 * 
 */
export type sessions = $Result.DefaultSelection<Prisma.$sessionsPayload>
/**
 * Model tour
 * 
 */
export type tour = $Result.DefaultSelection<Prisma.$tourPayload>
/**
 * Model tourcheckpoint
 * 
 */
export type tourcheckpoint = $Result.DefaultSelection<Prisma.$tourcheckpointPayload>
/**
 * Model userbadge
 * 
 */
export type userbadge = $Result.DefaultSelection<Prisma.$userbadgePayload>
/**
 * Model usercheckpointattempt
 * 
 */
export type usercheckpointattempt = $Result.DefaultSelection<Prisma.$usercheckpointattemptPayload>
/**
 * Model userprofile
 * 
 */
export type userprofile = $Result.DefaultSelection<Prisma.$userprofilePayload>
/**
 * Model userquizcompletion
 * 
 */
export type userquizcompletion = $Result.DefaultSelection<Prisma.$userquizcompletionPayload>
/**
 * Model userrole
 * 
 */
export type userrole = $Result.DefaultSelection<Prisma.$userrolePayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model usertourcompletion
 * 
 */
export type usertourcompletion = $Result.DefaultSelection<Prisma.$usertourcompletionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const sec_level: {
  Sec1: 'Sec1',
  Sec2: 'Sec2',
  Sec3: 'Sec3',
  Sec4: 'Sec4',
  Sec5: 'Sec5',
  Other: 'Other'
};

export type sec_level = (typeof sec_level)[keyof typeof sec_level]

}

export type sec_level = $Enums.sec_level

export const sec_level: typeof $Enums.sec_level

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Auditactions
 * const auditactions = await prisma.auditaction.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Auditactions
   * const auditactions = await prisma.auditaction.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.auditaction`: Exposes CRUD operations for the **auditaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditactions
    * const auditactions = await prisma.auditaction.findMany()
    * ```
    */
  get auditaction(): Prisma.auditactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditlog`: Exposes CRUD operations for the **auditlog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditlogs
    * const auditlogs = await prisma.auditlog.findMany()
    * ```
    */
  get auditlog(): Prisma.auditlogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.badgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checkpoint`: Exposes CRUD operations for the **checkpoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Checkpoints
    * const checkpoints = await prisma.checkpoint.findMany()
    * ```
    */
  get checkpoint(): Prisma.checkpointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.locationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locationtype`: Exposes CRUD operations for the **locationtype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locationtypes
    * const locationtypes = await prisma.locationtype.findMany()
    * ```
    */
  get locationtype(): Prisma.locationtypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.permissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.questionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionoption`: Exposes CRUD operations for the **questionoption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questionoptions
    * const questionoptions = await prisma.questionoption.findMany()
    * ```
    */
  get questionoption(): Prisma.questionoptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.quizDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.reviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolepermission`: Exposes CRUD operations for the **rolepermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rolepermissions
    * const rolepermissions = await prisma.rolepermission.findMany()
    * ```
    */
  get rolepermission(): Prisma.rolepermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tour`: Exposes CRUD operations for the **tour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tours
    * const tours = await prisma.tour.findMany()
    * ```
    */
  get tour(): Prisma.tourDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tourcheckpoint`: Exposes CRUD operations for the **tourcheckpoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tourcheckpoints
    * const tourcheckpoints = await prisma.tourcheckpoint.findMany()
    * ```
    */
  get tourcheckpoint(): Prisma.tourcheckpointDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userbadge`: Exposes CRUD operations for the **userbadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userbadges
    * const userbadges = await prisma.userbadge.findMany()
    * ```
    */
  get userbadge(): Prisma.userbadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usercheckpointattempt`: Exposes CRUD operations for the **usercheckpointattempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usercheckpointattempts
    * const usercheckpointattempts = await prisma.usercheckpointattempt.findMany()
    * ```
    */
  get usercheckpointattempt(): Prisma.usercheckpointattemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userprofile`: Exposes CRUD operations for the **userprofile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userprofiles
    * const userprofiles = await prisma.userprofile.findMany()
    * ```
    */
  get userprofile(): Prisma.userprofileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userquizcompletion`: Exposes CRUD operations for the **userquizcompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userquizcompletions
    * const userquizcompletions = await prisma.userquizcompletion.findMany()
    * ```
    */
  get userquizcompletion(): Prisma.userquizcompletionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userrole`: Exposes CRUD operations for the **userrole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userroles
    * const userroles = await prisma.userrole.findMany()
    * ```
    */
  get userrole(): Prisma.userroleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usertourcompletion`: Exposes CRUD operations for the **usertourcompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usertourcompletions
    * const usertourcompletions = await prisma.usertourcompletion.findMany()
    * ```
    */
  get usertourcompletion(): Prisma.usertourcompletionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    auditaction: 'auditaction',
    auditlog: 'auditlog',
    badge: 'badge',
    checkpoint: 'checkpoint',
    location: 'location',
    locationtype: 'locationtype',
    permission: 'permission',
    question: 'question',
    questionoption: 'questionoption',
    quiz: 'quiz',
    review: 'review',
    role: 'role',
    rolepermission: 'rolepermission',
    sessions: 'sessions',
    tour: 'tour',
    tourcheckpoint: 'tourcheckpoint',
    userbadge: 'userbadge',
    usercheckpointattempt: 'usercheckpointattempt',
    userprofile: 'userprofile',
    userquizcompletion: 'userquizcompletion',
    userrole: 'userrole',
    users: 'users',
    usertourcompletion: 'usertourcompletion'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "auditaction" | "auditlog" | "badge" | "checkpoint" | "location" | "locationtype" | "permission" | "question" | "questionoption" | "quiz" | "review" | "role" | "rolepermission" | "sessions" | "tour" | "tourcheckpoint" | "userbadge" | "usercheckpointattempt" | "userprofile" | "userquizcompletion" | "userrole" | "users" | "usertourcompletion"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      auditaction: {
        payload: Prisma.$auditactionPayload<ExtArgs>
        fields: Prisma.auditactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auditactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auditactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditactionPayload>
          }
          findFirst: {
            args: Prisma.auditactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auditactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditactionPayload>
          }
          findMany: {
            args: Prisma.auditactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditactionPayload>[]
          }
          create: {
            args: Prisma.auditactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditactionPayload>
          }
          createMany: {
            args: Prisma.auditactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.auditactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditactionPayload>[]
          }
          delete: {
            args: Prisma.auditactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditactionPayload>
          }
          update: {
            args: Prisma.auditactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditactionPayload>
          }
          deleteMany: {
            args: Prisma.auditactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auditactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.auditactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditactionPayload>[]
          }
          upsert: {
            args: Prisma.auditactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditactionPayload>
          }
          aggregate: {
            args: Prisma.AuditactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditaction>
          }
          groupBy: {
            args: Prisma.auditactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.auditactionCountArgs<ExtArgs>
            result: $Utils.Optional<AuditactionCountAggregateOutputType> | number
          }
        }
      }
      auditlog: {
        payload: Prisma.$auditlogPayload<ExtArgs>
        fields: Prisma.auditlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.auditlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.auditlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          findFirst: {
            args: Prisma.auditlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.auditlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          findMany: {
            args: Prisma.auditlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>[]
          }
          create: {
            args: Prisma.auditlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          createMany: {
            args: Prisma.auditlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.auditlogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>[]
          }
          delete: {
            args: Prisma.auditlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          update: {
            args: Prisma.auditlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          deleteMany: {
            args: Prisma.auditlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.auditlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.auditlogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>[]
          }
          upsert: {
            args: Prisma.auditlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$auditlogPayload>
          }
          aggregate: {
            args: Prisma.AuditlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditlog>
          }
          groupBy: {
            args: Prisma.auditlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditlogGroupByOutputType>[]
          }
          count: {
            args: Prisma.auditlogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditlogCountAggregateOutputType> | number
          }
        }
      }
      badge: {
        payload: Prisma.$badgePayload<ExtArgs>
        fields: Prisma.badgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.badgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.badgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>
          }
          findFirst: {
            args: Prisma.badgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.badgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>
          }
          findMany: {
            args: Prisma.badgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>[]
          }
          create: {
            args: Prisma.badgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>
          }
          createMany: {
            args: Prisma.badgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.badgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>[]
          }
          delete: {
            args: Prisma.badgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>
          }
          update: {
            args: Prisma.badgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>
          }
          deleteMany: {
            args: Prisma.badgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.badgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.badgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>[]
          }
          upsert: {
            args: Prisma.badgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$badgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.badgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.badgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      checkpoint: {
        payload: Prisma.$checkpointPayload<ExtArgs>
        fields: Prisma.checkpointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.checkpointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.checkpointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointPayload>
          }
          findFirst: {
            args: Prisma.checkpointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.checkpointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointPayload>
          }
          findMany: {
            args: Prisma.checkpointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointPayload>[]
          }
          create: {
            args: Prisma.checkpointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointPayload>
          }
          createMany: {
            args: Prisma.checkpointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.checkpointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointPayload>[]
          }
          delete: {
            args: Prisma.checkpointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointPayload>
          }
          update: {
            args: Prisma.checkpointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointPayload>
          }
          deleteMany: {
            args: Prisma.checkpointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.checkpointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.checkpointUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointPayload>[]
          }
          upsert: {
            args: Prisma.checkpointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointPayload>
          }
          aggregate: {
            args: Prisma.CheckpointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckpoint>
          }
          groupBy: {
            args: Prisma.checkpointGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckpointGroupByOutputType>[]
          }
          count: {
            args: Prisma.checkpointCountArgs<ExtArgs>
            result: $Utils.Optional<CheckpointCountAggregateOutputType> | number
          }
        }
      }
      location: {
        payload: Prisma.$locationPayload<ExtArgs>
        fields: Prisma.locationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.locationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.locationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          findFirst: {
            args: Prisma.locationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.locationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          findMany: {
            args: Prisma.locationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>[]
          }
          create: {
            args: Prisma.locationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          createMany: {
            args: Prisma.locationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.locationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>[]
          }
          delete: {
            args: Prisma.locationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          update: {
            args: Prisma.locationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          deleteMany: {
            args: Prisma.locationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.locationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.locationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>[]
          }
          upsert: {
            args: Prisma.locationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.locationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.locationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      locationtype: {
        payload: Prisma.$locationtypePayload<ExtArgs>
        fields: Prisma.locationtypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.locationtypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationtypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.locationtypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationtypePayload>
          }
          findFirst: {
            args: Prisma.locationtypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationtypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.locationtypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationtypePayload>
          }
          findMany: {
            args: Prisma.locationtypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationtypePayload>[]
          }
          create: {
            args: Prisma.locationtypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationtypePayload>
          }
          createMany: {
            args: Prisma.locationtypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.locationtypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationtypePayload>[]
          }
          delete: {
            args: Prisma.locationtypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationtypePayload>
          }
          update: {
            args: Prisma.locationtypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationtypePayload>
          }
          deleteMany: {
            args: Prisma.locationtypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.locationtypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.locationtypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationtypePayload>[]
          }
          upsert: {
            args: Prisma.locationtypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationtypePayload>
          }
          aggregate: {
            args: Prisma.LocationtypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationtype>
          }
          groupBy: {
            args: Prisma.locationtypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationtypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.locationtypeCountArgs<ExtArgs>
            result: $Utils.Optional<LocationtypeCountAggregateOutputType> | number
          }
        }
      }
      permission: {
        payload: Prisma.$permissionPayload<ExtArgs>
        fields: Prisma.permissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          findFirst: {
            args: Prisma.permissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          findMany: {
            args: Prisma.permissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>[]
          }
          create: {
            args: Prisma.permissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          createMany: {
            args: Prisma.permissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.permissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>[]
          }
          delete: {
            args: Prisma.permissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          update: {
            args: Prisma.permissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          deleteMany: {
            args: Prisma.permissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.permissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>[]
          }
          upsert: {
            args: Prisma.permissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.permissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      question: {
        payload: Prisma.$questionPayload<ExtArgs>
        fields: Prisma.questionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          findFirst: {
            args: Prisma.questionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          findMany: {
            args: Prisma.questionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>[]
          }
          create: {
            args: Prisma.questionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          createMany: {
            args: Prisma.questionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.questionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>[]
          }
          delete: {
            args: Prisma.questionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          update: {
            args: Prisma.questionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          deleteMany: {
            args: Prisma.questionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.questionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>[]
          }
          upsert: {
            args: Prisma.questionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.questionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.questionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      questionoption: {
        payload: Prisma.$questionoptionPayload<ExtArgs>
        fields: Prisma.questionoptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionoptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionoptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionoptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionoptionPayload>
          }
          findFirst: {
            args: Prisma.questionoptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionoptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionoptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionoptionPayload>
          }
          findMany: {
            args: Prisma.questionoptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionoptionPayload>[]
          }
          create: {
            args: Prisma.questionoptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionoptionPayload>
          }
          createMany: {
            args: Prisma.questionoptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.questionoptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionoptionPayload>[]
          }
          delete: {
            args: Prisma.questionoptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionoptionPayload>
          }
          update: {
            args: Prisma.questionoptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionoptionPayload>
          }
          deleteMany: {
            args: Prisma.questionoptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questionoptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.questionoptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionoptionPayload>[]
          }
          upsert: {
            args: Prisma.questionoptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionoptionPayload>
          }
          aggregate: {
            args: Prisma.QuestionoptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionoption>
          }
          groupBy: {
            args: Prisma.questionoptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionoptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.questionoptionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionoptionCountAggregateOutputType> | number
          }
        }
      }
      quiz: {
        payload: Prisma.$quizPayload<ExtArgs>
        fields: Prisma.quizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>
          }
          findFirst: {
            args: Prisma.quizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>
          }
          findMany: {
            args: Prisma.quizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>[]
          }
          create: {
            args: Prisma.quizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>
          }
          createMany: {
            args: Prisma.quizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.quizCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>[]
          }
          delete: {
            args: Prisma.quizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>
          }
          update: {
            args: Prisma.quizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>
          }
          deleteMany: {
            args: Prisma.quizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.quizUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>[]
          }
          upsert: {
            args: Prisma.quizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizPayload>
          }
          aggregate: {
            args: Prisma.QuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz>
          }
          groupBy: {
            args: Prisma.quizGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.quizCountArgs<ExtArgs>
            result: $Utils.Optional<QuizCountAggregateOutputType> | number
          }
        }
      }
      review: {
        payload: Prisma.$reviewPayload<ExtArgs>
        fields: Prisma.reviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>
          }
          findFirst: {
            args: Prisma.reviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>
          }
          findMany: {
            args: Prisma.reviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>[]
          }
          create: {
            args: Prisma.reviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>
          }
          createMany: {
            args: Prisma.reviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>[]
          }
          delete: {
            args: Prisma.reviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>
          }
          update: {
            args: Prisma.reviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>
          }
          deleteMany: {
            args: Prisma.reviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>[]
          }
          upsert: {
            args: Prisma.reviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.reviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.reviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      role: {
        payload: Prisma.$rolePayload<ExtArgs>
        fields: Prisma.roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findFirst: {
            args: Prisma.roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findMany: {
            args: Prisma.roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          create: {
            args: Prisma.roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          createMany: {
            args: Prisma.roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.roleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          delete: {
            args: Prisma.roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          update: {
            args: Prisma.roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          deleteMany: {
            args: Prisma.roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.roleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          upsert: {
            args: Prisma.roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.roleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      rolepermission: {
        payload: Prisma.$rolepermissionPayload<ExtArgs>
        fields: Prisma.rolepermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolepermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolepermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>
          }
          findFirst: {
            args: Prisma.rolepermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolepermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>
          }
          findMany: {
            args: Prisma.rolepermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>[]
          }
          create: {
            args: Prisma.rolepermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>
          }
          createMany: {
            args: Prisma.rolepermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rolepermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>[]
          }
          delete: {
            args: Prisma.rolepermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>
          }
          update: {
            args: Prisma.rolepermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>
          }
          deleteMany: {
            args: Prisma.rolepermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolepermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rolepermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>[]
          }
          upsert: {
            args: Prisma.rolepermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolepermissionPayload>
          }
          aggregate: {
            args: Prisma.RolepermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolepermission>
          }
          groupBy: {
            args: Prisma.rolepermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolepermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolepermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolepermissionCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: Prisma.$sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sessionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      tour: {
        payload: Prisma.$tourPayload<ExtArgs>
        fields: Prisma.tourFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tourFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tourFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourPayload>
          }
          findFirst: {
            args: Prisma.tourFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tourFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourPayload>
          }
          findMany: {
            args: Prisma.tourFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourPayload>[]
          }
          create: {
            args: Prisma.tourCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourPayload>
          }
          createMany: {
            args: Prisma.tourCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tourCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourPayload>[]
          }
          delete: {
            args: Prisma.tourDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourPayload>
          }
          update: {
            args: Prisma.tourUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourPayload>
          }
          deleteMany: {
            args: Prisma.tourDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tourUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tourUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourPayload>[]
          }
          upsert: {
            args: Prisma.tourUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourPayload>
          }
          aggregate: {
            args: Prisma.TourAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTour>
          }
          groupBy: {
            args: Prisma.tourGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourGroupByOutputType>[]
          }
          count: {
            args: Prisma.tourCountArgs<ExtArgs>
            result: $Utils.Optional<TourCountAggregateOutputType> | number
          }
        }
      }
      tourcheckpoint: {
        payload: Prisma.$tourcheckpointPayload<ExtArgs>
        fields: Prisma.tourcheckpointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tourcheckpointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourcheckpointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tourcheckpointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourcheckpointPayload>
          }
          findFirst: {
            args: Prisma.tourcheckpointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourcheckpointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tourcheckpointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourcheckpointPayload>
          }
          findMany: {
            args: Prisma.tourcheckpointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourcheckpointPayload>[]
          }
          create: {
            args: Prisma.tourcheckpointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourcheckpointPayload>
          }
          createMany: {
            args: Prisma.tourcheckpointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tourcheckpointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourcheckpointPayload>[]
          }
          delete: {
            args: Prisma.tourcheckpointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourcheckpointPayload>
          }
          update: {
            args: Prisma.tourcheckpointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourcheckpointPayload>
          }
          deleteMany: {
            args: Prisma.tourcheckpointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tourcheckpointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tourcheckpointUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourcheckpointPayload>[]
          }
          upsert: {
            args: Prisma.tourcheckpointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tourcheckpointPayload>
          }
          aggregate: {
            args: Prisma.TourcheckpointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTourcheckpoint>
          }
          groupBy: {
            args: Prisma.tourcheckpointGroupByArgs<ExtArgs>
            result: $Utils.Optional<TourcheckpointGroupByOutputType>[]
          }
          count: {
            args: Prisma.tourcheckpointCountArgs<ExtArgs>
            result: $Utils.Optional<TourcheckpointCountAggregateOutputType> | number
          }
        }
      }
      userbadge: {
        payload: Prisma.$userbadgePayload<ExtArgs>
        fields: Prisma.userbadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userbadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userbadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userbadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userbadgePayload>
          }
          findFirst: {
            args: Prisma.userbadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userbadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userbadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userbadgePayload>
          }
          findMany: {
            args: Prisma.userbadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userbadgePayload>[]
          }
          create: {
            args: Prisma.userbadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userbadgePayload>
          }
          createMany: {
            args: Prisma.userbadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userbadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userbadgePayload>[]
          }
          delete: {
            args: Prisma.userbadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userbadgePayload>
          }
          update: {
            args: Prisma.userbadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userbadgePayload>
          }
          deleteMany: {
            args: Prisma.userbadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userbadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userbadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userbadgePayload>[]
          }
          upsert: {
            args: Prisma.userbadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userbadgePayload>
          }
          aggregate: {
            args: Prisma.UserbadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserbadge>
          }
          groupBy: {
            args: Prisma.userbadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserbadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.userbadgeCountArgs<ExtArgs>
            result: $Utils.Optional<UserbadgeCountAggregateOutputType> | number
          }
        }
      }
      usercheckpointattempt: {
        payload: Prisma.$usercheckpointattemptPayload<ExtArgs>
        fields: Prisma.usercheckpointattemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usercheckpointattemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercheckpointattemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usercheckpointattemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercheckpointattemptPayload>
          }
          findFirst: {
            args: Prisma.usercheckpointattemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercheckpointattemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usercheckpointattemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercheckpointattemptPayload>
          }
          findMany: {
            args: Prisma.usercheckpointattemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercheckpointattemptPayload>[]
          }
          create: {
            args: Prisma.usercheckpointattemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercheckpointattemptPayload>
          }
          createMany: {
            args: Prisma.usercheckpointattemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usercheckpointattemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercheckpointattemptPayload>[]
          }
          delete: {
            args: Prisma.usercheckpointattemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercheckpointattemptPayload>
          }
          update: {
            args: Prisma.usercheckpointattemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercheckpointattemptPayload>
          }
          deleteMany: {
            args: Prisma.usercheckpointattemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usercheckpointattemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usercheckpointattemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercheckpointattemptPayload>[]
          }
          upsert: {
            args: Prisma.usercheckpointattemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usercheckpointattemptPayload>
          }
          aggregate: {
            args: Prisma.UsercheckpointattemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsercheckpointattempt>
          }
          groupBy: {
            args: Prisma.usercheckpointattemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsercheckpointattemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.usercheckpointattemptCountArgs<ExtArgs>
            result: $Utils.Optional<UsercheckpointattemptCountAggregateOutputType> | number
          }
        }
      }
      userprofile: {
        payload: Prisma.$userprofilePayload<ExtArgs>
        fields: Prisma.userprofileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userprofileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userprofilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userprofileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userprofilePayload>
          }
          findFirst: {
            args: Prisma.userprofileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userprofilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userprofileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userprofilePayload>
          }
          findMany: {
            args: Prisma.userprofileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userprofilePayload>[]
          }
          create: {
            args: Prisma.userprofileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userprofilePayload>
          }
          createMany: {
            args: Prisma.userprofileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userprofileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userprofilePayload>[]
          }
          delete: {
            args: Prisma.userprofileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userprofilePayload>
          }
          update: {
            args: Prisma.userprofileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userprofilePayload>
          }
          deleteMany: {
            args: Prisma.userprofileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userprofileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userprofileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userprofilePayload>[]
          }
          upsert: {
            args: Prisma.userprofileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userprofilePayload>
          }
          aggregate: {
            args: Prisma.UserprofileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserprofile>
          }
          groupBy: {
            args: Prisma.userprofileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserprofileGroupByOutputType>[]
          }
          count: {
            args: Prisma.userprofileCountArgs<ExtArgs>
            result: $Utils.Optional<UserprofileCountAggregateOutputType> | number
          }
        }
      }
      userquizcompletion: {
        payload: Prisma.$userquizcompletionPayload<ExtArgs>
        fields: Prisma.userquizcompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userquizcompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userquizcompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userquizcompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userquizcompletionPayload>
          }
          findFirst: {
            args: Prisma.userquizcompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userquizcompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userquizcompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userquizcompletionPayload>
          }
          findMany: {
            args: Prisma.userquizcompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userquizcompletionPayload>[]
          }
          create: {
            args: Prisma.userquizcompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userquizcompletionPayload>
          }
          createMany: {
            args: Prisma.userquizcompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userquizcompletionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userquizcompletionPayload>[]
          }
          delete: {
            args: Prisma.userquizcompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userquizcompletionPayload>
          }
          update: {
            args: Prisma.userquizcompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userquizcompletionPayload>
          }
          deleteMany: {
            args: Prisma.userquizcompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userquizcompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userquizcompletionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userquizcompletionPayload>[]
          }
          upsert: {
            args: Prisma.userquizcompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userquizcompletionPayload>
          }
          aggregate: {
            args: Prisma.UserquizcompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserquizcompletion>
          }
          groupBy: {
            args: Prisma.userquizcompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserquizcompletionGroupByOutputType>[]
          }
          count: {
            args: Prisma.userquizcompletionCountArgs<ExtArgs>
            result: $Utils.Optional<UserquizcompletionCountAggregateOutputType> | number
          }
        }
      }
      userrole: {
        payload: Prisma.$userrolePayload<ExtArgs>
        fields: Prisma.userroleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userroleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userroleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findFirst: {
            args: Prisma.userroleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userroleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findMany: {
            args: Prisma.userroleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          create: {
            args: Prisma.userroleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          createMany: {
            args: Prisma.userroleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userroleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          delete: {
            args: Prisma.userroleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          update: {
            args: Prisma.userroleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          deleteMany: {
            args: Prisma.userroleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userroleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userroleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          upsert: {
            args: Prisma.userroleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          aggregate: {
            args: Prisma.UserroleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserrole>
          }
          groupBy: {
            args: Prisma.userroleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserroleGroupByOutputType>[]
          }
          count: {
            args: Prisma.userroleCountArgs<ExtArgs>
            result: $Utils.Optional<UserroleCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      usertourcompletion: {
        payload: Prisma.$usertourcompletionPayload<ExtArgs>
        fields: Prisma.usertourcompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usertourcompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertourcompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usertourcompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertourcompletionPayload>
          }
          findFirst: {
            args: Prisma.usertourcompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertourcompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usertourcompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertourcompletionPayload>
          }
          findMany: {
            args: Prisma.usertourcompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertourcompletionPayload>[]
          }
          create: {
            args: Prisma.usertourcompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertourcompletionPayload>
          }
          createMany: {
            args: Prisma.usertourcompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usertourcompletionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertourcompletionPayload>[]
          }
          delete: {
            args: Prisma.usertourcompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertourcompletionPayload>
          }
          update: {
            args: Prisma.usertourcompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertourcompletionPayload>
          }
          deleteMany: {
            args: Prisma.usertourcompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usertourcompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usertourcompletionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertourcompletionPayload>[]
          }
          upsert: {
            args: Prisma.usertourcompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usertourcompletionPayload>
          }
          aggregate: {
            args: Prisma.UsertourcompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsertourcompletion>
          }
          groupBy: {
            args: Prisma.usertourcompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsertourcompletionGroupByOutputType>[]
          }
          count: {
            args: Prisma.usertourcompletionCountArgs<ExtArgs>
            result: $Utils.Optional<UsertourcompletionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    auditaction?: auditactionOmit
    auditlog?: auditlogOmit
    badge?: badgeOmit
    checkpoint?: checkpointOmit
    location?: locationOmit
    locationtype?: locationtypeOmit
    permission?: permissionOmit
    question?: questionOmit
    questionoption?: questionoptionOmit
    quiz?: quizOmit
    review?: reviewOmit
    role?: roleOmit
    rolepermission?: rolepermissionOmit
    sessions?: sessionsOmit
    tour?: tourOmit
    tourcheckpoint?: tourcheckpointOmit
    userbadge?: userbadgeOmit
    usercheckpointattempt?: usercheckpointattemptOmit
    userprofile?: userprofileOmit
    userquizcompletion?: userquizcompletionOmit
    userrole?: userroleOmit
    users?: usersOmit
    usertourcompletion?: usertourcompletionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AuditactionCountOutputType
   */

  export type AuditactionCountOutputType = {
    auditlog: number
  }

  export type AuditactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditlog?: boolean | AuditactionCountOutputTypeCountAuditlogArgs
  }

  // Custom InputTypes
  /**
   * AuditactionCountOutputType without action
   */
  export type AuditactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditactionCountOutputType
     */
    select?: AuditactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuditactionCountOutputType without action
   */
  export type AuditactionCountOutputTypeCountAuditlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditlogWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    userbadge: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userbadge?: boolean | BadgeCountOutputTypeCountUserbadgeArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountUserbadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userbadgeWhereInput
  }


  /**
   * Count Type CheckpointCountOutputType
   */

  export type CheckpointCountOutputType = {
    tourcheckpoint: number
    usercheckpointattempt: number
  }

  export type CheckpointCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tourcheckpoint?: boolean | CheckpointCountOutputTypeCountTourcheckpointArgs
    usercheckpointattempt?: boolean | CheckpointCountOutputTypeCountUsercheckpointattemptArgs
  }

  // Custom InputTypes
  /**
   * CheckpointCountOutputType without action
   */
  export type CheckpointCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckpointCountOutputType
     */
    select?: CheckpointCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CheckpointCountOutputType without action
   */
  export type CheckpointCountOutputTypeCountTourcheckpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tourcheckpointWhereInput
  }

  /**
   * CheckpointCountOutputType without action
   */
  export type CheckpointCountOutputTypeCountUsercheckpointattemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usercheckpointattemptWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    checkpoint: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoint?: boolean | LocationCountOutputTypeCountCheckpointArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountCheckpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checkpointWhereInput
  }


  /**
   * Count Type LocationtypeCountOutputType
   */

  export type LocationtypeCountOutputType = {
    location: number
  }

  export type LocationtypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationtypeCountOutputTypeCountLocationArgs
  }

  // Custom InputTypes
  /**
   * LocationtypeCountOutputType without action
   */
  export type LocationtypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationtypeCountOutputType
     */
    select?: LocationtypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationtypeCountOutputType without action
   */
  export type LocationtypeCountOutputTypeCountLocationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: locationWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    rolepermission: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolepermission?: boolean | PermissionCountOutputTypeCountRolepermissionArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolepermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolepermissionWhereInput
  }


  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    questionoption: number
  }

  export type QuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questionoption?: boolean | QuestionCountOutputTypeCountQuestionoptionArgs
  }

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountQuestionoptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionoptionWhereInput
  }


  /**
   * Count Type QuizCountOutputType
   */

  export type QuizCountOutputType = {
    checkpoint: number
    question: number
    userquizcompletion: number
  }

  export type QuizCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoint?: boolean | QuizCountOutputTypeCountCheckpointArgs
    question?: boolean | QuizCountOutputTypeCountQuestionArgs
    userquizcompletion?: boolean | QuizCountOutputTypeCountUserquizcompletionArgs
  }

  // Custom InputTypes
  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountCheckpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checkpointWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountUserquizcompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userquizcompletionWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    rolepermission: number
    userrole: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolepermission?: boolean | RoleCountOutputTypeCountRolepermissionArgs
    userrole?: boolean | RoleCountOutputTypeCountUserroleArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRolepermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolepermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
  }


  /**
   * Count Type SessionsCountOutputType
   */

  export type SessionsCountOutputType = {
    auditlog: number
  }

  export type SessionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditlog?: boolean | SessionsCountOutputTypeCountAuditlogArgs
  }

  // Custom InputTypes
  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionsCountOutputType
     */
    select?: SessionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionsCountOutputType without action
   */
  export type SessionsCountOutputTypeCountAuditlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditlogWhereInput
  }


  /**
   * Count Type TourCountOutputType
   */

  export type TourCountOutputType = {
    badge: number
    review: number
    tourcheckpoint: number
    usertourcompletion: number
  }

  export type TourCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | TourCountOutputTypeCountBadgeArgs
    review?: boolean | TourCountOutputTypeCountReviewArgs
    tourcheckpoint?: boolean | TourCountOutputTypeCountTourcheckpointArgs
    usertourcompletion?: boolean | TourCountOutputTypeCountUsertourcompletionArgs
  }

  // Custom InputTypes
  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TourCountOutputType
     */
    select?: TourCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: badgeWhereInput
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewWhereInput
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountTourcheckpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tourcheckpointWhereInput
  }

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeCountUsertourcompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usertourcompletionWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    auditlog: number
    review: number
    sessions: number
    userbadge: number
    usercheckpointattempt: number
    userquizcompletion: number
    usertourcompletion: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditlog?: boolean | UsersCountOutputTypeCountAuditlogArgs
    review?: boolean | UsersCountOutputTypeCountReviewArgs
    sessions?: boolean | UsersCountOutputTypeCountSessionsArgs
    userbadge?: boolean | UsersCountOutputTypeCountUserbadgeArgs
    usercheckpointattempt?: boolean | UsersCountOutputTypeCountUsercheckpointattemptArgs
    userquizcompletion?: boolean | UsersCountOutputTypeCountUserquizcompletionArgs
    usertourcompletion?: boolean | UsersCountOutputTypeCountUsertourcompletionArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAuditlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditlogWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserbadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userbadgeWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUsercheckpointattemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usercheckpointattemptWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserquizcompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userquizcompletionWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUsertourcompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usertourcompletionWhereInput
  }


  /**
   * Count Type UsertourcompletionCountOutputType
   */

  export type UsertourcompletionCountOutputType = {
    usercheckpointattempt: number
  }

  export type UsertourcompletionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usercheckpointattempt?: boolean | UsertourcompletionCountOutputTypeCountUsercheckpointattemptArgs
  }

  // Custom InputTypes
  /**
   * UsertourcompletionCountOutputType without action
   */
  export type UsertourcompletionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsertourcompletionCountOutputType
     */
    select?: UsertourcompletionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsertourcompletionCountOutputType without action
   */
  export type UsertourcompletionCountOutputTypeCountUsercheckpointattemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usercheckpointattemptWhereInput
  }


  /**
   * Models
   */

  /**
   * Model auditaction
   */

  export type AggregateAuditaction = {
    _count: AuditactionCountAggregateOutputType | null
    _min: AuditactionMinAggregateOutputType | null
    _max: AuditactionMaxAggregateOutputType | null
  }

  export type AuditactionMinAggregateOutputType = {
    action_id: string | null
    description: string | null
  }

  export type AuditactionMaxAggregateOutputType = {
    action_id: string | null
    description: string | null
  }

  export type AuditactionCountAggregateOutputType = {
    action_id: number
    description: number
    _all: number
  }


  export type AuditactionMinAggregateInputType = {
    action_id?: true
    description?: true
  }

  export type AuditactionMaxAggregateInputType = {
    action_id?: true
    description?: true
  }

  export type AuditactionCountAggregateInputType = {
    action_id?: true
    description?: true
    _all?: true
  }

  export type AuditactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditaction to aggregate.
     */
    where?: auditactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditactions to fetch.
     */
    orderBy?: auditactionOrderByWithRelationInput | auditactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auditactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auditactions
    **/
    _count?: true | AuditactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditactionMaxAggregateInputType
  }

  export type GetAuditactionAggregateType<T extends AuditactionAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditaction[P]>
      : GetScalarType<T[P], AggregateAuditaction[P]>
  }




  export type auditactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditactionWhereInput
    orderBy?: auditactionOrderByWithAggregationInput | auditactionOrderByWithAggregationInput[]
    by: AuditactionScalarFieldEnum[] | AuditactionScalarFieldEnum
    having?: auditactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditactionCountAggregateInputType | true
    _min?: AuditactionMinAggregateInputType
    _max?: AuditactionMaxAggregateInputType
  }

  export type AuditactionGroupByOutputType = {
    action_id: string
    description: string | null
    _count: AuditactionCountAggregateOutputType | null
    _min: AuditactionMinAggregateOutputType | null
    _max: AuditactionMaxAggregateOutputType | null
  }

  type GetAuditactionGroupByPayload<T extends auditactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditactionGroupByOutputType[P]>
            : GetScalarType<T[P], AuditactionGroupByOutputType[P]>
        }
      >
    >


  export type auditactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    action_id?: boolean
    description?: boolean
    auditlog?: boolean | auditaction$auditlogArgs<ExtArgs>
    _count?: boolean | AuditactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditaction"]>

  export type auditactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    action_id?: boolean
    description?: boolean
  }, ExtArgs["result"]["auditaction"]>

  export type auditactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    action_id?: boolean
    description?: boolean
  }, ExtArgs["result"]["auditaction"]>

  export type auditactionSelectScalar = {
    action_id?: boolean
    description?: boolean
  }

  export type auditactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"action_id" | "description", ExtArgs["result"]["auditaction"]>
  export type auditactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditlog?: boolean | auditaction$auditlogArgs<ExtArgs>
    _count?: boolean | AuditactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type auditactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type auditactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $auditactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auditaction"
    objects: {
      auditlog: Prisma.$auditlogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      action_id: string
      description: string | null
    }, ExtArgs["result"]["auditaction"]>
    composites: {}
  }

  type auditactionGetPayload<S extends boolean | null | undefined | auditactionDefaultArgs> = $Result.GetResult<Prisma.$auditactionPayload, S>

  type auditactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auditactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditactionCountAggregateInputType | true
    }

  export interface auditactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auditaction'], meta: { name: 'auditaction' } }
    /**
     * Find zero or one Auditaction that matches the filter.
     * @param {auditactionFindUniqueArgs} args - Arguments to find a Auditaction
     * @example
     * // Get one Auditaction
     * const auditaction = await prisma.auditaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auditactionFindUniqueArgs>(args: SelectSubset<T, auditactionFindUniqueArgs<ExtArgs>>): Prisma__auditactionClient<$Result.GetResult<Prisma.$auditactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auditaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auditactionFindUniqueOrThrowArgs} args - Arguments to find a Auditaction
     * @example
     * // Get one Auditaction
     * const auditaction = await prisma.auditaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auditactionFindUniqueOrThrowArgs>(args: SelectSubset<T, auditactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auditactionClient<$Result.GetResult<Prisma.$auditactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditactionFindFirstArgs} args - Arguments to find a Auditaction
     * @example
     * // Get one Auditaction
     * const auditaction = await prisma.auditaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auditactionFindFirstArgs>(args?: SelectSubset<T, auditactionFindFirstArgs<ExtArgs>>): Prisma__auditactionClient<$Result.GetResult<Prisma.$auditactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditactionFindFirstOrThrowArgs} args - Arguments to find a Auditaction
     * @example
     * // Get one Auditaction
     * const auditaction = await prisma.auditaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auditactionFindFirstOrThrowArgs>(args?: SelectSubset<T, auditactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__auditactionClient<$Result.GetResult<Prisma.$auditactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auditactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditactions
     * const auditactions = await prisma.auditaction.findMany()
     * 
     * // Get first 10 Auditactions
     * const auditactions = await prisma.auditaction.findMany({ take: 10 })
     * 
     * // Only select the `action_id`
     * const auditactionWithAction_idOnly = await prisma.auditaction.findMany({ select: { action_id: true } })
     * 
     */
    findMany<T extends auditactionFindManyArgs>(args?: SelectSubset<T, auditactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auditaction.
     * @param {auditactionCreateArgs} args - Arguments to create a Auditaction.
     * @example
     * // Create one Auditaction
     * const Auditaction = await prisma.auditaction.create({
     *   data: {
     *     // ... data to create a Auditaction
     *   }
     * })
     * 
     */
    create<T extends auditactionCreateArgs>(args: SelectSubset<T, auditactionCreateArgs<ExtArgs>>): Prisma__auditactionClient<$Result.GetResult<Prisma.$auditactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auditactions.
     * @param {auditactionCreateManyArgs} args - Arguments to create many Auditactions.
     * @example
     * // Create many Auditactions
     * const auditaction = await prisma.auditaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auditactionCreateManyArgs>(args?: SelectSubset<T, auditactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auditactions and returns the data saved in the database.
     * @param {auditactionCreateManyAndReturnArgs} args - Arguments to create many Auditactions.
     * @example
     * // Create many Auditactions
     * const auditaction = await prisma.auditaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auditactions and only return the `action_id`
     * const auditactionWithAction_idOnly = await prisma.auditaction.createManyAndReturn({
     *   select: { action_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends auditactionCreateManyAndReturnArgs>(args?: SelectSubset<T, auditactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auditaction.
     * @param {auditactionDeleteArgs} args - Arguments to delete one Auditaction.
     * @example
     * // Delete one Auditaction
     * const Auditaction = await prisma.auditaction.delete({
     *   where: {
     *     // ... filter to delete one Auditaction
     *   }
     * })
     * 
     */
    delete<T extends auditactionDeleteArgs>(args: SelectSubset<T, auditactionDeleteArgs<ExtArgs>>): Prisma__auditactionClient<$Result.GetResult<Prisma.$auditactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auditaction.
     * @param {auditactionUpdateArgs} args - Arguments to update one Auditaction.
     * @example
     * // Update one Auditaction
     * const auditaction = await prisma.auditaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auditactionUpdateArgs>(args: SelectSubset<T, auditactionUpdateArgs<ExtArgs>>): Prisma__auditactionClient<$Result.GetResult<Prisma.$auditactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auditactions.
     * @param {auditactionDeleteManyArgs} args - Arguments to filter Auditactions to delete.
     * @example
     * // Delete a few Auditactions
     * const { count } = await prisma.auditaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auditactionDeleteManyArgs>(args?: SelectSubset<T, auditactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditactions
     * const auditaction = await prisma.auditaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auditactionUpdateManyArgs>(args: SelectSubset<T, auditactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditactions and returns the data updated in the database.
     * @param {auditactionUpdateManyAndReturnArgs} args - Arguments to update many Auditactions.
     * @example
     * // Update many Auditactions
     * const auditaction = await prisma.auditaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auditactions and only return the `action_id`
     * const auditactionWithAction_idOnly = await prisma.auditaction.updateManyAndReturn({
     *   select: { action_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends auditactionUpdateManyAndReturnArgs>(args: SelectSubset<T, auditactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auditaction.
     * @param {auditactionUpsertArgs} args - Arguments to update or create a Auditaction.
     * @example
     * // Update or create a Auditaction
     * const auditaction = await prisma.auditaction.upsert({
     *   create: {
     *     // ... data to create a Auditaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditaction we want to update
     *   }
     * })
     */
    upsert<T extends auditactionUpsertArgs>(args: SelectSubset<T, auditactionUpsertArgs<ExtArgs>>): Prisma__auditactionClient<$Result.GetResult<Prisma.$auditactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auditactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditactionCountArgs} args - Arguments to filter Auditactions to count.
     * @example
     * // Count the number of Auditactions
     * const count = await prisma.auditaction.count({
     *   where: {
     *     // ... the filter for the Auditactions we want to count
     *   }
     * })
    **/
    count<T extends auditactionCountArgs>(
      args?: Subset<T, auditactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditactionAggregateArgs>(args: Subset<T, AuditactionAggregateArgs>): Prisma.PrismaPromise<GetAuditactionAggregateType<T>>

    /**
     * Group by Auditaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auditactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auditactionGroupByArgs['orderBy'] }
        : { orderBy?: auditactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auditactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auditaction model
   */
  readonly fields: auditactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auditaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auditactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditlog<T extends auditaction$auditlogArgs<ExtArgs> = {}>(args?: Subset<T, auditaction$auditlogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auditaction model
   */
  interface auditactionFieldRefs {
    readonly action_id: FieldRef<"auditaction", 'String'>
    readonly description: FieldRef<"auditaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * auditaction findUnique
   */
  export type auditactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditaction
     */
    select?: auditactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditaction
     */
    omit?: auditactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditactionInclude<ExtArgs> | null
    /**
     * Filter, which auditaction to fetch.
     */
    where: auditactionWhereUniqueInput
  }

  /**
   * auditaction findUniqueOrThrow
   */
  export type auditactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditaction
     */
    select?: auditactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditaction
     */
    omit?: auditactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditactionInclude<ExtArgs> | null
    /**
     * Filter, which auditaction to fetch.
     */
    where: auditactionWhereUniqueInput
  }

  /**
   * auditaction findFirst
   */
  export type auditactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditaction
     */
    select?: auditactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditaction
     */
    omit?: auditactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditactionInclude<ExtArgs> | null
    /**
     * Filter, which auditaction to fetch.
     */
    where?: auditactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditactions to fetch.
     */
    orderBy?: auditactionOrderByWithRelationInput | auditactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditactions.
     */
    cursor?: auditactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditactions.
     */
    distinct?: AuditactionScalarFieldEnum | AuditactionScalarFieldEnum[]
  }

  /**
   * auditaction findFirstOrThrow
   */
  export type auditactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditaction
     */
    select?: auditactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditaction
     */
    omit?: auditactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditactionInclude<ExtArgs> | null
    /**
     * Filter, which auditaction to fetch.
     */
    where?: auditactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditactions to fetch.
     */
    orderBy?: auditactionOrderByWithRelationInput | auditactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditactions.
     */
    cursor?: auditactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditactions.
     */
    distinct?: AuditactionScalarFieldEnum | AuditactionScalarFieldEnum[]
  }

  /**
   * auditaction findMany
   */
  export type auditactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditaction
     */
    select?: auditactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditaction
     */
    omit?: auditactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditactionInclude<ExtArgs> | null
    /**
     * Filter, which auditactions to fetch.
     */
    where?: auditactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditactions to fetch.
     */
    orderBy?: auditactionOrderByWithRelationInput | auditactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auditactions.
     */
    cursor?: auditactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditactions.
     */
    skip?: number
    distinct?: AuditactionScalarFieldEnum | AuditactionScalarFieldEnum[]
  }

  /**
   * auditaction create
   */
  export type auditactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditaction
     */
    select?: auditactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditaction
     */
    omit?: auditactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditactionInclude<ExtArgs> | null
    /**
     * The data needed to create a auditaction.
     */
    data: XOR<auditactionCreateInput, auditactionUncheckedCreateInput>
  }

  /**
   * auditaction createMany
   */
  export type auditactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auditactions.
     */
    data: auditactionCreateManyInput | auditactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auditaction createManyAndReturn
   */
  export type auditactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditaction
     */
    select?: auditactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auditaction
     */
    omit?: auditactionOmit<ExtArgs> | null
    /**
     * The data used to create many auditactions.
     */
    data: auditactionCreateManyInput | auditactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auditaction update
   */
  export type auditactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditaction
     */
    select?: auditactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditaction
     */
    omit?: auditactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditactionInclude<ExtArgs> | null
    /**
     * The data needed to update a auditaction.
     */
    data: XOR<auditactionUpdateInput, auditactionUncheckedUpdateInput>
    /**
     * Choose, which auditaction to update.
     */
    where: auditactionWhereUniqueInput
  }

  /**
   * auditaction updateMany
   */
  export type auditactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auditactions.
     */
    data: XOR<auditactionUpdateManyMutationInput, auditactionUncheckedUpdateManyInput>
    /**
     * Filter which auditactions to update
     */
    where?: auditactionWhereInput
    /**
     * Limit how many auditactions to update.
     */
    limit?: number
  }

  /**
   * auditaction updateManyAndReturn
   */
  export type auditactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditaction
     */
    select?: auditactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auditaction
     */
    omit?: auditactionOmit<ExtArgs> | null
    /**
     * The data used to update auditactions.
     */
    data: XOR<auditactionUpdateManyMutationInput, auditactionUncheckedUpdateManyInput>
    /**
     * Filter which auditactions to update
     */
    where?: auditactionWhereInput
    /**
     * Limit how many auditactions to update.
     */
    limit?: number
  }

  /**
   * auditaction upsert
   */
  export type auditactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditaction
     */
    select?: auditactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditaction
     */
    omit?: auditactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditactionInclude<ExtArgs> | null
    /**
     * The filter to search for the auditaction to update in case it exists.
     */
    where: auditactionWhereUniqueInput
    /**
     * In case the auditaction found by the `where` argument doesn't exist, create a new auditaction with this data.
     */
    create: XOR<auditactionCreateInput, auditactionUncheckedCreateInput>
    /**
     * In case the auditaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auditactionUpdateInput, auditactionUncheckedUpdateInput>
  }

  /**
   * auditaction delete
   */
  export type auditactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditaction
     */
    select?: auditactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditaction
     */
    omit?: auditactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditactionInclude<ExtArgs> | null
    /**
     * Filter which auditaction to delete.
     */
    where: auditactionWhereUniqueInput
  }

  /**
   * auditaction deleteMany
   */
  export type auditactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditactions to delete
     */
    where?: auditactionWhereInput
    /**
     * Limit how many auditactions to delete.
     */
    limit?: number
  }

  /**
   * auditaction.auditlog
   */
  export type auditaction$auditlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    where?: auditlogWhereInput
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    cursor?: auditlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * auditaction without action
   */
  export type auditactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditaction
     */
    select?: auditactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditaction
     */
    omit?: auditactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditactionInclude<ExtArgs> | null
  }


  /**
   * Model auditlog
   */

  export type AggregateAuditlog = {
    _count: AuditlogCountAggregateOutputType | null
    _avg: AuditlogAvgAggregateOutputType | null
    _sum: AuditlogSumAggregateOutputType | null
    _min: AuditlogMinAggregateOutputType | null
    _max: AuditlogMaxAggregateOutputType | null
  }

  export type AuditlogAvgAggregateOutputType = {
    log_id: number | null
    user_id: number | null
    session_id: number | null
    target_id: number | null
  }

  export type AuditlogSumAggregateOutputType = {
    log_id: number | null
    user_id: number | null
    session_id: number | null
    target_id: number | null
  }

  export type AuditlogMinAggregateOutputType = {
    log_id: number | null
    user_id: number | null
    session_id: number | null
    action_id: string | null
    target_id: number | null
    target_entity: string | null
    timestamp: Date | null
  }

  export type AuditlogMaxAggregateOutputType = {
    log_id: number | null
    user_id: number | null
    session_id: number | null
    action_id: string | null
    target_id: number | null
    target_entity: string | null
    timestamp: Date | null
  }

  export type AuditlogCountAggregateOutputType = {
    log_id: number
    user_id: number
    session_id: number
    action_id: number
    target_id: number
    target_entity: number
    timestamp: number
    _all: number
  }


  export type AuditlogAvgAggregateInputType = {
    log_id?: true
    user_id?: true
    session_id?: true
    target_id?: true
  }

  export type AuditlogSumAggregateInputType = {
    log_id?: true
    user_id?: true
    session_id?: true
    target_id?: true
  }

  export type AuditlogMinAggregateInputType = {
    log_id?: true
    user_id?: true
    session_id?: true
    action_id?: true
    target_id?: true
    target_entity?: true
    timestamp?: true
  }

  export type AuditlogMaxAggregateInputType = {
    log_id?: true
    user_id?: true
    session_id?: true
    action_id?: true
    target_id?: true
    target_entity?: true
    timestamp?: true
  }

  export type AuditlogCountAggregateInputType = {
    log_id?: true
    user_id?: true
    session_id?: true
    action_id?: true
    target_id?: true
    target_entity?: true
    timestamp?: true
    _all?: true
  }

  export type AuditlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditlog to aggregate.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auditlogs
    **/
    _count?: true | AuditlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditlogMaxAggregateInputType
  }

  export type GetAuditlogAggregateType<T extends AuditlogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditlog[P]>
      : GetScalarType<T[P], AggregateAuditlog[P]>
  }




  export type auditlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: auditlogWhereInput
    orderBy?: auditlogOrderByWithAggregationInput | auditlogOrderByWithAggregationInput[]
    by: AuditlogScalarFieldEnum[] | AuditlogScalarFieldEnum
    having?: auditlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditlogCountAggregateInputType | true
    _avg?: AuditlogAvgAggregateInputType
    _sum?: AuditlogSumAggregateInputType
    _min?: AuditlogMinAggregateInputType
    _max?: AuditlogMaxAggregateInputType
  }

  export type AuditlogGroupByOutputType = {
    log_id: number
    user_id: number | null
    session_id: number | null
    action_id: string | null
    target_id: number
    target_entity: string | null
    timestamp: Date | null
    _count: AuditlogCountAggregateOutputType | null
    _avg: AuditlogAvgAggregateOutputType | null
    _sum: AuditlogSumAggregateOutputType | null
    _min: AuditlogMinAggregateOutputType | null
    _max: AuditlogMaxAggregateOutputType | null
  }

  type GetAuditlogGroupByPayload<T extends auditlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditlogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditlogGroupByOutputType[P]>
        }
      >
    >


  export type auditlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    log_id?: boolean
    user_id?: boolean
    session_id?: boolean
    action_id?: boolean
    target_id?: boolean
    target_entity?: boolean
    timestamp?: boolean
    auditaction?: boolean | auditlog$auditactionArgs<ExtArgs>
    sessions?: boolean | auditlog$sessionsArgs<ExtArgs>
    users?: boolean | auditlog$usersArgs<ExtArgs>
  }, ExtArgs["result"]["auditlog"]>

  export type auditlogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    log_id?: boolean
    user_id?: boolean
    session_id?: boolean
    action_id?: boolean
    target_id?: boolean
    target_entity?: boolean
    timestamp?: boolean
    auditaction?: boolean | auditlog$auditactionArgs<ExtArgs>
    sessions?: boolean | auditlog$sessionsArgs<ExtArgs>
    users?: boolean | auditlog$usersArgs<ExtArgs>
  }, ExtArgs["result"]["auditlog"]>

  export type auditlogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    log_id?: boolean
    user_id?: boolean
    session_id?: boolean
    action_id?: boolean
    target_id?: boolean
    target_entity?: boolean
    timestamp?: boolean
    auditaction?: boolean | auditlog$auditactionArgs<ExtArgs>
    sessions?: boolean | auditlog$sessionsArgs<ExtArgs>
    users?: boolean | auditlog$usersArgs<ExtArgs>
  }, ExtArgs["result"]["auditlog"]>

  export type auditlogSelectScalar = {
    log_id?: boolean
    user_id?: boolean
    session_id?: boolean
    action_id?: boolean
    target_id?: boolean
    target_entity?: boolean
    timestamp?: boolean
  }

  export type auditlogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"log_id" | "user_id" | "session_id" | "action_id" | "target_id" | "target_entity" | "timestamp", ExtArgs["result"]["auditlog"]>
  export type auditlogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditaction?: boolean | auditlog$auditactionArgs<ExtArgs>
    sessions?: boolean | auditlog$sessionsArgs<ExtArgs>
    users?: boolean | auditlog$usersArgs<ExtArgs>
  }
  export type auditlogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditaction?: boolean | auditlog$auditactionArgs<ExtArgs>
    sessions?: boolean | auditlog$sessionsArgs<ExtArgs>
    users?: boolean | auditlog$usersArgs<ExtArgs>
  }
  export type auditlogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditaction?: boolean | auditlog$auditactionArgs<ExtArgs>
    sessions?: boolean | auditlog$sessionsArgs<ExtArgs>
    users?: boolean | auditlog$usersArgs<ExtArgs>
  }

  export type $auditlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "auditlog"
    objects: {
      auditaction: Prisma.$auditactionPayload<ExtArgs> | null
      sessions: Prisma.$sessionsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      log_id: number
      user_id: number | null
      session_id: number | null
      action_id: string | null
      target_id: number
      target_entity: string | null
      timestamp: Date | null
    }, ExtArgs["result"]["auditlog"]>
    composites: {}
  }

  type auditlogGetPayload<S extends boolean | null | undefined | auditlogDefaultArgs> = $Result.GetResult<Prisma.$auditlogPayload, S>

  type auditlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<auditlogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditlogCountAggregateInputType | true
    }

  export interface auditlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['auditlog'], meta: { name: 'auditlog' } }
    /**
     * Find zero or one Auditlog that matches the filter.
     * @param {auditlogFindUniqueArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auditlogFindUniqueArgs>(args: SelectSubset<T, auditlogFindUniqueArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auditlog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auditlogFindUniqueOrThrowArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auditlogFindUniqueOrThrowArgs>(args: SelectSubset<T, auditlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditlog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogFindFirstArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auditlogFindFirstArgs>(args?: SelectSubset<T, auditlogFindFirstArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auditlog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogFindFirstOrThrowArgs} args - Arguments to find a Auditlog
     * @example
     * // Get one Auditlog
     * const auditlog = await prisma.auditlog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auditlogFindFirstOrThrowArgs>(args?: SelectSubset<T, auditlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auditlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditlogs
     * const auditlogs = await prisma.auditlog.findMany()
     * 
     * // Get first 10 Auditlogs
     * const auditlogs = await prisma.auditlog.findMany({ take: 10 })
     * 
     * // Only select the `log_id`
     * const auditlogWithLog_idOnly = await prisma.auditlog.findMany({ select: { log_id: true } })
     * 
     */
    findMany<T extends auditlogFindManyArgs>(args?: SelectSubset<T, auditlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auditlog.
     * @param {auditlogCreateArgs} args - Arguments to create a Auditlog.
     * @example
     * // Create one Auditlog
     * const Auditlog = await prisma.auditlog.create({
     *   data: {
     *     // ... data to create a Auditlog
     *   }
     * })
     * 
     */
    create<T extends auditlogCreateArgs>(args: SelectSubset<T, auditlogCreateArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auditlogs.
     * @param {auditlogCreateManyArgs} args - Arguments to create many Auditlogs.
     * @example
     * // Create many Auditlogs
     * const auditlog = await prisma.auditlog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends auditlogCreateManyArgs>(args?: SelectSubset<T, auditlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auditlogs and returns the data saved in the database.
     * @param {auditlogCreateManyAndReturnArgs} args - Arguments to create many Auditlogs.
     * @example
     * // Create many Auditlogs
     * const auditlog = await prisma.auditlog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auditlogs and only return the `log_id`
     * const auditlogWithLog_idOnly = await prisma.auditlog.createManyAndReturn({
     *   select: { log_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends auditlogCreateManyAndReturnArgs>(args?: SelectSubset<T, auditlogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auditlog.
     * @param {auditlogDeleteArgs} args - Arguments to delete one Auditlog.
     * @example
     * // Delete one Auditlog
     * const Auditlog = await prisma.auditlog.delete({
     *   where: {
     *     // ... filter to delete one Auditlog
     *   }
     * })
     * 
     */
    delete<T extends auditlogDeleteArgs>(args: SelectSubset<T, auditlogDeleteArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auditlog.
     * @param {auditlogUpdateArgs} args - Arguments to update one Auditlog.
     * @example
     * // Update one Auditlog
     * const auditlog = await prisma.auditlog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends auditlogUpdateArgs>(args: SelectSubset<T, auditlogUpdateArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auditlogs.
     * @param {auditlogDeleteManyArgs} args - Arguments to filter Auditlogs to delete.
     * @example
     * // Delete a few Auditlogs
     * const { count } = await prisma.auditlog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends auditlogDeleteManyArgs>(args?: SelectSubset<T, auditlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditlogs
     * const auditlog = await prisma.auditlog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends auditlogUpdateManyArgs>(args: SelectSubset<T, auditlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditlogs and returns the data updated in the database.
     * @param {auditlogUpdateManyAndReturnArgs} args - Arguments to update many Auditlogs.
     * @example
     * // Update many Auditlogs
     * const auditlog = await prisma.auditlog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auditlogs and only return the `log_id`
     * const auditlogWithLog_idOnly = await prisma.auditlog.updateManyAndReturn({
     *   select: { log_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends auditlogUpdateManyAndReturnArgs>(args: SelectSubset<T, auditlogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auditlog.
     * @param {auditlogUpsertArgs} args - Arguments to update or create a Auditlog.
     * @example
     * // Update or create a Auditlog
     * const auditlog = await prisma.auditlog.upsert({
     *   create: {
     *     // ... data to create a Auditlog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditlog we want to update
     *   }
     * })
     */
    upsert<T extends auditlogUpsertArgs>(args: SelectSubset<T, auditlogUpsertArgs<ExtArgs>>): Prisma__auditlogClient<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auditlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogCountArgs} args - Arguments to filter Auditlogs to count.
     * @example
     * // Count the number of Auditlogs
     * const count = await prisma.auditlog.count({
     *   where: {
     *     // ... the filter for the Auditlogs we want to count
     *   }
     * })
    **/
    count<T extends auditlogCountArgs>(
      args?: Subset<T, auditlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditlogAggregateArgs>(args: Subset<T, AuditlogAggregateArgs>): Prisma.PrismaPromise<GetAuditlogAggregateType<T>>

    /**
     * Group by Auditlog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends auditlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auditlogGroupByArgs['orderBy'] }
        : { orderBy?: auditlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, auditlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the auditlog model
   */
  readonly fields: auditlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auditlog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auditlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditaction<T extends auditlog$auditactionArgs<ExtArgs> = {}>(args?: Subset<T, auditlog$auditactionArgs<ExtArgs>>): Prisma__auditactionClient<$Result.GetResult<Prisma.$auditactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessions<T extends auditlog$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, auditlog$sessionsArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends auditlog$usersArgs<ExtArgs> = {}>(args?: Subset<T, auditlog$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the auditlog model
   */
  interface auditlogFieldRefs {
    readonly log_id: FieldRef<"auditlog", 'Int'>
    readonly user_id: FieldRef<"auditlog", 'Int'>
    readonly session_id: FieldRef<"auditlog", 'Int'>
    readonly action_id: FieldRef<"auditlog", 'String'>
    readonly target_id: FieldRef<"auditlog", 'Int'>
    readonly target_entity: FieldRef<"auditlog", 'String'>
    readonly timestamp: FieldRef<"auditlog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * auditlog findUnique
   */
  export type auditlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where: auditlogWhereUniqueInput
  }

  /**
   * auditlog findUniqueOrThrow
   */
  export type auditlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where: auditlogWhereUniqueInput
  }

  /**
   * auditlog findFirst
   */
  export type auditlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditlogs.
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditlogs.
     */
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * auditlog findFirstOrThrow
   */
  export type auditlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * Filter, which auditlog to fetch.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditlogs.
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditlogs.
     */
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * auditlog findMany
   */
  export type auditlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * Filter, which auditlogs to fetch.
     */
    where?: auditlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditlogs to fetch.
     */
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auditlogs.
     */
    cursor?: auditlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditlogs.
     */
    skip?: number
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * auditlog create
   */
  export type auditlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * The data needed to create a auditlog.
     */
    data: XOR<auditlogCreateInput, auditlogUncheckedCreateInput>
  }

  /**
   * auditlog createMany
   */
  export type auditlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many auditlogs.
     */
    data: auditlogCreateManyInput | auditlogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * auditlog createManyAndReturn
   */
  export type auditlogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * The data used to create many auditlogs.
     */
    data: auditlogCreateManyInput | auditlogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * auditlog update
   */
  export type auditlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * The data needed to update a auditlog.
     */
    data: XOR<auditlogUpdateInput, auditlogUncheckedUpdateInput>
    /**
     * Choose, which auditlog to update.
     */
    where: auditlogWhereUniqueInput
  }

  /**
   * auditlog updateMany
   */
  export type auditlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update auditlogs.
     */
    data: XOR<auditlogUpdateManyMutationInput, auditlogUncheckedUpdateManyInput>
    /**
     * Filter which auditlogs to update
     */
    where?: auditlogWhereInput
    /**
     * Limit how many auditlogs to update.
     */
    limit?: number
  }

  /**
   * auditlog updateManyAndReturn
   */
  export type auditlogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * The data used to update auditlogs.
     */
    data: XOR<auditlogUpdateManyMutationInput, auditlogUncheckedUpdateManyInput>
    /**
     * Filter which auditlogs to update
     */
    where?: auditlogWhereInput
    /**
     * Limit how many auditlogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * auditlog upsert
   */
  export type auditlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * The filter to search for the auditlog to update in case it exists.
     */
    where: auditlogWhereUniqueInput
    /**
     * In case the auditlog found by the `where` argument doesn't exist, create a new auditlog with this data.
     */
    create: XOR<auditlogCreateInput, auditlogUncheckedCreateInput>
    /**
     * In case the auditlog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auditlogUpdateInput, auditlogUncheckedUpdateInput>
  }

  /**
   * auditlog delete
   */
  export type auditlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    /**
     * Filter which auditlog to delete.
     */
    where: auditlogWhereUniqueInput
  }

  /**
   * auditlog deleteMany
   */
  export type auditlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which auditlogs to delete
     */
    where?: auditlogWhereInput
    /**
     * Limit how many auditlogs to delete.
     */
    limit?: number
  }

  /**
   * auditlog.auditaction
   */
  export type auditlog$auditactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditaction
     */
    select?: auditactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditaction
     */
    omit?: auditactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditactionInclude<ExtArgs> | null
    where?: auditactionWhereInput
  }

  /**
   * auditlog.sessions
   */
  export type auditlog$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    where?: sessionsWhereInput
  }

  /**
   * auditlog.users
   */
  export type auditlog$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * auditlog without action
   */
  export type auditlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
  }


  /**
   * Model badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeAvgAggregateOutputType = {
    badge_id: number | null
    tour_id: number | null
  }

  export type BadgeSumAggregateOutputType = {
    badge_id: number | null
    tour_id: number | null
  }

  export type BadgeMinAggregateOutputType = {
    badge_id: number | null
    tour_id: number | null
    badge_title: string | null
    description: string | null
    image_url: string | null
  }

  export type BadgeMaxAggregateOutputType = {
    badge_id: number | null
    tour_id: number | null
    badge_title: string | null
    description: string | null
    image_url: string | null
  }

  export type BadgeCountAggregateOutputType = {
    badge_id: number
    tour_id: number
    badge_title: number
    description: number
    image_url: number
    _all: number
  }


  export type BadgeAvgAggregateInputType = {
    badge_id?: true
    tour_id?: true
  }

  export type BadgeSumAggregateInputType = {
    badge_id?: true
    tour_id?: true
  }

  export type BadgeMinAggregateInputType = {
    badge_id?: true
    tour_id?: true
    badge_title?: true
    description?: true
    image_url?: true
  }

  export type BadgeMaxAggregateInputType = {
    badge_id?: true
    tour_id?: true
    badge_title?: true
    description?: true
    image_url?: true
  }

  export type BadgeCountAggregateInputType = {
    badge_id?: true
    tour_id?: true
    badge_title?: true
    description?: true
    image_url?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badge to aggregate.
     */
    where?: badgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgeOrderByWithRelationInput | badgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: badgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type badgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: badgeWhereInput
    orderBy?: badgeOrderByWithAggregationInput | badgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: badgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _avg?: BadgeAvgAggregateInputType
    _sum?: BadgeSumAggregateInputType
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    badge_id: number
    tour_id: number | null
    badge_title: string
    description: string
    image_url: string
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends badgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type badgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    badge_id?: boolean
    tour_id?: boolean
    badge_title?: boolean
    description?: boolean
    image_url?: boolean
    tour?: boolean | badge$tourArgs<ExtArgs>
    userbadge?: boolean | badge$userbadgeArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type badgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    badge_id?: boolean
    tour_id?: boolean
    badge_title?: boolean
    description?: boolean
    image_url?: boolean
    tour?: boolean | badge$tourArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type badgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    badge_id?: boolean
    tour_id?: boolean
    badge_title?: boolean
    description?: boolean
    image_url?: boolean
    tour?: boolean | badge$tourArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type badgeSelectScalar = {
    badge_id?: boolean
    tour_id?: boolean
    badge_title?: boolean
    description?: boolean
    image_url?: boolean
  }

  export type badgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"badge_id" | "tour_id" | "badge_title" | "description" | "image_url", ExtArgs["result"]["badge"]>
  export type badgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | badge$tourArgs<ExtArgs>
    userbadge?: boolean | badge$userbadgeArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type badgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | badge$tourArgs<ExtArgs>
  }
  export type badgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | badge$tourArgs<ExtArgs>
  }

  export type $badgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "badge"
    objects: {
      tour: Prisma.$tourPayload<ExtArgs> | null
      userbadge: Prisma.$userbadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      badge_id: number
      tour_id: number | null
      badge_title: string
      description: string
      image_url: string
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type badgeGetPayload<S extends boolean | null | undefined | badgeDefaultArgs> = $Result.GetResult<Prisma.$badgePayload, S>

  type badgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<badgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface badgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['badge'], meta: { name: 'badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {badgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends badgeFindUniqueArgs>(args: SelectSubset<T, badgeFindUniqueArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {badgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends badgeFindUniqueOrThrowArgs>(args: SelectSubset<T, badgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends badgeFindFirstArgs>(args?: SelectSubset<T, badgeFindFirstArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends badgeFindFirstOrThrowArgs>(args?: SelectSubset<T, badgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `badge_id`
     * const badgeWithBadge_idOnly = await prisma.badge.findMany({ select: { badge_id: true } })
     * 
     */
    findMany<T extends badgeFindManyArgs>(args?: SelectSubset<T, badgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Badge.
     * @param {badgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends badgeCreateArgs>(args: SelectSubset<T, badgeCreateArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Badges.
     * @param {badgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends badgeCreateManyArgs>(args?: SelectSubset<T, badgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {badgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `badge_id`
     * const badgeWithBadge_idOnly = await prisma.badge.createManyAndReturn({
     *   select: { badge_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends badgeCreateManyAndReturnArgs>(args?: SelectSubset<T, badgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Badge.
     * @param {badgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends badgeDeleteArgs>(args: SelectSubset<T, badgeDeleteArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Badge.
     * @param {badgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends badgeUpdateArgs>(args: SelectSubset<T, badgeUpdateArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Badges.
     * @param {badgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends badgeDeleteManyArgs>(args?: SelectSubset<T, badgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends badgeUpdateManyArgs>(args: SelectSubset<T, badgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges and returns the data updated in the database.
     * @param {badgeUpdateManyAndReturnArgs} args - Arguments to update many Badges.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Badges and only return the `badge_id`
     * const badgeWithBadge_idOnly = await prisma.badge.updateManyAndReturn({
     *   select: { badge_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends badgeUpdateManyAndReturnArgs>(args: SelectSubset<T, badgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Badge.
     * @param {badgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends badgeUpsertArgs>(args: SelectSubset<T, badgeUpsertArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends badgeCountArgs>(
      args?: Subset<T, badgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {badgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends badgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: badgeGroupByArgs['orderBy'] }
        : { orderBy?: badgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, badgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the badge model
   */
  readonly fields: badgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__badgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tour<T extends badge$tourArgs<ExtArgs> = {}>(args?: Subset<T, badge$tourArgs<ExtArgs>>): Prisma__tourClient<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userbadge<T extends badge$userbadgeArgs<ExtArgs> = {}>(args?: Subset<T, badge$userbadgeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userbadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the badge model
   */
  interface badgeFieldRefs {
    readonly badge_id: FieldRef<"badge", 'Int'>
    readonly tour_id: FieldRef<"badge", 'Int'>
    readonly badge_title: FieldRef<"badge", 'String'>
    readonly description: FieldRef<"badge", 'String'>
    readonly image_url: FieldRef<"badge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * badge findUnique
   */
  export type badgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * Filter, which badge to fetch.
     */
    where: badgeWhereUniqueInput
  }

  /**
   * badge findUniqueOrThrow
   */
  export type badgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * Filter, which badge to fetch.
     */
    where: badgeWhereUniqueInput
  }

  /**
   * badge findFirst
   */
  export type badgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * Filter, which badge to fetch.
     */
    where?: badgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgeOrderByWithRelationInput | badgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badges.
     */
    cursor?: badgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * badge findFirstOrThrow
   */
  export type badgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * Filter, which badge to fetch.
     */
    where?: badgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgeOrderByWithRelationInput | badgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for badges.
     */
    cursor?: badgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * badge findMany
   */
  export type badgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * Filter, which badges to fetch.
     */
    where?: badgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of badges to fetch.
     */
    orderBy?: badgeOrderByWithRelationInput | badgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing badges.
     */
    cursor?: badgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * badge create
   */
  export type badgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * The data needed to create a badge.
     */
    data: XOR<badgeCreateInput, badgeUncheckedCreateInput>
  }

  /**
   * badge createMany
   */
  export type badgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many badges.
     */
    data: badgeCreateManyInput | badgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * badge createManyAndReturn
   */
  export type badgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * The data used to create many badges.
     */
    data: badgeCreateManyInput | badgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * badge update
   */
  export type badgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * The data needed to update a badge.
     */
    data: XOR<badgeUpdateInput, badgeUncheckedUpdateInput>
    /**
     * Choose, which badge to update.
     */
    where: badgeWhereUniqueInput
  }

  /**
   * badge updateMany
   */
  export type badgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update badges.
     */
    data: XOR<badgeUpdateManyMutationInput, badgeUncheckedUpdateManyInput>
    /**
     * Filter which badges to update
     */
    where?: badgeWhereInput
    /**
     * Limit how many badges to update.
     */
    limit?: number
  }

  /**
   * badge updateManyAndReturn
   */
  export type badgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * The data used to update badges.
     */
    data: XOR<badgeUpdateManyMutationInput, badgeUncheckedUpdateManyInput>
    /**
     * Filter which badges to update
     */
    where?: badgeWhereInput
    /**
     * Limit how many badges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * badge upsert
   */
  export type badgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * The filter to search for the badge to update in case it exists.
     */
    where: badgeWhereUniqueInput
    /**
     * In case the badge found by the `where` argument doesn't exist, create a new badge with this data.
     */
    create: XOR<badgeCreateInput, badgeUncheckedCreateInput>
    /**
     * In case the badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<badgeUpdateInput, badgeUncheckedUpdateInput>
  }

  /**
   * badge delete
   */
  export type badgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    /**
     * Filter which badge to delete.
     */
    where: badgeWhereUniqueInput
  }

  /**
   * badge deleteMany
   */
  export type badgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which badges to delete
     */
    where?: badgeWhereInput
    /**
     * Limit how many badges to delete.
     */
    limit?: number
  }

  /**
   * badge.tour
   */
  export type badge$tourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourInclude<ExtArgs> | null
    where?: tourWhereInput
  }

  /**
   * badge.userbadge
   */
  export type badge$userbadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeInclude<ExtArgs> | null
    where?: userbadgeWhereInput
    orderBy?: userbadgeOrderByWithRelationInput | userbadgeOrderByWithRelationInput[]
    cursor?: userbadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserbadgeScalarFieldEnum | UserbadgeScalarFieldEnum[]
  }

  /**
   * badge without action
   */
  export type badgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
  }


  /**
   * Model checkpoint
   */

  export type AggregateCheckpoint = {
    _count: CheckpointCountAggregateOutputType | null
    _avg: CheckpointAvgAggregateOutputType | null
    _sum: CheckpointSumAggregateOutputType | null
    _min: CheckpointMinAggregateOutputType | null
    _max: CheckpointMaxAggregateOutputType | null
  }

  export type CheckpointAvgAggregateOutputType = {
    checkpoint_id: number | null
    quiz_id: number | null
    location_id: number | null
    points_reward: number | null
  }

  export type CheckpointSumAggregateOutputType = {
    checkpoint_id: number | null
    quiz_id: number | null
    location_id: number | null
    points_reward: number | null
  }

  export type CheckpointMinAggregateOutputType = {
    checkpoint_id: number | null
    quiz_id: number | null
    location_id: number | null
    points_reward: number | null
    created_at: Date | null
  }

  export type CheckpointMaxAggregateOutputType = {
    checkpoint_id: number | null
    quiz_id: number | null
    location_id: number | null
    points_reward: number | null
    created_at: Date | null
  }

  export type CheckpointCountAggregateOutputType = {
    checkpoint_id: number
    quiz_id: number
    location_id: number
    points_reward: number
    created_at: number
    _all: number
  }


  export type CheckpointAvgAggregateInputType = {
    checkpoint_id?: true
    quiz_id?: true
    location_id?: true
    points_reward?: true
  }

  export type CheckpointSumAggregateInputType = {
    checkpoint_id?: true
    quiz_id?: true
    location_id?: true
    points_reward?: true
  }

  export type CheckpointMinAggregateInputType = {
    checkpoint_id?: true
    quiz_id?: true
    location_id?: true
    points_reward?: true
    created_at?: true
  }

  export type CheckpointMaxAggregateInputType = {
    checkpoint_id?: true
    quiz_id?: true
    location_id?: true
    points_reward?: true
    created_at?: true
  }

  export type CheckpointCountAggregateInputType = {
    checkpoint_id?: true
    quiz_id?: true
    location_id?: true
    points_reward?: true
    created_at?: true
    _all?: true
  }

  export type CheckpointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which checkpoint to aggregate.
     */
    where?: checkpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkpoints to fetch.
     */
    orderBy?: checkpointOrderByWithRelationInput | checkpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: checkpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned checkpoints
    **/
    _count?: true | CheckpointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheckpointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheckpointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckpointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckpointMaxAggregateInputType
  }

  export type GetCheckpointAggregateType<T extends CheckpointAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckpoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckpoint[P]>
      : GetScalarType<T[P], AggregateCheckpoint[P]>
  }




  export type checkpointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checkpointWhereInput
    orderBy?: checkpointOrderByWithAggregationInput | checkpointOrderByWithAggregationInput[]
    by: CheckpointScalarFieldEnum[] | CheckpointScalarFieldEnum
    having?: checkpointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckpointCountAggregateInputType | true
    _avg?: CheckpointAvgAggregateInputType
    _sum?: CheckpointSumAggregateInputType
    _min?: CheckpointMinAggregateInputType
    _max?: CheckpointMaxAggregateInputType
  }

  export type CheckpointGroupByOutputType = {
    checkpoint_id: number
    quiz_id: number | null
    location_id: number
    points_reward: number
    created_at: Date | null
    _count: CheckpointCountAggregateOutputType | null
    _avg: CheckpointAvgAggregateOutputType | null
    _sum: CheckpointSumAggregateOutputType | null
    _min: CheckpointMinAggregateOutputType | null
    _max: CheckpointMaxAggregateOutputType | null
  }

  type GetCheckpointGroupByPayload<T extends checkpointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckpointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckpointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckpointGroupByOutputType[P]>
            : GetScalarType<T[P], CheckpointGroupByOutputType[P]>
        }
      >
    >


  export type checkpointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    checkpoint_id?: boolean
    quiz_id?: boolean
    location_id?: boolean
    points_reward?: boolean
    created_at?: boolean
    location?: boolean | locationDefaultArgs<ExtArgs>
    quiz?: boolean | checkpoint$quizArgs<ExtArgs>
    tourcheckpoint?: boolean | checkpoint$tourcheckpointArgs<ExtArgs>
    usercheckpointattempt?: boolean | checkpoint$usercheckpointattemptArgs<ExtArgs>
    _count?: boolean | CheckpointCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkpoint"]>

  export type checkpointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    checkpoint_id?: boolean
    quiz_id?: boolean
    location_id?: boolean
    points_reward?: boolean
    created_at?: boolean
    location?: boolean | locationDefaultArgs<ExtArgs>
    quiz?: boolean | checkpoint$quizArgs<ExtArgs>
  }, ExtArgs["result"]["checkpoint"]>

  export type checkpointSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    checkpoint_id?: boolean
    quiz_id?: boolean
    location_id?: boolean
    points_reward?: boolean
    created_at?: boolean
    location?: boolean | locationDefaultArgs<ExtArgs>
    quiz?: boolean | checkpoint$quizArgs<ExtArgs>
  }, ExtArgs["result"]["checkpoint"]>

  export type checkpointSelectScalar = {
    checkpoint_id?: boolean
    quiz_id?: boolean
    location_id?: boolean
    points_reward?: boolean
    created_at?: boolean
  }

  export type checkpointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"checkpoint_id" | "quiz_id" | "location_id" | "points_reward" | "created_at", ExtArgs["result"]["checkpoint"]>
  export type checkpointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | locationDefaultArgs<ExtArgs>
    quiz?: boolean | checkpoint$quizArgs<ExtArgs>
    tourcheckpoint?: boolean | checkpoint$tourcheckpointArgs<ExtArgs>
    usercheckpointattempt?: boolean | checkpoint$usercheckpointattemptArgs<ExtArgs>
    _count?: boolean | CheckpointCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type checkpointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | locationDefaultArgs<ExtArgs>
    quiz?: boolean | checkpoint$quizArgs<ExtArgs>
  }
  export type checkpointIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | locationDefaultArgs<ExtArgs>
    quiz?: boolean | checkpoint$quizArgs<ExtArgs>
  }

  export type $checkpointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "checkpoint"
    objects: {
      location: Prisma.$locationPayload<ExtArgs>
      quiz: Prisma.$quizPayload<ExtArgs> | null
      tourcheckpoint: Prisma.$tourcheckpointPayload<ExtArgs>[]
      usercheckpointattempt: Prisma.$usercheckpointattemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      checkpoint_id: number
      quiz_id: number | null
      location_id: number
      points_reward: number
      created_at: Date | null
    }, ExtArgs["result"]["checkpoint"]>
    composites: {}
  }

  type checkpointGetPayload<S extends boolean | null | undefined | checkpointDefaultArgs> = $Result.GetResult<Prisma.$checkpointPayload, S>

  type checkpointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<checkpointFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CheckpointCountAggregateInputType | true
    }

  export interface checkpointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['checkpoint'], meta: { name: 'checkpoint' } }
    /**
     * Find zero or one Checkpoint that matches the filter.
     * @param {checkpointFindUniqueArgs} args - Arguments to find a Checkpoint
     * @example
     * // Get one Checkpoint
     * const checkpoint = await prisma.checkpoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends checkpointFindUniqueArgs>(args: SelectSubset<T, checkpointFindUniqueArgs<ExtArgs>>): Prisma__checkpointClient<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Checkpoint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {checkpointFindUniqueOrThrowArgs} args - Arguments to find a Checkpoint
     * @example
     * // Get one Checkpoint
     * const checkpoint = await prisma.checkpoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends checkpointFindUniqueOrThrowArgs>(args: SelectSubset<T, checkpointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__checkpointClient<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Checkpoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkpointFindFirstArgs} args - Arguments to find a Checkpoint
     * @example
     * // Get one Checkpoint
     * const checkpoint = await prisma.checkpoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends checkpointFindFirstArgs>(args?: SelectSubset<T, checkpointFindFirstArgs<ExtArgs>>): Prisma__checkpointClient<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Checkpoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkpointFindFirstOrThrowArgs} args - Arguments to find a Checkpoint
     * @example
     * // Get one Checkpoint
     * const checkpoint = await prisma.checkpoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends checkpointFindFirstOrThrowArgs>(args?: SelectSubset<T, checkpointFindFirstOrThrowArgs<ExtArgs>>): Prisma__checkpointClient<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Checkpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkpointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Checkpoints
     * const checkpoints = await prisma.checkpoint.findMany()
     * 
     * // Get first 10 Checkpoints
     * const checkpoints = await prisma.checkpoint.findMany({ take: 10 })
     * 
     * // Only select the `checkpoint_id`
     * const checkpointWithCheckpoint_idOnly = await prisma.checkpoint.findMany({ select: { checkpoint_id: true } })
     * 
     */
    findMany<T extends checkpointFindManyArgs>(args?: SelectSubset<T, checkpointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Checkpoint.
     * @param {checkpointCreateArgs} args - Arguments to create a Checkpoint.
     * @example
     * // Create one Checkpoint
     * const Checkpoint = await prisma.checkpoint.create({
     *   data: {
     *     // ... data to create a Checkpoint
     *   }
     * })
     * 
     */
    create<T extends checkpointCreateArgs>(args: SelectSubset<T, checkpointCreateArgs<ExtArgs>>): Prisma__checkpointClient<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Checkpoints.
     * @param {checkpointCreateManyArgs} args - Arguments to create many Checkpoints.
     * @example
     * // Create many Checkpoints
     * const checkpoint = await prisma.checkpoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends checkpointCreateManyArgs>(args?: SelectSubset<T, checkpointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Checkpoints and returns the data saved in the database.
     * @param {checkpointCreateManyAndReturnArgs} args - Arguments to create many Checkpoints.
     * @example
     * // Create many Checkpoints
     * const checkpoint = await prisma.checkpoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Checkpoints and only return the `checkpoint_id`
     * const checkpointWithCheckpoint_idOnly = await prisma.checkpoint.createManyAndReturn({
     *   select: { checkpoint_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends checkpointCreateManyAndReturnArgs>(args?: SelectSubset<T, checkpointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Checkpoint.
     * @param {checkpointDeleteArgs} args - Arguments to delete one Checkpoint.
     * @example
     * // Delete one Checkpoint
     * const Checkpoint = await prisma.checkpoint.delete({
     *   where: {
     *     // ... filter to delete one Checkpoint
     *   }
     * })
     * 
     */
    delete<T extends checkpointDeleteArgs>(args: SelectSubset<T, checkpointDeleteArgs<ExtArgs>>): Prisma__checkpointClient<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Checkpoint.
     * @param {checkpointUpdateArgs} args - Arguments to update one Checkpoint.
     * @example
     * // Update one Checkpoint
     * const checkpoint = await prisma.checkpoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends checkpointUpdateArgs>(args: SelectSubset<T, checkpointUpdateArgs<ExtArgs>>): Prisma__checkpointClient<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Checkpoints.
     * @param {checkpointDeleteManyArgs} args - Arguments to filter Checkpoints to delete.
     * @example
     * // Delete a few Checkpoints
     * const { count } = await prisma.checkpoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends checkpointDeleteManyArgs>(args?: SelectSubset<T, checkpointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checkpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkpointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Checkpoints
     * const checkpoint = await prisma.checkpoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends checkpointUpdateManyArgs>(args: SelectSubset<T, checkpointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checkpoints and returns the data updated in the database.
     * @param {checkpointUpdateManyAndReturnArgs} args - Arguments to update many Checkpoints.
     * @example
     * // Update many Checkpoints
     * const checkpoint = await prisma.checkpoint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Checkpoints and only return the `checkpoint_id`
     * const checkpointWithCheckpoint_idOnly = await prisma.checkpoint.updateManyAndReturn({
     *   select: { checkpoint_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends checkpointUpdateManyAndReturnArgs>(args: SelectSubset<T, checkpointUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Checkpoint.
     * @param {checkpointUpsertArgs} args - Arguments to update or create a Checkpoint.
     * @example
     * // Update or create a Checkpoint
     * const checkpoint = await prisma.checkpoint.upsert({
     *   create: {
     *     // ... data to create a Checkpoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Checkpoint we want to update
     *   }
     * })
     */
    upsert<T extends checkpointUpsertArgs>(args: SelectSubset<T, checkpointUpsertArgs<ExtArgs>>): Prisma__checkpointClient<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Checkpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkpointCountArgs} args - Arguments to filter Checkpoints to count.
     * @example
     * // Count the number of Checkpoints
     * const count = await prisma.checkpoint.count({
     *   where: {
     *     // ... the filter for the Checkpoints we want to count
     *   }
     * })
    **/
    count<T extends checkpointCountArgs>(
      args?: Subset<T, checkpointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckpointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Checkpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckpointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckpointAggregateArgs>(args: Subset<T, CheckpointAggregateArgs>): Prisma.PrismaPromise<GetCheckpointAggregateType<T>>

    /**
     * Group by Checkpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkpointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends checkpointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: checkpointGroupByArgs['orderBy'] }
        : { orderBy?: checkpointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, checkpointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckpointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the checkpoint model
   */
  readonly fields: checkpointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for checkpoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__checkpointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends locationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, locationDefaultArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quiz<T extends checkpoint$quizArgs<ExtArgs> = {}>(args?: Subset<T, checkpoint$quizArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tourcheckpoint<T extends checkpoint$tourcheckpointArgs<ExtArgs> = {}>(args?: Subset<T, checkpoint$tourcheckpointArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tourcheckpointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usercheckpointattempt<T extends checkpoint$usercheckpointattemptArgs<ExtArgs> = {}>(args?: Subset<T, checkpoint$usercheckpointattemptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the checkpoint model
   */
  interface checkpointFieldRefs {
    readonly checkpoint_id: FieldRef<"checkpoint", 'Int'>
    readonly quiz_id: FieldRef<"checkpoint", 'Int'>
    readonly location_id: FieldRef<"checkpoint", 'Int'>
    readonly points_reward: FieldRef<"checkpoint", 'Int'>
    readonly created_at: FieldRef<"checkpoint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * checkpoint findUnique
   */
  export type checkpointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointInclude<ExtArgs> | null
    /**
     * Filter, which checkpoint to fetch.
     */
    where: checkpointWhereUniqueInput
  }

  /**
   * checkpoint findUniqueOrThrow
   */
  export type checkpointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointInclude<ExtArgs> | null
    /**
     * Filter, which checkpoint to fetch.
     */
    where: checkpointWhereUniqueInput
  }

  /**
   * checkpoint findFirst
   */
  export type checkpointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointInclude<ExtArgs> | null
    /**
     * Filter, which checkpoint to fetch.
     */
    where?: checkpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkpoints to fetch.
     */
    orderBy?: checkpointOrderByWithRelationInput | checkpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checkpoints.
     */
    cursor?: checkpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checkpoints.
     */
    distinct?: CheckpointScalarFieldEnum | CheckpointScalarFieldEnum[]
  }

  /**
   * checkpoint findFirstOrThrow
   */
  export type checkpointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointInclude<ExtArgs> | null
    /**
     * Filter, which checkpoint to fetch.
     */
    where?: checkpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkpoints to fetch.
     */
    orderBy?: checkpointOrderByWithRelationInput | checkpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checkpoints.
     */
    cursor?: checkpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checkpoints.
     */
    distinct?: CheckpointScalarFieldEnum | CheckpointScalarFieldEnum[]
  }

  /**
   * checkpoint findMany
   */
  export type checkpointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointInclude<ExtArgs> | null
    /**
     * Filter, which checkpoints to fetch.
     */
    where?: checkpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkpoints to fetch.
     */
    orderBy?: checkpointOrderByWithRelationInput | checkpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing checkpoints.
     */
    cursor?: checkpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkpoints.
     */
    skip?: number
    distinct?: CheckpointScalarFieldEnum | CheckpointScalarFieldEnum[]
  }

  /**
   * checkpoint create
   */
  export type checkpointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointInclude<ExtArgs> | null
    /**
     * The data needed to create a checkpoint.
     */
    data: XOR<checkpointCreateInput, checkpointUncheckedCreateInput>
  }

  /**
   * checkpoint createMany
   */
  export type checkpointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many checkpoints.
     */
    data: checkpointCreateManyInput | checkpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * checkpoint createManyAndReturn
   */
  export type checkpointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * The data used to create many checkpoints.
     */
    data: checkpointCreateManyInput | checkpointCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * checkpoint update
   */
  export type checkpointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointInclude<ExtArgs> | null
    /**
     * The data needed to update a checkpoint.
     */
    data: XOR<checkpointUpdateInput, checkpointUncheckedUpdateInput>
    /**
     * Choose, which checkpoint to update.
     */
    where: checkpointWhereUniqueInput
  }

  /**
   * checkpoint updateMany
   */
  export type checkpointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update checkpoints.
     */
    data: XOR<checkpointUpdateManyMutationInput, checkpointUncheckedUpdateManyInput>
    /**
     * Filter which checkpoints to update
     */
    where?: checkpointWhereInput
    /**
     * Limit how many checkpoints to update.
     */
    limit?: number
  }

  /**
   * checkpoint updateManyAndReturn
   */
  export type checkpointUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * The data used to update checkpoints.
     */
    data: XOR<checkpointUpdateManyMutationInput, checkpointUncheckedUpdateManyInput>
    /**
     * Filter which checkpoints to update
     */
    where?: checkpointWhereInput
    /**
     * Limit how many checkpoints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * checkpoint upsert
   */
  export type checkpointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointInclude<ExtArgs> | null
    /**
     * The filter to search for the checkpoint to update in case it exists.
     */
    where: checkpointWhereUniqueInput
    /**
     * In case the checkpoint found by the `where` argument doesn't exist, create a new checkpoint with this data.
     */
    create: XOR<checkpointCreateInput, checkpointUncheckedCreateInput>
    /**
     * In case the checkpoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<checkpointUpdateInput, checkpointUncheckedUpdateInput>
  }

  /**
   * checkpoint delete
   */
  export type checkpointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointInclude<ExtArgs> | null
    /**
     * Filter which checkpoint to delete.
     */
    where: checkpointWhereUniqueInput
  }

  /**
   * checkpoint deleteMany
   */
  export type checkpointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which checkpoints to delete
     */
    where?: checkpointWhereInput
    /**
     * Limit how many checkpoints to delete.
     */
    limit?: number
  }

  /**
   * checkpoint.quiz
   */
  export type checkpoint$quizArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    where?: quizWhereInput
  }

  /**
   * checkpoint.tourcheckpoint
   */
  export type checkpoint$tourcheckpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointInclude<ExtArgs> | null
    where?: tourcheckpointWhereInput
    orderBy?: tourcheckpointOrderByWithRelationInput | tourcheckpointOrderByWithRelationInput[]
    cursor?: tourcheckpointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourcheckpointScalarFieldEnum | TourcheckpointScalarFieldEnum[]
  }

  /**
   * checkpoint.usercheckpointattempt
   */
  export type checkpoint$usercheckpointattemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptInclude<ExtArgs> | null
    where?: usercheckpointattemptWhereInput
    orderBy?: usercheckpointattemptOrderByWithRelationInput | usercheckpointattemptOrderByWithRelationInput[]
    cursor?: usercheckpointattemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsercheckpointattemptScalarFieldEnum | UsercheckpointattemptScalarFieldEnum[]
  }

  /**
   * checkpoint without action
   */
  export type checkpointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointInclude<ExtArgs> | null
  }


  /**
   * Model location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    location_id: number | null
  }

  export type LocationSumAggregateOutputType = {
    location_id: number | null
  }

  export type LocationMinAggregateOutputType = {
    location_id: number | null
    location_name: string | null
    locationtype_id: string | null
    description: string | null
    created_at: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    location_id: number | null
    location_name: string | null
    locationtype_id: string | null
    description: string | null
    created_at: Date | null
  }

  export type LocationCountAggregateOutputType = {
    location_id: number
    location_name: number
    locationtype_id: number
    description: number
    created_at: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    location_id?: true
  }

  export type LocationSumAggregateInputType = {
    location_id?: true
  }

  export type LocationMinAggregateInputType = {
    location_id?: true
    location_name?: true
    locationtype_id?: true
    description?: true
    created_at?: true
  }

  export type LocationMaxAggregateInputType = {
    location_id?: true
    location_name?: true
    locationtype_id?: true
    description?: true
    created_at?: true
  }

  export type LocationCountAggregateInputType = {
    location_id?: true
    location_name?: true
    locationtype_id?: true
    description?: true
    created_at?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which location to aggregate.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type locationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: locationWhereInput
    orderBy?: locationOrderByWithAggregationInput | locationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: locationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    location_id: number
    location_name: string
    locationtype_id: string | null
    description: string | null
    created_at: Date | null
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends locationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type locationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    location_id?: boolean
    location_name?: boolean
    locationtype_id?: boolean
    description?: boolean
    created_at?: boolean
    checkpoint?: boolean | location$checkpointArgs<ExtArgs>
    locationtype?: boolean | location$locationtypeArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type locationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    location_id?: boolean
    location_name?: boolean
    locationtype_id?: boolean
    description?: boolean
    created_at?: boolean
    locationtype?: boolean | location$locationtypeArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type locationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    location_id?: boolean
    location_name?: boolean
    locationtype_id?: boolean
    description?: boolean
    created_at?: boolean
    locationtype?: boolean | location$locationtypeArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type locationSelectScalar = {
    location_id?: boolean
    location_name?: boolean
    locationtype_id?: boolean
    description?: boolean
    created_at?: boolean
  }

  export type locationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"location_id" | "location_name" | "locationtype_id" | "description" | "created_at", ExtArgs["result"]["location"]>
  export type locationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoint?: boolean | location$checkpointArgs<ExtArgs>
    locationtype?: boolean | location$locationtypeArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type locationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationtype?: boolean | location$locationtypeArgs<ExtArgs>
  }
  export type locationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locationtype?: boolean | location$locationtypeArgs<ExtArgs>
  }

  export type $locationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "location"
    objects: {
      checkpoint: Prisma.$checkpointPayload<ExtArgs>[]
      locationtype: Prisma.$locationtypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      location_id: number
      location_name: string
      locationtype_id: string | null
      description: string | null
      created_at: Date | null
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type locationGetPayload<S extends boolean | null | undefined | locationDefaultArgs> = $Result.GetResult<Prisma.$locationPayload, S>

  type locationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<locationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface locationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['location'], meta: { name: 'location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {locationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends locationFindUniqueArgs>(args: SelectSubset<T, locationFindUniqueArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {locationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends locationFindUniqueOrThrowArgs>(args: SelectSubset<T, locationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends locationFindFirstArgs>(args?: SelectSubset<T, locationFindFirstArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends locationFindFirstOrThrowArgs>(args?: SelectSubset<T, locationFindFirstOrThrowArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `location_id`
     * const locationWithLocation_idOnly = await prisma.location.findMany({ select: { location_id: true } })
     * 
     */
    findMany<T extends locationFindManyArgs>(args?: SelectSubset<T, locationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {locationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends locationCreateArgs>(args: SelectSubset<T, locationCreateArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {locationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends locationCreateManyArgs>(args?: SelectSubset<T, locationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {locationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `location_id`
     * const locationWithLocation_idOnly = await prisma.location.createManyAndReturn({
     *   select: { location_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends locationCreateManyAndReturnArgs>(args?: SelectSubset<T, locationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {locationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends locationDeleteArgs>(args: SelectSubset<T, locationDeleteArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {locationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends locationUpdateArgs>(args: SelectSubset<T, locationUpdateArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {locationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends locationDeleteManyArgs>(args?: SelectSubset<T, locationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends locationUpdateManyArgs>(args: SelectSubset<T, locationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {locationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `location_id`
     * const locationWithLocation_idOnly = await prisma.location.updateManyAndReturn({
     *   select: { location_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends locationUpdateManyAndReturnArgs>(args: SelectSubset<T, locationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {locationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends locationUpsertArgs>(args: SelectSubset<T, locationUpsertArgs<ExtArgs>>): Prisma__locationClient<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationCountArgs>(
      args?: Subset<T, locationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends locationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: locationGroupByArgs['orderBy'] }
        : { orderBy?: locationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, locationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the location model
   */
  readonly fields: locationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__locationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    checkpoint<T extends location$checkpointArgs<ExtArgs> = {}>(args?: Subset<T, location$checkpointArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locationtype<T extends location$locationtypeArgs<ExtArgs> = {}>(args?: Subset<T, location$locationtypeArgs<ExtArgs>>): Prisma__locationtypeClient<$Result.GetResult<Prisma.$locationtypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the location model
   */
  interface locationFieldRefs {
    readonly location_id: FieldRef<"location", 'Int'>
    readonly location_name: FieldRef<"location", 'String'>
    readonly locationtype_id: FieldRef<"location", 'String'>
    readonly description: FieldRef<"location", 'String'>
    readonly created_at: FieldRef<"location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * location findUnique
   */
  export type locationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location findUniqueOrThrow
   */
  export type locationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location findFirst
   */
  export type locationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * location findFirstOrThrow
   */
  export type locationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which location to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * location findMany
   */
  export type locationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     */
    cursor?: locationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * location create
   */
  export type locationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * The data needed to create a location.
     */
    data: XOR<locationCreateInput, locationUncheckedCreateInput>
  }

  /**
   * location createMany
   */
  export type locationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many locations.
     */
    data: locationCreateManyInput | locationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * location createManyAndReturn
   */
  export type locationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * The data used to create many locations.
     */
    data: locationCreateManyInput | locationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * location update
   */
  export type locationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * The data needed to update a location.
     */
    data: XOR<locationUpdateInput, locationUncheckedUpdateInput>
    /**
     * Choose, which location to update.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location updateMany
   */
  export type locationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update locations.
     */
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationWhereInput
    /**
     * Limit how many locations to update.
     */
    limit?: number
  }

  /**
   * location updateManyAndReturn
   */
  export type locationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * The data used to update locations.
     */
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationWhereInput
    /**
     * Limit how many locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * location upsert
   */
  export type locationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * The filter to search for the location to update in case it exists.
     */
    where: locationWhereUniqueInput
    /**
     * In case the location found by the `where` argument doesn't exist, create a new location with this data.
     */
    create: XOR<locationCreateInput, locationUncheckedCreateInput>
    /**
     * In case the location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locationUpdateInput, locationUncheckedUpdateInput>
  }

  /**
   * location delete
   */
  export type locationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    /**
     * Filter which location to delete.
     */
    where: locationWhereUniqueInput
  }

  /**
   * location deleteMany
   */
  export type locationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to delete
     */
    where?: locationWhereInput
    /**
     * Limit how many locations to delete.
     */
    limit?: number
  }

  /**
   * location.checkpoint
   */
  export type location$checkpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointInclude<ExtArgs> | null
    where?: checkpointWhereInput
    orderBy?: checkpointOrderByWithRelationInput | checkpointOrderByWithRelationInput[]
    cursor?: checkpointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckpointScalarFieldEnum | CheckpointScalarFieldEnum[]
  }

  /**
   * location.locationtype
   */
  export type location$locationtypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locationtype
     */
    select?: locationtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locationtype
     */
    omit?: locationtypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationtypeInclude<ExtArgs> | null
    where?: locationtypeWhereInput
  }

  /**
   * location without action
   */
  export type locationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
  }


  /**
   * Model locationtype
   */

  export type AggregateLocationtype = {
    _count: LocationtypeCountAggregateOutputType | null
    _min: LocationtypeMinAggregateOutputType | null
    _max: LocationtypeMaxAggregateOutputType | null
  }

  export type LocationtypeMinAggregateOutputType = {
    locationtype_id: string | null
    description: string | null
  }

  export type LocationtypeMaxAggregateOutputType = {
    locationtype_id: string | null
    description: string | null
  }

  export type LocationtypeCountAggregateOutputType = {
    locationtype_id: number
    description: number
    _all: number
  }


  export type LocationtypeMinAggregateInputType = {
    locationtype_id?: true
    description?: true
  }

  export type LocationtypeMaxAggregateInputType = {
    locationtype_id?: true
    description?: true
  }

  export type LocationtypeCountAggregateInputType = {
    locationtype_id?: true
    description?: true
    _all?: true
  }

  export type LocationtypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locationtype to aggregate.
     */
    where?: locationtypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locationtypes to fetch.
     */
    orderBy?: locationtypeOrderByWithRelationInput | locationtypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locationtypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locationtypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locationtypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locationtypes
    **/
    _count?: true | LocationtypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationtypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationtypeMaxAggregateInputType
  }

  export type GetLocationtypeAggregateType<T extends LocationtypeAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationtype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationtype[P]>
      : GetScalarType<T[P], AggregateLocationtype[P]>
  }




  export type locationtypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: locationtypeWhereInput
    orderBy?: locationtypeOrderByWithAggregationInput | locationtypeOrderByWithAggregationInput[]
    by: LocationtypeScalarFieldEnum[] | LocationtypeScalarFieldEnum
    having?: locationtypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationtypeCountAggregateInputType | true
    _min?: LocationtypeMinAggregateInputType
    _max?: LocationtypeMaxAggregateInputType
  }

  export type LocationtypeGroupByOutputType = {
    locationtype_id: string
    description: string | null
    _count: LocationtypeCountAggregateOutputType | null
    _min: LocationtypeMinAggregateOutputType | null
    _max: LocationtypeMaxAggregateOutputType | null
  }

  type GetLocationtypeGroupByPayload<T extends locationtypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationtypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationtypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationtypeGroupByOutputType[P]>
            : GetScalarType<T[P], LocationtypeGroupByOutputType[P]>
        }
      >
    >


  export type locationtypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    locationtype_id?: boolean
    description?: boolean
    location?: boolean | locationtype$locationArgs<ExtArgs>
    _count?: boolean | LocationtypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationtype"]>

  export type locationtypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    locationtype_id?: boolean
    description?: boolean
  }, ExtArgs["result"]["locationtype"]>

  export type locationtypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    locationtype_id?: boolean
    description?: boolean
  }, ExtArgs["result"]["locationtype"]>

  export type locationtypeSelectScalar = {
    locationtype_id?: boolean
    description?: boolean
  }

  export type locationtypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"locationtype_id" | "description", ExtArgs["result"]["locationtype"]>
  export type locationtypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | locationtype$locationArgs<ExtArgs>
    _count?: boolean | LocationtypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type locationtypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type locationtypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $locationtypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "locationtype"
    objects: {
      location: Prisma.$locationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      locationtype_id: string
      description: string | null
    }, ExtArgs["result"]["locationtype"]>
    composites: {}
  }

  type locationtypeGetPayload<S extends boolean | null | undefined | locationtypeDefaultArgs> = $Result.GetResult<Prisma.$locationtypePayload, S>

  type locationtypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<locationtypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationtypeCountAggregateInputType | true
    }

  export interface locationtypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['locationtype'], meta: { name: 'locationtype' } }
    /**
     * Find zero or one Locationtype that matches the filter.
     * @param {locationtypeFindUniqueArgs} args - Arguments to find a Locationtype
     * @example
     * // Get one Locationtype
     * const locationtype = await prisma.locationtype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends locationtypeFindUniqueArgs>(args: SelectSubset<T, locationtypeFindUniqueArgs<ExtArgs>>): Prisma__locationtypeClient<$Result.GetResult<Prisma.$locationtypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Locationtype that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {locationtypeFindUniqueOrThrowArgs} args - Arguments to find a Locationtype
     * @example
     * // Get one Locationtype
     * const locationtype = await prisma.locationtype.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends locationtypeFindUniqueOrThrowArgs>(args: SelectSubset<T, locationtypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__locationtypeClient<$Result.GetResult<Prisma.$locationtypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Locationtype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationtypeFindFirstArgs} args - Arguments to find a Locationtype
     * @example
     * // Get one Locationtype
     * const locationtype = await prisma.locationtype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends locationtypeFindFirstArgs>(args?: SelectSubset<T, locationtypeFindFirstArgs<ExtArgs>>): Prisma__locationtypeClient<$Result.GetResult<Prisma.$locationtypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Locationtype that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationtypeFindFirstOrThrowArgs} args - Arguments to find a Locationtype
     * @example
     * // Get one Locationtype
     * const locationtype = await prisma.locationtype.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends locationtypeFindFirstOrThrowArgs>(args?: SelectSubset<T, locationtypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__locationtypeClient<$Result.GetResult<Prisma.$locationtypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locationtypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationtypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locationtypes
     * const locationtypes = await prisma.locationtype.findMany()
     * 
     * // Get first 10 Locationtypes
     * const locationtypes = await prisma.locationtype.findMany({ take: 10 })
     * 
     * // Only select the `locationtype_id`
     * const locationtypeWithLocationtype_idOnly = await prisma.locationtype.findMany({ select: { locationtype_id: true } })
     * 
     */
    findMany<T extends locationtypeFindManyArgs>(args?: SelectSubset<T, locationtypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationtypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Locationtype.
     * @param {locationtypeCreateArgs} args - Arguments to create a Locationtype.
     * @example
     * // Create one Locationtype
     * const Locationtype = await prisma.locationtype.create({
     *   data: {
     *     // ... data to create a Locationtype
     *   }
     * })
     * 
     */
    create<T extends locationtypeCreateArgs>(args: SelectSubset<T, locationtypeCreateArgs<ExtArgs>>): Prisma__locationtypeClient<$Result.GetResult<Prisma.$locationtypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locationtypes.
     * @param {locationtypeCreateManyArgs} args - Arguments to create many Locationtypes.
     * @example
     * // Create many Locationtypes
     * const locationtype = await prisma.locationtype.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends locationtypeCreateManyArgs>(args?: SelectSubset<T, locationtypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locationtypes and returns the data saved in the database.
     * @param {locationtypeCreateManyAndReturnArgs} args - Arguments to create many Locationtypes.
     * @example
     * // Create many Locationtypes
     * const locationtype = await prisma.locationtype.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locationtypes and only return the `locationtype_id`
     * const locationtypeWithLocationtype_idOnly = await prisma.locationtype.createManyAndReturn({
     *   select: { locationtype_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends locationtypeCreateManyAndReturnArgs>(args?: SelectSubset<T, locationtypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationtypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Locationtype.
     * @param {locationtypeDeleteArgs} args - Arguments to delete one Locationtype.
     * @example
     * // Delete one Locationtype
     * const Locationtype = await prisma.locationtype.delete({
     *   where: {
     *     // ... filter to delete one Locationtype
     *   }
     * })
     * 
     */
    delete<T extends locationtypeDeleteArgs>(args: SelectSubset<T, locationtypeDeleteArgs<ExtArgs>>): Prisma__locationtypeClient<$Result.GetResult<Prisma.$locationtypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Locationtype.
     * @param {locationtypeUpdateArgs} args - Arguments to update one Locationtype.
     * @example
     * // Update one Locationtype
     * const locationtype = await prisma.locationtype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends locationtypeUpdateArgs>(args: SelectSubset<T, locationtypeUpdateArgs<ExtArgs>>): Prisma__locationtypeClient<$Result.GetResult<Prisma.$locationtypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locationtypes.
     * @param {locationtypeDeleteManyArgs} args - Arguments to filter Locationtypes to delete.
     * @example
     * // Delete a few Locationtypes
     * const { count } = await prisma.locationtype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends locationtypeDeleteManyArgs>(args?: SelectSubset<T, locationtypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locationtypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationtypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locationtypes
     * const locationtype = await prisma.locationtype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends locationtypeUpdateManyArgs>(args: SelectSubset<T, locationtypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locationtypes and returns the data updated in the database.
     * @param {locationtypeUpdateManyAndReturnArgs} args - Arguments to update many Locationtypes.
     * @example
     * // Update many Locationtypes
     * const locationtype = await prisma.locationtype.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locationtypes and only return the `locationtype_id`
     * const locationtypeWithLocationtype_idOnly = await prisma.locationtype.updateManyAndReturn({
     *   select: { locationtype_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends locationtypeUpdateManyAndReturnArgs>(args: SelectSubset<T, locationtypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationtypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Locationtype.
     * @param {locationtypeUpsertArgs} args - Arguments to update or create a Locationtype.
     * @example
     * // Update or create a Locationtype
     * const locationtype = await prisma.locationtype.upsert({
     *   create: {
     *     // ... data to create a Locationtype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locationtype we want to update
     *   }
     * })
     */
    upsert<T extends locationtypeUpsertArgs>(args: SelectSubset<T, locationtypeUpsertArgs<ExtArgs>>): Prisma__locationtypeClient<$Result.GetResult<Prisma.$locationtypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locationtypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationtypeCountArgs} args - Arguments to filter Locationtypes to count.
     * @example
     * // Count the number of Locationtypes
     * const count = await prisma.locationtype.count({
     *   where: {
     *     // ... the filter for the Locationtypes we want to count
     *   }
     * })
    **/
    count<T extends locationtypeCountArgs>(
      args?: Subset<T, locationtypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationtypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locationtype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationtypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationtypeAggregateArgs>(args: Subset<T, LocationtypeAggregateArgs>): Prisma.PrismaPromise<GetLocationtypeAggregateType<T>>

    /**
     * Group by Locationtype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationtypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends locationtypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: locationtypeGroupByArgs['orderBy'] }
        : { orderBy?: locationtypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, locationtypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationtypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the locationtype model
   */
  readonly fields: locationtypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for locationtype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__locationtypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends locationtype$locationArgs<ExtArgs> = {}>(args?: Subset<T, locationtype$locationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the locationtype model
   */
  interface locationtypeFieldRefs {
    readonly locationtype_id: FieldRef<"locationtype", 'String'>
    readonly description: FieldRef<"locationtype", 'String'>
  }
    

  // Custom InputTypes
  /**
   * locationtype findUnique
   */
  export type locationtypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locationtype
     */
    select?: locationtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locationtype
     */
    omit?: locationtypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationtypeInclude<ExtArgs> | null
    /**
     * Filter, which locationtype to fetch.
     */
    where: locationtypeWhereUniqueInput
  }

  /**
   * locationtype findUniqueOrThrow
   */
  export type locationtypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locationtype
     */
    select?: locationtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locationtype
     */
    omit?: locationtypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationtypeInclude<ExtArgs> | null
    /**
     * Filter, which locationtype to fetch.
     */
    where: locationtypeWhereUniqueInput
  }

  /**
   * locationtype findFirst
   */
  export type locationtypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locationtype
     */
    select?: locationtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locationtype
     */
    omit?: locationtypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationtypeInclude<ExtArgs> | null
    /**
     * Filter, which locationtype to fetch.
     */
    where?: locationtypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locationtypes to fetch.
     */
    orderBy?: locationtypeOrderByWithRelationInput | locationtypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locationtypes.
     */
    cursor?: locationtypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locationtypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locationtypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locationtypes.
     */
    distinct?: LocationtypeScalarFieldEnum | LocationtypeScalarFieldEnum[]
  }

  /**
   * locationtype findFirstOrThrow
   */
  export type locationtypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locationtype
     */
    select?: locationtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locationtype
     */
    omit?: locationtypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationtypeInclude<ExtArgs> | null
    /**
     * Filter, which locationtype to fetch.
     */
    where?: locationtypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locationtypes to fetch.
     */
    orderBy?: locationtypeOrderByWithRelationInput | locationtypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locationtypes.
     */
    cursor?: locationtypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locationtypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locationtypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locationtypes.
     */
    distinct?: LocationtypeScalarFieldEnum | LocationtypeScalarFieldEnum[]
  }

  /**
   * locationtype findMany
   */
  export type locationtypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locationtype
     */
    select?: locationtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locationtype
     */
    omit?: locationtypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationtypeInclude<ExtArgs> | null
    /**
     * Filter, which locationtypes to fetch.
     */
    where?: locationtypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locationtypes to fetch.
     */
    orderBy?: locationtypeOrderByWithRelationInput | locationtypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locationtypes.
     */
    cursor?: locationtypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locationtypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locationtypes.
     */
    skip?: number
    distinct?: LocationtypeScalarFieldEnum | LocationtypeScalarFieldEnum[]
  }

  /**
   * locationtype create
   */
  export type locationtypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locationtype
     */
    select?: locationtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locationtype
     */
    omit?: locationtypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationtypeInclude<ExtArgs> | null
    /**
     * The data needed to create a locationtype.
     */
    data: XOR<locationtypeCreateInput, locationtypeUncheckedCreateInput>
  }

  /**
   * locationtype createMany
   */
  export type locationtypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many locationtypes.
     */
    data: locationtypeCreateManyInput | locationtypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * locationtype createManyAndReturn
   */
  export type locationtypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locationtype
     */
    select?: locationtypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the locationtype
     */
    omit?: locationtypeOmit<ExtArgs> | null
    /**
     * The data used to create many locationtypes.
     */
    data: locationtypeCreateManyInput | locationtypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * locationtype update
   */
  export type locationtypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locationtype
     */
    select?: locationtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locationtype
     */
    omit?: locationtypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationtypeInclude<ExtArgs> | null
    /**
     * The data needed to update a locationtype.
     */
    data: XOR<locationtypeUpdateInput, locationtypeUncheckedUpdateInput>
    /**
     * Choose, which locationtype to update.
     */
    where: locationtypeWhereUniqueInput
  }

  /**
   * locationtype updateMany
   */
  export type locationtypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update locationtypes.
     */
    data: XOR<locationtypeUpdateManyMutationInput, locationtypeUncheckedUpdateManyInput>
    /**
     * Filter which locationtypes to update
     */
    where?: locationtypeWhereInput
    /**
     * Limit how many locationtypes to update.
     */
    limit?: number
  }

  /**
   * locationtype updateManyAndReturn
   */
  export type locationtypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locationtype
     */
    select?: locationtypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the locationtype
     */
    omit?: locationtypeOmit<ExtArgs> | null
    /**
     * The data used to update locationtypes.
     */
    data: XOR<locationtypeUpdateManyMutationInput, locationtypeUncheckedUpdateManyInput>
    /**
     * Filter which locationtypes to update
     */
    where?: locationtypeWhereInput
    /**
     * Limit how many locationtypes to update.
     */
    limit?: number
  }

  /**
   * locationtype upsert
   */
  export type locationtypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locationtype
     */
    select?: locationtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locationtype
     */
    omit?: locationtypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationtypeInclude<ExtArgs> | null
    /**
     * The filter to search for the locationtype to update in case it exists.
     */
    where: locationtypeWhereUniqueInput
    /**
     * In case the locationtype found by the `where` argument doesn't exist, create a new locationtype with this data.
     */
    create: XOR<locationtypeCreateInput, locationtypeUncheckedCreateInput>
    /**
     * In case the locationtype was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locationtypeUpdateInput, locationtypeUncheckedUpdateInput>
  }

  /**
   * locationtype delete
   */
  export type locationtypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locationtype
     */
    select?: locationtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locationtype
     */
    omit?: locationtypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationtypeInclude<ExtArgs> | null
    /**
     * Filter which locationtype to delete.
     */
    where: locationtypeWhereUniqueInput
  }

  /**
   * locationtype deleteMany
   */
  export type locationtypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locationtypes to delete
     */
    where?: locationtypeWhereInput
    /**
     * Limit how many locationtypes to delete.
     */
    limit?: number
  }

  /**
   * locationtype.location
   */
  export type locationtype$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the location
     */
    select?: locationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the location
     */
    omit?: locationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationInclude<ExtArgs> | null
    where?: locationWhereInput
    orderBy?: locationOrderByWithRelationInput | locationOrderByWithRelationInput[]
    cursor?: locationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * locationtype without action
   */
  export type locationtypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locationtype
     */
    select?: locationtypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locationtype
     */
    omit?: locationtypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: locationtypeInclude<ExtArgs> | null
  }


  /**
   * Model permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    permission_id: number | null
  }

  export type PermissionSumAggregateOutputType = {
    permission_id: number | null
  }

  export type PermissionMinAggregateOutputType = {
    permission_id: number | null
    permission_name: string | null
    description: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    permission_id: number | null
    permission_name: string | null
    description: string | null
  }

  export type PermissionCountAggregateOutputType = {
    permission_id: number
    permission_name: number
    description: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    permission_id?: true
  }

  export type PermissionSumAggregateInputType = {
    permission_id?: true
  }

  export type PermissionMinAggregateInputType = {
    permission_id?: true
    permission_name?: true
    description?: true
  }

  export type PermissionMaxAggregateInputType = {
    permission_id?: true
    permission_name?: true
    description?: true
  }

  export type PermissionCountAggregateInputType = {
    permission_id?: true
    permission_name?: true
    description?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permission to aggregate.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type permissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionWhereInput
    orderBy?: permissionOrderByWithAggregationInput | permissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: permissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    permission_id: number
    permission_name: string
    description: string | null
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends permissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type permissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    permission_name?: boolean
    description?: boolean
    rolepermission?: boolean | permission$rolepermissionArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type permissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    permission_name?: boolean
    description?: boolean
  }, ExtArgs["result"]["permission"]>

  export type permissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    permission_name?: boolean
    description?: boolean
  }, ExtArgs["result"]["permission"]>

  export type permissionSelectScalar = {
    permission_id?: boolean
    permission_name?: boolean
    description?: boolean
  }

  export type permissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"permission_id" | "permission_name" | "description", ExtArgs["result"]["permission"]>
  export type permissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolepermission?: boolean | permission$rolepermissionArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type permissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type permissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $permissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permission"
    objects: {
      rolepermission: Prisma.$rolepermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      permission_id: number
      permission_name: string
      description: string | null
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type permissionGetPayload<S extends boolean | null | undefined | permissionDefaultArgs> = $Result.GetResult<Prisma.$permissionPayload, S>

  type permissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<permissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface permissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permission'], meta: { name: 'permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {permissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissionFindUniqueArgs>(args: SelectSubset<T, permissionFindUniqueArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {permissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissionFindUniqueOrThrowArgs>(args: SelectSubset<T, permissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissionFindFirstArgs>(args?: SelectSubset<T, permissionFindFirstArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissionFindFirstOrThrowArgs>(args?: SelectSubset<T, permissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `permission_id`
     * const permissionWithPermission_idOnly = await prisma.permission.findMany({ select: { permission_id: true } })
     * 
     */
    findMany<T extends permissionFindManyArgs>(args?: SelectSubset<T, permissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {permissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends permissionCreateArgs>(args: SelectSubset<T, permissionCreateArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {permissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissionCreateManyArgs>(args?: SelectSubset<T, permissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {permissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `permission_id`
     * const permissionWithPermission_idOnly = await prisma.permission.createManyAndReturn({
     *   select: { permission_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends permissionCreateManyAndReturnArgs>(args?: SelectSubset<T, permissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {permissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends permissionDeleteArgs>(args: SelectSubset<T, permissionDeleteArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {permissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissionUpdateArgs>(args: SelectSubset<T, permissionUpdateArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {permissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissionDeleteManyArgs>(args?: SelectSubset<T, permissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissionUpdateManyArgs>(args: SelectSubset<T, permissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {permissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `permission_id`
     * const permissionWithPermission_idOnly = await prisma.permission.updateManyAndReturn({
     *   select: { permission_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends permissionUpdateManyAndReturnArgs>(args: SelectSubset<T, permissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {permissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends permissionUpsertArgs>(args: SelectSubset<T, permissionUpsertArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionCountArgs>(
      args?: Subset<T, permissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionGroupByArgs['orderBy'] }
        : { orderBy?: permissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permission model
   */
  readonly fields: permissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolepermission<T extends permission$rolepermissionArgs<ExtArgs> = {}>(args?: Subset<T, permission$rolepermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permission model
   */
  interface permissionFieldRefs {
    readonly permission_id: FieldRef<"permission", 'Int'>
    readonly permission_name: FieldRef<"permission", 'String'>
    readonly description: FieldRef<"permission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * permission findUnique
   */
  export type permissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission findUniqueOrThrow
   */
  export type permissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission findFirst
   */
  export type permissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission findFirstOrThrow
   */
  export type permissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission findMany
   */
  export type permissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionOrderByWithRelationInput | permissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * permission create
   */
  export type permissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The data needed to create a permission.
     */
    data: XOR<permissionCreateInput, permissionUncheckedCreateInput>
  }

  /**
   * permission createMany
   */
  export type permissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissions.
     */
    data: permissionCreateManyInput | permissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permission createManyAndReturn
   */
  export type permissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * The data used to create many permissions.
     */
    data: permissionCreateManyInput | permissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permission update
   */
  export type permissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The data needed to update a permission.
     */
    data: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
    /**
     * Choose, which permission to update.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission updateMany
   */
  export type permissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionWhereInput
    /**
     * Limit how many permissions to update.
     */
    limit?: number
  }

  /**
   * permission updateManyAndReturn
   */
  export type permissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionWhereInput
    /**
     * Limit how many permissions to update.
     */
    limit?: number
  }

  /**
   * permission upsert
   */
  export type permissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * The filter to search for the permission to update in case it exists.
     */
    where: permissionWhereUniqueInput
    /**
     * In case the permission found by the `where` argument doesn't exist, create a new permission with this data.
     */
    create: XOR<permissionCreateInput, permissionUncheckedCreateInput>
    /**
     * In case the permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
  }

  /**
   * permission delete
   */
  export type permissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
    /**
     * Filter which permission to delete.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission deleteMany
   */
  export type permissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionWhereInput
    /**
     * Limit how many permissions to delete.
     */
    limit?: number
  }

  /**
   * permission.rolepermission
   */
  export type permission$rolepermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    where?: rolepermissionWhereInput
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    cursor?: rolepermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolepermissionScalarFieldEnum | RolepermissionScalarFieldEnum[]
  }

  /**
   * permission without action
   */
  export type permissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permission
     */
    omit?: permissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionInclude<ExtArgs> | null
  }


  /**
   * Model question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    question_id: number | null
    quiz_id: number | null
  }

  export type QuestionSumAggregateOutputType = {
    question_id: number | null
    quiz_id: number | null
  }

  export type QuestionMinAggregateOutputType = {
    question_id: number | null
    question: string | null
    quiz_id: number | null
  }

  export type QuestionMaxAggregateOutputType = {
    question_id: number | null
    question: string | null
    quiz_id: number | null
  }

  export type QuestionCountAggregateOutputType = {
    question_id: number
    question: number
    quiz_id: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    question_id?: true
    quiz_id?: true
  }

  export type QuestionSumAggregateInputType = {
    question_id?: true
    quiz_id?: true
  }

  export type QuestionMinAggregateInputType = {
    question_id?: true
    question?: true
    quiz_id?: true
  }

  export type QuestionMaxAggregateInputType = {
    question_id?: true
    question?: true
    quiz_id?: true
  }

  export type QuestionCountAggregateInputType = {
    question_id?: true
    question?: true
    quiz_id?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which question to aggregate.
     */
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type questionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionWhereInput
    orderBy?: questionOrderByWithAggregationInput | questionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: questionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    question_id: number
    question: string
    quiz_id: number | null
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends questionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type questionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    question_id?: boolean
    question?: boolean
    quiz_id?: boolean
    quiz?: boolean | question$quizArgs<ExtArgs>
    questionoption?: boolean | question$questionoptionArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type questionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    question_id?: boolean
    question?: boolean
    quiz_id?: boolean
    quiz?: boolean | question$quizArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type questionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    question_id?: boolean
    question?: boolean
    quiz_id?: boolean
    quiz?: boolean | question$quizArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type questionSelectScalar = {
    question_id?: boolean
    question?: boolean
    quiz_id?: boolean
  }

  export type questionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"question_id" | "question" | "quiz_id", ExtArgs["result"]["question"]>
  export type questionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | question$quizArgs<ExtArgs>
    questionoption?: boolean | question$questionoptionArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type questionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | question$quizArgs<ExtArgs>
  }
  export type questionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | question$quizArgs<ExtArgs>
  }

  export type $questionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "question"
    objects: {
      quiz: Prisma.$quizPayload<ExtArgs> | null
      questionoption: Prisma.$questionoptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      question_id: number
      question: string
      quiz_id: number | null
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type questionGetPayload<S extends boolean | null | undefined | questionDefaultArgs> = $Result.GetResult<Prisma.$questionPayload, S>

  type questionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<questionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface questionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['question'], meta: { name: 'question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {questionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questionFindUniqueArgs>(args: SelectSubset<T, questionFindUniqueArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {questionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questionFindUniqueOrThrowArgs>(args: SelectSubset<T, questionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questionFindFirstArgs>(args?: SelectSubset<T, questionFindFirstArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questionFindFirstOrThrowArgs>(args?: SelectSubset<T, questionFindFirstOrThrowArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `question_id`
     * const questionWithQuestion_idOnly = await prisma.question.findMany({ select: { question_id: true } })
     * 
     */
    findMany<T extends questionFindManyArgs>(args?: SelectSubset<T, questionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Question.
     * @param {questionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends questionCreateArgs>(args: SelectSubset<T, questionCreateArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {questionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questionCreateManyArgs>(args?: SelectSubset<T, questionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {questionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `question_id`
     * const questionWithQuestion_idOnly = await prisma.question.createManyAndReturn({
     *   select: { question_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends questionCreateManyAndReturnArgs>(args?: SelectSubset<T, questionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Question.
     * @param {questionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends questionDeleteArgs>(args: SelectSubset<T, questionDeleteArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Question.
     * @param {questionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questionUpdateArgs>(args: SelectSubset<T, questionUpdateArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {questionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questionDeleteManyArgs>(args?: SelectSubset<T, questionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questionUpdateManyArgs>(args: SelectSubset<T, questionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions and returns the data updated in the database.
     * @param {questionUpdateManyAndReturnArgs} args - Arguments to update many Questions.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questions and only return the `question_id`
     * const questionWithQuestion_idOnly = await prisma.question.updateManyAndReturn({
     *   select: { question_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends questionUpdateManyAndReturnArgs>(args: SelectSubset<T, questionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Question.
     * @param {questionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends questionUpsertArgs>(args: SelectSubset<T, questionUpsertArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends questionCountArgs>(
      args?: Subset<T, questionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionGroupByArgs['orderBy'] }
        : { orderBy?: questionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the question model
   */
  readonly fields: questionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends question$quizArgs<ExtArgs> = {}>(args?: Subset<T, question$quizArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    questionoption<T extends question$questionoptionArgs<ExtArgs> = {}>(args?: Subset<T, question$questionoptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionoptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the question model
   */
  interface questionFieldRefs {
    readonly question_id: FieldRef<"question", 'Int'>
    readonly question: FieldRef<"question", 'String'>
    readonly quiz_id: FieldRef<"question", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * question findUnique
   */
  export type questionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which question to fetch.
     */
    where: questionWhereUniqueInput
  }

  /**
   * question findUniqueOrThrow
   */
  export type questionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which question to fetch.
     */
    where: questionWhereUniqueInput
  }

  /**
   * question findFirst
   */
  export type questionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which question to fetch.
     */
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * question findFirstOrThrow
   */
  export type questionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which question to fetch.
     */
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * question findMany
   */
  export type questionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions.
     */
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * question create
   */
  export type questionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * The data needed to create a question.
     */
    data: XOR<questionCreateInput, questionUncheckedCreateInput>
  }

  /**
   * question createMany
   */
  export type questionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questions.
     */
    data: questionCreateManyInput | questionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * question createManyAndReturn
   */
  export type questionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * The data used to create many questions.
     */
    data: questionCreateManyInput | questionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * question update
   */
  export type questionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * The data needed to update a question.
     */
    data: XOR<questionUpdateInput, questionUncheckedUpdateInput>
    /**
     * Choose, which question to update.
     */
    where: questionWhereUniqueInput
  }

  /**
   * question updateMany
   */
  export type questionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questions.
     */
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     */
    where?: questionWhereInput
    /**
     * Limit how many questions to update.
     */
    limit?: number
  }

  /**
   * question updateManyAndReturn
   */
  export type questionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * The data used to update questions.
     */
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     */
    where?: questionWhereInput
    /**
     * Limit how many questions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * question upsert
   */
  export type questionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * The filter to search for the question to update in case it exists.
     */
    where: questionWhereUniqueInput
    /**
     * In case the question found by the `where` argument doesn't exist, create a new question with this data.
     */
    create: XOR<questionCreateInput, questionUncheckedCreateInput>
    /**
     * In case the question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionUpdateInput, questionUncheckedUpdateInput>
  }

  /**
   * question delete
   */
  export type questionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter which question to delete.
     */
    where: questionWhereUniqueInput
  }

  /**
   * question deleteMany
   */
  export type questionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to delete
     */
    where?: questionWhereInput
    /**
     * Limit how many questions to delete.
     */
    limit?: number
  }

  /**
   * question.quiz
   */
  export type question$quizArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    where?: quizWhereInput
  }

  /**
   * question.questionoption
   */
  export type question$questionoptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionoption
     */
    select?: questionoptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionoption
     */
    omit?: questionoptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionoptionInclude<ExtArgs> | null
    where?: questionoptionWhereInput
    orderBy?: questionoptionOrderByWithRelationInput | questionoptionOrderByWithRelationInput[]
    cursor?: questionoptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionoptionScalarFieldEnum | QuestionoptionScalarFieldEnum[]
  }

  /**
   * question without action
   */
  export type questionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
  }


  /**
   * Model questionoption
   */

  export type AggregateQuestionoption = {
    _count: QuestionoptionCountAggregateOutputType | null
    _avg: QuestionoptionAvgAggregateOutputType | null
    _sum: QuestionoptionSumAggregateOutputType | null
    _min: QuestionoptionMinAggregateOutputType | null
    _max: QuestionoptionMaxAggregateOutputType | null
  }

  export type QuestionoptionAvgAggregateOutputType = {
    option_id: number | null
    question_id: number | null
  }

  export type QuestionoptionSumAggregateOutputType = {
    option_id: number | null
    question_id: number | null
  }

  export type QuestionoptionMinAggregateOutputType = {
    option_id: number | null
    option: string | null
    is_correct: boolean | null
    question_id: number | null
  }

  export type QuestionoptionMaxAggregateOutputType = {
    option_id: number | null
    option: string | null
    is_correct: boolean | null
    question_id: number | null
  }

  export type QuestionoptionCountAggregateOutputType = {
    option_id: number
    option: number
    is_correct: number
    question_id: number
    _all: number
  }


  export type QuestionoptionAvgAggregateInputType = {
    option_id?: true
    question_id?: true
  }

  export type QuestionoptionSumAggregateInputType = {
    option_id?: true
    question_id?: true
  }

  export type QuestionoptionMinAggregateInputType = {
    option_id?: true
    option?: true
    is_correct?: true
    question_id?: true
  }

  export type QuestionoptionMaxAggregateInputType = {
    option_id?: true
    option?: true
    is_correct?: true
    question_id?: true
  }

  export type QuestionoptionCountAggregateInputType = {
    option_id?: true
    option?: true
    is_correct?: true
    question_id?: true
    _all?: true
  }

  export type QuestionoptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questionoption to aggregate.
     */
    where?: questionoptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionoptions to fetch.
     */
    orderBy?: questionoptionOrderByWithRelationInput | questionoptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionoptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionoptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionoptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questionoptions
    **/
    _count?: true | QuestionoptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionoptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionoptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionoptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionoptionMaxAggregateInputType
  }

  export type GetQuestionoptionAggregateType<T extends QuestionoptionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionoption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionoption[P]>
      : GetScalarType<T[P], AggregateQuestionoption[P]>
  }




  export type questionoptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionoptionWhereInput
    orderBy?: questionoptionOrderByWithAggregationInput | questionoptionOrderByWithAggregationInput[]
    by: QuestionoptionScalarFieldEnum[] | QuestionoptionScalarFieldEnum
    having?: questionoptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionoptionCountAggregateInputType | true
    _avg?: QuestionoptionAvgAggregateInputType
    _sum?: QuestionoptionSumAggregateInputType
    _min?: QuestionoptionMinAggregateInputType
    _max?: QuestionoptionMaxAggregateInputType
  }

  export type QuestionoptionGroupByOutputType = {
    option_id: number
    option: string
    is_correct: boolean
    question_id: number
    _count: QuestionoptionCountAggregateOutputType | null
    _avg: QuestionoptionAvgAggregateOutputType | null
    _sum: QuestionoptionSumAggregateOutputType | null
    _min: QuestionoptionMinAggregateOutputType | null
    _max: QuestionoptionMaxAggregateOutputType | null
  }

  type GetQuestionoptionGroupByPayload<T extends questionoptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionoptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionoptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionoptionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionoptionGroupByOutputType[P]>
        }
      >
    >


  export type questionoptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    option_id?: boolean
    option?: boolean
    is_correct?: boolean
    question_id?: boolean
    question?: boolean | questionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionoption"]>

  export type questionoptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    option_id?: boolean
    option?: boolean
    is_correct?: boolean
    question_id?: boolean
    question?: boolean | questionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionoption"]>

  export type questionoptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    option_id?: boolean
    option?: boolean
    is_correct?: boolean
    question_id?: boolean
    question?: boolean | questionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionoption"]>

  export type questionoptionSelectScalar = {
    option_id?: boolean
    option?: boolean
    is_correct?: boolean
    question_id?: boolean
  }

  export type questionoptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"option_id" | "option" | "is_correct" | "question_id", ExtArgs["result"]["questionoption"]>
  export type questionoptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | questionDefaultArgs<ExtArgs>
  }
  export type questionoptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | questionDefaultArgs<ExtArgs>
  }
  export type questionoptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | questionDefaultArgs<ExtArgs>
  }

  export type $questionoptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questionoption"
    objects: {
      question: Prisma.$questionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      option_id: number
      option: string
      is_correct: boolean
      question_id: number
    }, ExtArgs["result"]["questionoption"]>
    composites: {}
  }

  type questionoptionGetPayload<S extends boolean | null | undefined | questionoptionDefaultArgs> = $Result.GetResult<Prisma.$questionoptionPayload, S>

  type questionoptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<questionoptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionoptionCountAggregateInputType | true
    }

  export interface questionoptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questionoption'], meta: { name: 'questionoption' } }
    /**
     * Find zero or one Questionoption that matches the filter.
     * @param {questionoptionFindUniqueArgs} args - Arguments to find a Questionoption
     * @example
     * // Get one Questionoption
     * const questionoption = await prisma.questionoption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questionoptionFindUniqueArgs>(args: SelectSubset<T, questionoptionFindUniqueArgs<ExtArgs>>): Prisma__questionoptionClient<$Result.GetResult<Prisma.$questionoptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Questionoption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {questionoptionFindUniqueOrThrowArgs} args - Arguments to find a Questionoption
     * @example
     * // Get one Questionoption
     * const questionoption = await prisma.questionoption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questionoptionFindUniqueOrThrowArgs>(args: SelectSubset<T, questionoptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questionoptionClient<$Result.GetResult<Prisma.$questionoptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Questionoption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionoptionFindFirstArgs} args - Arguments to find a Questionoption
     * @example
     * // Get one Questionoption
     * const questionoption = await prisma.questionoption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questionoptionFindFirstArgs>(args?: SelectSubset<T, questionoptionFindFirstArgs<ExtArgs>>): Prisma__questionoptionClient<$Result.GetResult<Prisma.$questionoptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Questionoption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionoptionFindFirstOrThrowArgs} args - Arguments to find a Questionoption
     * @example
     * // Get one Questionoption
     * const questionoption = await prisma.questionoption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questionoptionFindFirstOrThrowArgs>(args?: SelectSubset<T, questionoptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__questionoptionClient<$Result.GetResult<Prisma.$questionoptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questionoptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionoptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questionoptions
     * const questionoptions = await prisma.questionoption.findMany()
     * 
     * // Get first 10 Questionoptions
     * const questionoptions = await prisma.questionoption.findMany({ take: 10 })
     * 
     * // Only select the `option_id`
     * const questionoptionWithOption_idOnly = await prisma.questionoption.findMany({ select: { option_id: true } })
     * 
     */
    findMany<T extends questionoptionFindManyArgs>(args?: SelectSubset<T, questionoptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionoptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Questionoption.
     * @param {questionoptionCreateArgs} args - Arguments to create a Questionoption.
     * @example
     * // Create one Questionoption
     * const Questionoption = await prisma.questionoption.create({
     *   data: {
     *     // ... data to create a Questionoption
     *   }
     * })
     * 
     */
    create<T extends questionoptionCreateArgs>(args: SelectSubset<T, questionoptionCreateArgs<ExtArgs>>): Prisma__questionoptionClient<$Result.GetResult<Prisma.$questionoptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questionoptions.
     * @param {questionoptionCreateManyArgs} args - Arguments to create many Questionoptions.
     * @example
     * // Create many Questionoptions
     * const questionoption = await prisma.questionoption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questionoptionCreateManyArgs>(args?: SelectSubset<T, questionoptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questionoptions and returns the data saved in the database.
     * @param {questionoptionCreateManyAndReturnArgs} args - Arguments to create many Questionoptions.
     * @example
     * // Create many Questionoptions
     * const questionoption = await prisma.questionoption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questionoptions and only return the `option_id`
     * const questionoptionWithOption_idOnly = await prisma.questionoption.createManyAndReturn({
     *   select: { option_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends questionoptionCreateManyAndReturnArgs>(args?: SelectSubset<T, questionoptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionoptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Questionoption.
     * @param {questionoptionDeleteArgs} args - Arguments to delete one Questionoption.
     * @example
     * // Delete one Questionoption
     * const Questionoption = await prisma.questionoption.delete({
     *   where: {
     *     // ... filter to delete one Questionoption
     *   }
     * })
     * 
     */
    delete<T extends questionoptionDeleteArgs>(args: SelectSubset<T, questionoptionDeleteArgs<ExtArgs>>): Prisma__questionoptionClient<$Result.GetResult<Prisma.$questionoptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Questionoption.
     * @param {questionoptionUpdateArgs} args - Arguments to update one Questionoption.
     * @example
     * // Update one Questionoption
     * const questionoption = await prisma.questionoption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questionoptionUpdateArgs>(args: SelectSubset<T, questionoptionUpdateArgs<ExtArgs>>): Prisma__questionoptionClient<$Result.GetResult<Prisma.$questionoptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questionoptions.
     * @param {questionoptionDeleteManyArgs} args - Arguments to filter Questionoptions to delete.
     * @example
     * // Delete a few Questionoptions
     * const { count } = await prisma.questionoption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questionoptionDeleteManyArgs>(args?: SelectSubset<T, questionoptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questionoptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionoptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questionoptions
     * const questionoption = await prisma.questionoption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questionoptionUpdateManyArgs>(args: SelectSubset<T, questionoptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questionoptions and returns the data updated in the database.
     * @param {questionoptionUpdateManyAndReturnArgs} args - Arguments to update many Questionoptions.
     * @example
     * // Update many Questionoptions
     * const questionoption = await prisma.questionoption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questionoptions and only return the `option_id`
     * const questionoptionWithOption_idOnly = await prisma.questionoption.updateManyAndReturn({
     *   select: { option_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends questionoptionUpdateManyAndReturnArgs>(args: SelectSubset<T, questionoptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionoptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Questionoption.
     * @param {questionoptionUpsertArgs} args - Arguments to update or create a Questionoption.
     * @example
     * // Update or create a Questionoption
     * const questionoption = await prisma.questionoption.upsert({
     *   create: {
     *     // ... data to create a Questionoption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questionoption we want to update
     *   }
     * })
     */
    upsert<T extends questionoptionUpsertArgs>(args: SelectSubset<T, questionoptionUpsertArgs<ExtArgs>>): Prisma__questionoptionClient<$Result.GetResult<Prisma.$questionoptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questionoptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionoptionCountArgs} args - Arguments to filter Questionoptions to count.
     * @example
     * // Count the number of Questionoptions
     * const count = await prisma.questionoption.count({
     *   where: {
     *     // ... the filter for the Questionoptions we want to count
     *   }
     * })
    **/
    count<T extends questionoptionCountArgs>(
      args?: Subset<T, questionoptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionoptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questionoption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionoptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionoptionAggregateArgs>(args: Subset<T, QuestionoptionAggregateArgs>): Prisma.PrismaPromise<GetQuestionoptionAggregateType<T>>

    /**
     * Group by Questionoption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionoptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionoptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionoptionGroupByArgs['orderBy'] }
        : { orderBy?: questionoptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionoptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionoptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questionoption model
   */
  readonly fields: questionoptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questionoption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionoptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends questionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, questionDefaultArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questionoption model
   */
  interface questionoptionFieldRefs {
    readonly option_id: FieldRef<"questionoption", 'Int'>
    readonly option: FieldRef<"questionoption", 'String'>
    readonly is_correct: FieldRef<"questionoption", 'Boolean'>
    readonly question_id: FieldRef<"questionoption", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * questionoption findUnique
   */
  export type questionoptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionoption
     */
    select?: questionoptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionoption
     */
    omit?: questionoptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionoptionInclude<ExtArgs> | null
    /**
     * Filter, which questionoption to fetch.
     */
    where: questionoptionWhereUniqueInput
  }

  /**
   * questionoption findUniqueOrThrow
   */
  export type questionoptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionoption
     */
    select?: questionoptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionoption
     */
    omit?: questionoptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionoptionInclude<ExtArgs> | null
    /**
     * Filter, which questionoption to fetch.
     */
    where: questionoptionWhereUniqueInput
  }

  /**
   * questionoption findFirst
   */
  export type questionoptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionoption
     */
    select?: questionoptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionoption
     */
    omit?: questionoptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionoptionInclude<ExtArgs> | null
    /**
     * Filter, which questionoption to fetch.
     */
    where?: questionoptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionoptions to fetch.
     */
    orderBy?: questionoptionOrderByWithRelationInput | questionoptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questionoptions.
     */
    cursor?: questionoptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionoptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionoptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questionoptions.
     */
    distinct?: QuestionoptionScalarFieldEnum | QuestionoptionScalarFieldEnum[]
  }

  /**
   * questionoption findFirstOrThrow
   */
  export type questionoptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionoption
     */
    select?: questionoptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionoption
     */
    omit?: questionoptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionoptionInclude<ExtArgs> | null
    /**
     * Filter, which questionoption to fetch.
     */
    where?: questionoptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionoptions to fetch.
     */
    orderBy?: questionoptionOrderByWithRelationInput | questionoptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questionoptions.
     */
    cursor?: questionoptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionoptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionoptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questionoptions.
     */
    distinct?: QuestionoptionScalarFieldEnum | QuestionoptionScalarFieldEnum[]
  }

  /**
   * questionoption findMany
   */
  export type questionoptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionoption
     */
    select?: questionoptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionoption
     */
    omit?: questionoptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionoptionInclude<ExtArgs> | null
    /**
     * Filter, which questionoptions to fetch.
     */
    where?: questionoptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questionoptions to fetch.
     */
    orderBy?: questionoptionOrderByWithRelationInput | questionoptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questionoptions.
     */
    cursor?: questionoptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questionoptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questionoptions.
     */
    skip?: number
    distinct?: QuestionoptionScalarFieldEnum | QuestionoptionScalarFieldEnum[]
  }

  /**
   * questionoption create
   */
  export type questionoptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionoption
     */
    select?: questionoptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionoption
     */
    omit?: questionoptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionoptionInclude<ExtArgs> | null
    /**
     * The data needed to create a questionoption.
     */
    data: XOR<questionoptionCreateInput, questionoptionUncheckedCreateInput>
  }

  /**
   * questionoption createMany
   */
  export type questionoptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questionoptions.
     */
    data: questionoptionCreateManyInput | questionoptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * questionoption createManyAndReturn
   */
  export type questionoptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionoption
     */
    select?: questionoptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the questionoption
     */
    omit?: questionoptionOmit<ExtArgs> | null
    /**
     * The data used to create many questionoptions.
     */
    data: questionoptionCreateManyInput | questionoptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionoptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * questionoption update
   */
  export type questionoptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionoption
     */
    select?: questionoptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionoption
     */
    omit?: questionoptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionoptionInclude<ExtArgs> | null
    /**
     * The data needed to update a questionoption.
     */
    data: XOR<questionoptionUpdateInput, questionoptionUncheckedUpdateInput>
    /**
     * Choose, which questionoption to update.
     */
    where: questionoptionWhereUniqueInput
  }

  /**
   * questionoption updateMany
   */
  export type questionoptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questionoptions.
     */
    data: XOR<questionoptionUpdateManyMutationInput, questionoptionUncheckedUpdateManyInput>
    /**
     * Filter which questionoptions to update
     */
    where?: questionoptionWhereInput
    /**
     * Limit how many questionoptions to update.
     */
    limit?: number
  }

  /**
   * questionoption updateManyAndReturn
   */
  export type questionoptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionoption
     */
    select?: questionoptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the questionoption
     */
    omit?: questionoptionOmit<ExtArgs> | null
    /**
     * The data used to update questionoptions.
     */
    data: XOR<questionoptionUpdateManyMutationInput, questionoptionUncheckedUpdateManyInput>
    /**
     * Filter which questionoptions to update
     */
    where?: questionoptionWhereInput
    /**
     * Limit how many questionoptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionoptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * questionoption upsert
   */
  export type questionoptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionoption
     */
    select?: questionoptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionoption
     */
    omit?: questionoptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionoptionInclude<ExtArgs> | null
    /**
     * The filter to search for the questionoption to update in case it exists.
     */
    where: questionoptionWhereUniqueInput
    /**
     * In case the questionoption found by the `where` argument doesn't exist, create a new questionoption with this data.
     */
    create: XOR<questionoptionCreateInput, questionoptionUncheckedCreateInput>
    /**
     * In case the questionoption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionoptionUpdateInput, questionoptionUncheckedUpdateInput>
  }

  /**
   * questionoption delete
   */
  export type questionoptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionoption
     */
    select?: questionoptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionoption
     */
    omit?: questionoptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionoptionInclude<ExtArgs> | null
    /**
     * Filter which questionoption to delete.
     */
    where: questionoptionWhereUniqueInput
  }

  /**
   * questionoption deleteMany
   */
  export type questionoptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questionoptions to delete
     */
    where?: questionoptionWhereInput
    /**
     * Limit how many questionoptions to delete.
     */
    limit?: number
  }

  /**
   * questionoption without action
   */
  export type questionoptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questionoption
     */
    select?: questionoptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questionoption
     */
    omit?: questionoptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionoptionInclude<ExtArgs> | null
  }


  /**
   * Model quiz
   */

  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizAvgAggregateOutputType = {
    quiz_id: number | null
  }

  export type QuizSumAggregateOutputType = {
    quiz_id: number | null
  }

  export type QuizMinAggregateOutputType = {
    quiz_id: number | null
    quiz_title: string | null
    description: string | null
  }

  export type QuizMaxAggregateOutputType = {
    quiz_id: number | null
    quiz_title: string | null
    description: string | null
  }

  export type QuizCountAggregateOutputType = {
    quiz_id: number
    quiz_title: number
    description: number
    _all: number
  }


  export type QuizAvgAggregateInputType = {
    quiz_id?: true
  }

  export type QuizSumAggregateInputType = {
    quiz_id?: true
  }

  export type QuizMinAggregateInputType = {
    quiz_id?: true
    quiz_title?: true
    description?: true
  }

  export type QuizMaxAggregateInputType = {
    quiz_id?: true
    quiz_title?: true
    description?: true
  }

  export type QuizCountAggregateInputType = {
    quiz_id?: true
    quiz_title?: true
    description?: true
    _all?: true
  }

  export type QuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quiz to aggregate.
     */
    where?: quizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     */
    orderBy?: quizOrderByWithRelationInput | quizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type quizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quizWhereInput
    orderBy?: quizOrderByWithAggregationInput | quizOrderByWithAggregationInput[]
    by: QuizScalarFieldEnum[] | QuizScalarFieldEnum
    having?: quizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _avg?: QuizAvgAggregateInputType
    _sum?: QuizSumAggregateInputType
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }

  export type QuizGroupByOutputType = {
    quiz_id: number
    quiz_title: string
    description: string | null
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends quizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type quizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    quiz_id?: boolean
    quiz_title?: boolean
    description?: boolean
    checkpoint?: boolean | quiz$checkpointArgs<ExtArgs>
    question?: boolean | quiz$questionArgs<ExtArgs>
    userquizcompletion?: boolean | quiz$userquizcompletionArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type quizSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    quiz_id?: boolean
    quiz_title?: boolean
    description?: boolean
  }, ExtArgs["result"]["quiz"]>

  export type quizSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    quiz_id?: boolean
    quiz_title?: boolean
    description?: boolean
  }, ExtArgs["result"]["quiz"]>

  export type quizSelectScalar = {
    quiz_id?: boolean
    quiz_title?: boolean
    description?: boolean
  }

  export type quizOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"quiz_id" | "quiz_title" | "description", ExtArgs["result"]["quiz"]>
  export type quizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoint?: boolean | quiz$checkpointArgs<ExtArgs>
    question?: boolean | quiz$questionArgs<ExtArgs>
    userquizcompletion?: boolean | quiz$userquizcompletionArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type quizIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type quizIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $quizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quiz"
    objects: {
      checkpoint: Prisma.$checkpointPayload<ExtArgs>[]
      question: Prisma.$questionPayload<ExtArgs>[]
      userquizcompletion: Prisma.$userquizcompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      quiz_id: number
      quiz_title: string
      description: string | null
    }, ExtArgs["result"]["quiz"]>
    composites: {}
  }

  type quizGetPayload<S extends boolean | null | undefined | quizDefaultArgs> = $Result.GetResult<Prisma.$quizPayload, S>

  type quizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quizFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface quizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quiz'], meta: { name: 'quiz' } }
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {quizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quizFindUniqueArgs>(args: SelectSubset<T, quizFindUniqueArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quiz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quizFindUniqueOrThrowArgs>(args: SelectSubset<T, quizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quizFindFirstArgs>(args?: SelectSubset<T, quizFindFirstArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quizFindFirstOrThrowArgs>(args?: SelectSubset<T, quizFindFirstOrThrowArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `quiz_id`
     * const quizWithQuiz_idOnly = await prisma.quiz.findMany({ select: { quiz_id: true } })
     * 
     */
    findMany<T extends quizFindManyArgs>(args?: SelectSubset<T, quizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quiz.
     * @param {quizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
     */
    create<T extends quizCreateArgs>(args: SelectSubset<T, quizCreateArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quizzes.
     * @param {quizCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quizCreateManyArgs>(args?: SelectSubset<T, quizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quizzes and returns the data saved in the database.
     * @param {quizCreateManyAndReturnArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quizzes and only return the `quiz_id`
     * const quizWithQuiz_idOnly = await prisma.quiz.createManyAndReturn({
     *   select: { quiz_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends quizCreateManyAndReturnArgs>(args?: SelectSubset<T, quizCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quiz.
     * @param {quizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
     */
    delete<T extends quizDeleteArgs>(args: SelectSubset<T, quizDeleteArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quiz.
     * @param {quizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quizUpdateArgs>(args: SelectSubset<T, quizUpdateArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quizzes.
     * @param {quizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quizDeleteManyArgs>(args?: SelectSubset<T, quizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quizUpdateManyArgs>(args: SelectSubset<T, quizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes and returns the data updated in the database.
     * @param {quizUpdateManyAndReturnArgs} args - Arguments to update many Quizzes.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quizzes and only return the `quiz_id`
     * const quizWithQuiz_idOnly = await prisma.quiz.updateManyAndReturn({
     *   select: { quiz_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends quizUpdateManyAndReturnArgs>(args: SelectSubset<T, quizUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quiz.
     * @param {quizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
     */
    upsert<T extends quizUpsertArgs>(args: SelectSubset<T, quizUpsertArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends quizCountArgs>(
      args?: Subset<T, quizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quizGroupByArgs['orderBy'] }
        : { orderBy?: quizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quiz model
   */
  readonly fields: quizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    checkpoint<T extends quiz$checkpointArgs<ExtArgs> = {}>(args?: Subset<T, quiz$checkpointArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    question<T extends quiz$questionArgs<ExtArgs> = {}>(args?: Subset<T, quiz$questionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userquizcompletion<T extends quiz$userquizcompletionArgs<ExtArgs> = {}>(args?: Subset<T, quiz$userquizcompletionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userquizcompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quiz model
   */
  interface quizFieldRefs {
    readonly quiz_id: FieldRef<"quiz", 'Int'>
    readonly quiz_title: FieldRef<"quiz", 'String'>
    readonly description: FieldRef<"quiz", 'String'>
  }
    

  // Custom InputTypes
  /**
   * quiz findUnique
   */
  export type quizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * Filter, which quiz to fetch.
     */
    where: quizWhereUniqueInput
  }

  /**
   * quiz findUniqueOrThrow
   */
  export type quizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * Filter, which quiz to fetch.
     */
    where: quizWhereUniqueInput
  }

  /**
   * quiz findFirst
   */
  export type quizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * Filter, which quiz to fetch.
     */
    where?: quizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     */
    orderBy?: quizOrderByWithRelationInput | quizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quizzes.
     */
    cursor?: quizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * quiz findFirstOrThrow
   */
  export type quizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * Filter, which quiz to fetch.
     */
    where?: quizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     */
    orderBy?: quizOrderByWithRelationInput | quizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quizzes.
     */
    cursor?: quizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * quiz findMany
   */
  export type quizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * Filter, which quizzes to fetch.
     */
    where?: quizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     */
    orderBy?: quizOrderByWithRelationInput | quizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quizzes.
     */
    cursor?: quizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     */
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * quiz create
   */
  export type quizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * The data needed to create a quiz.
     */
    data: XOR<quizCreateInput, quizUncheckedCreateInput>
  }

  /**
   * quiz createMany
   */
  export type quizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quizzes.
     */
    data: quizCreateManyInput | quizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quiz createManyAndReturn
   */
  export type quizCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * The data used to create many quizzes.
     */
    data: quizCreateManyInput | quizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quiz update
   */
  export type quizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * The data needed to update a quiz.
     */
    data: XOR<quizUpdateInput, quizUncheckedUpdateInput>
    /**
     * Choose, which quiz to update.
     */
    where: quizWhereUniqueInput
  }

  /**
   * quiz updateMany
   */
  export type quizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quizzes.
     */
    data: XOR<quizUpdateManyMutationInput, quizUncheckedUpdateManyInput>
    /**
     * Filter which quizzes to update
     */
    where?: quizWhereInput
    /**
     * Limit how many quizzes to update.
     */
    limit?: number
  }

  /**
   * quiz updateManyAndReturn
   */
  export type quizUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * The data used to update quizzes.
     */
    data: XOR<quizUpdateManyMutationInput, quizUncheckedUpdateManyInput>
    /**
     * Filter which quizzes to update
     */
    where?: quizWhereInput
    /**
     * Limit how many quizzes to update.
     */
    limit?: number
  }

  /**
   * quiz upsert
   */
  export type quizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * The filter to search for the quiz to update in case it exists.
     */
    where: quizWhereUniqueInput
    /**
     * In case the quiz found by the `where` argument doesn't exist, create a new quiz with this data.
     */
    create: XOR<quizCreateInput, quizUncheckedCreateInput>
    /**
     * In case the quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quizUpdateInput, quizUncheckedUpdateInput>
  }

  /**
   * quiz delete
   */
  export type quizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
    /**
     * Filter which quiz to delete.
     */
    where: quizWhereUniqueInput
  }

  /**
   * quiz deleteMany
   */
  export type quizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quizzes to delete
     */
    where?: quizWhereInput
    /**
     * Limit how many quizzes to delete.
     */
    limit?: number
  }

  /**
   * quiz.checkpoint
   */
  export type quiz$checkpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointInclude<ExtArgs> | null
    where?: checkpointWhereInput
    orderBy?: checkpointOrderByWithRelationInput | checkpointOrderByWithRelationInput[]
    cursor?: checkpointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckpointScalarFieldEnum | CheckpointScalarFieldEnum[]
  }

  /**
   * quiz.question
   */
  export type quiz$questionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    where?: questionWhereInput
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    cursor?: questionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * quiz.userquizcompletion
   */
  export type quiz$userquizcompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionInclude<ExtArgs> | null
    where?: userquizcompletionWhereInput
    orderBy?: userquizcompletionOrderByWithRelationInput | userquizcompletionOrderByWithRelationInput[]
    cursor?: userquizcompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserquizcompletionScalarFieldEnum | UserquizcompletionScalarFieldEnum[]
  }

  /**
   * quiz without action
   */
  export type quizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz
     */
    select?: quizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz
     */
    omit?: quizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizInclude<ExtArgs> | null
  }


  /**
   * Model review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    review_id: number | null
    user_id: number | null
    tour_id: number | null
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    review_id: number | null
    user_id: number | null
    tour_id: number | null
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    review_id: number | null
    user_id: number | null
    tour_id: number | null
    review_text: string | null
    rating: number | null
    created_at: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    review_id: number | null
    user_id: number | null
    tour_id: number | null
    review_text: string | null
    rating: number | null
    created_at: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    review_id: number
    user_id: number
    tour_id: number
    review_text: number
    rating: number
    created_at: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    review_id?: true
    user_id?: true
    tour_id?: true
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    review_id?: true
    user_id?: true
    tour_id?: true
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    review_id?: true
    user_id?: true
    tour_id?: true
    review_text?: true
    rating?: true
    created_at?: true
  }

  export type ReviewMaxAggregateInputType = {
    review_id?: true
    user_id?: true
    tour_id?: true
    review_text?: true
    rating?: true
    created_at?: true
  }

  export type ReviewCountAggregateInputType = {
    review_id?: true
    user_id?: true
    tour_id?: true
    review_text?: true
    rating?: true
    created_at?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which review to aggregate.
     */
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewOrderByWithRelationInput | reviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type reviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewWhereInput
    orderBy?: reviewOrderByWithAggregationInput | reviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: reviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    review_id: number
    user_id: number | null
    tour_id: number
    review_text: string
    rating: number
    created_at: Date | null
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends reviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type reviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    review_id?: boolean
    user_id?: boolean
    tour_id?: boolean
    review_text?: boolean
    rating?: boolean
    created_at?: boolean
    tour?: boolean | tourDefaultArgs<ExtArgs>
    users?: boolean | review$usersArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type reviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    review_id?: boolean
    user_id?: boolean
    tour_id?: boolean
    review_text?: boolean
    rating?: boolean
    created_at?: boolean
    tour?: boolean | tourDefaultArgs<ExtArgs>
    users?: boolean | review$usersArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type reviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    review_id?: boolean
    user_id?: boolean
    tour_id?: boolean
    review_text?: boolean
    rating?: boolean
    created_at?: boolean
    tour?: boolean | tourDefaultArgs<ExtArgs>
    users?: boolean | review$usersArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type reviewSelectScalar = {
    review_id?: boolean
    user_id?: boolean
    tour_id?: boolean
    review_text?: boolean
    rating?: boolean
    created_at?: boolean
  }

  export type reviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"review_id" | "user_id" | "tour_id" | "review_text" | "rating" | "created_at", ExtArgs["result"]["review"]>
  export type reviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | tourDefaultArgs<ExtArgs>
    users?: boolean | review$usersArgs<ExtArgs>
  }
  export type reviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | tourDefaultArgs<ExtArgs>
    users?: boolean | review$usersArgs<ExtArgs>
  }
  export type reviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | tourDefaultArgs<ExtArgs>
    users?: boolean | review$usersArgs<ExtArgs>
  }

  export type $reviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "review"
    objects: {
      tour: Prisma.$tourPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      review_id: number
      user_id: number | null
      tour_id: number
      review_text: string
      rating: number
      created_at: Date | null
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type reviewGetPayload<S extends boolean | null | undefined | reviewDefaultArgs> = $Result.GetResult<Prisma.$reviewPayload, S>

  type reviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface reviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['review'], meta: { name: 'review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {reviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reviewFindUniqueArgs>(args: SelectSubset<T, reviewFindUniqueArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reviewFindUniqueOrThrowArgs>(args: SelectSubset<T, reviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reviewFindFirstArgs>(args?: SelectSubset<T, reviewFindFirstArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reviewFindFirstOrThrowArgs>(args?: SelectSubset<T, reviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `review_id`
     * const reviewWithReview_idOnly = await prisma.review.findMany({ select: { review_id: true } })
     * 
     */
    findMany<T extends reviewFindManyArgs>(args?: SelectSubset<T, reviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {reviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends reviewCreateArgs>(args: SelectSubset<T, reviewCreateArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {reviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reviewCreateManyArgs>(args?: SelectSubset<T, reviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {reviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `review_id`
     * const reviewWithReview_idOnly = await prisma.review.createManyAndReturn({
     *   select: { review_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reviewCreateManyAndReturnArgs>(args?: SelectSubset<T, reviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {reviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends reviewDeleteArgs>(args: SelectSubset<T, reviewDeleteArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {reviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reviewUpdateArgs>(args: SelectSubset<T, reviewUpdateArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {reviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reviewDeleteManyArgs>(args?: SelectSubset<T, reviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reviewUpdateManyArgs>(args: SelectSubset<T, reviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {reviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `review_id`
     * const reviewWithReview_idOnly = await prisma.review.updateManyAndReturn({
     *   select: { review_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reviewUpdateManyAndReturnArgs>(args: SelectSubset<T, reviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {reviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends reviewUpsertArgs>(args: SelectSubset<T, reviewUpsertArgs<ExtArgs>>): Prisma__reviewClient<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends reviewCountArgs>(
      args?: Subset<T, reviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reviewGroupByArgs['orderBy'] }
        : { orderBy?: reviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the review model
   */
  readonly fields: reviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tour<T extends tourDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tourDefaultArgs<ExtArgs>>): Prisma__tourClient<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends review$usersArgs<ExtArgs> = {}>(args?: Subset<T, review$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the review model
   */
  interface reviewFieldRefs {
    readonly review_id: FieldRef<"review", 'Int'>
    readonly user_id: FieldRef<"review", 'Int'>
    readonly tour_id: FieldRef<"review", 'Int'>
    readonly review_text: FieldRef<"review", 'String'>
    readonly rating: FieldRef<"review", 'Int'>
    readonly created_at: FieldRef<"review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * review findUnique
   */
  export type reviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * Filter, which review to fetch.
     */
    where: reviewWhereUniqueInput
  }

  /**
   * review findUniqueOrThrow
   */
  export type reviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * Filter, which review to fetch.
     */
    where: reviewWhereUniqueInput
  }

  /**
   * review findFirst
   */
  export type reviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * Filter, which review to fetch.
     */
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewOrderByWithRelationInput | reviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * review findFirstOrThrow
   */
  export type reviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * Filter, which review to fetch.
     */
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewOrderByWithRelationInput | reviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * review findMany
   */
  export type reviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewOrderByWithRelationInput | reviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews.
     */
    cursor?: reviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * review create
   */
  export type reviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * The data needed to create a review.
     */
    data: XOR<reviewCreateInput, reviewUncheckedCreateInput>
  }

  /**
   * review createMany
   */
  export type reviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reviews.
     */
    data: reviewCreateManyInput | reviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * review createManyAndReturn
   */
  export type reviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * The data used to create many reviews.
     */
    data: reviewCreateManyInput | reviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * review update
   */
  export type reviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * The data needed to update a review.
     */
    data: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
    /**
     * Choose, which review to update.
     */
    where: reviewWhereUniqueInput
  }

  /**
   * review updateMany
   */
  export type reviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewWhereInput
    /**
     * Limit how many reviews to update.
     */
    limit?: number
  }

  /**
   * review updateManyAndReturn
   */
  export type reviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewWhereInput
    /**
     * Limit how many reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * review upsert
   */
  export type reviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * The filter to search for the review to update in case it exists.
     */
    where: reviewWhereUniqueInput
    /**
     * In case the review found by the `where` argument doesn't exist, create a new review with this data.
     */
    create: XOR<reviewCreateInput, reviewUncheckedCreateInput>
    /**
     * In case the review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reviewUpdateInput, reviewUncheckedUpdateInput>
  }

  /**
   * review delete
   */
  export type reviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    /**
     * Filter which review to delete.
     */
    where: reviewWhereUniqueInput
  }

  /**
   * review deleteMany
   */
  export type reviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to delete
     */
    where?: reviewWhereInput
    /**
     * Limit how many reviews to delete.
     */
    limit?: number
  }

  /**
   * review.users
   */
  export type review$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * review without action
   */
  export type reviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
  }


  /**
   * Model role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    role_id: number | null
  }

  export type RoleSumAggregateOutputType = {
    role_id: number | null
  }

  export type RoleMinAggregateOutputType = {
    role_id: number | null
    role_name: string | null
    description: string | null
  }

  export type RoleMaxAggregateOutputType = {
    role_id: number | null
    role_name: string | null
    description: string | null
  }

  export type RoleCountAggregateOutputType = {
    role_id: number
    role_name: number
    description: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    role_id?: true
  }

  export type RoleSumAggregateInputType = {
    role_id?: true
  }

  export type RoleMinAggregateInputType = {
    role_id?: true
    role_name?: true
    description?: true
  }

  export type RoleMaxAggregateInputType = {
    role_id?: true
    role_name?: true
    description?: true
  }

  export type RoleCountAggregateInputType = {
    role_id?: true
    role_name?: true
    description?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
    orderBy?: roleOrderByWithAggregationInput | roleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    role_id: number
    role_name: string
    description: string | null
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
    description?: boolean
    rolepermission?: boolean | role$rolepermissionArgs<ExtArgs>
    userrole?: boolean | role$userroleArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type roleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
    description?: boolean
  }, ExtArgs["result"]["role"]>

  export type roleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    role_name?: boolean
    description?: boolean
  }, ExtArgs["result"]["role"]>

  export type roleSelectScalar = {
    role_id?: boolean
    role_name?: boolean
    description?: boolean
  }

  export type roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"role_id" | "role_name" | "description", ExtArgs["result"]["role"]>
  export type roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolepermission?: boolean | role$rolepermissionArgs<ExtArgs>
    userrole?: boolean | role$userroleArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type roleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type roleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role"
    objects: {
      rolepermission: Prisma.$rolepermissionPayload<ExtArgs>[]
      userrole: Prisma.$userrolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      role_name: string
      description: string | null
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type roleGetPayload<S extends boolean | null | undefined | roleDefaultArgs> = $Result.GetResult<Prisma.$rolePayload, S>

  type roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role'], meta: { name: 'role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roleFindUniqueArgs>(args: SelectSubset<T, roleFindUniqueArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs>(args: SelectSubset<T, roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roleFindFirstArgs>(args?: SelectSubset<T, roleFindFirstArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs>(args?: SelectSubset<T, roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const roleWithRole_idOnly = await prisma.role.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends roleFindManyArgs>(args?: SelectSubset<T, roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends roleCreateArgs>(args: SelectSubset<T, roleCreateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {roleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roleCreateManyArgs>(args?: SelectSubset<T, roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {roleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `role_id`
     * const roleWithRole_idOnly = await prisma.role.createManyAndReturn({
     *   select: { role_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends roleCreateManyAndReturnArgs>(args?: SelectSubset<T, roleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends roleDeleteArgs>(args: SelectSubset<T, roleDeleteArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roleUpdateArgs>(args: SelectSubset<T, roleUpdateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roleDeleteManyArgs>(args?: SelectSubset<T, roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roleUpdateManyArgs>(args: SelectSubset<T, roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {roleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `role_id`
     * const roleWithRole_idOnly = await prisma.role.updateManyAndReturn({
     *   select: { role_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends roleUpdateManyAndReturnArgs>(args: SelectSubset<T, roleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends roleUpsertArgs>(args: SelectSubset<T, roleUpsertArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleGroupByArgs['orderBy'] }
        : { orderBy?: roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role model
   */
  readonly fields: roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolepermission<T extends role$rolepermissionArgs<ExtArgs> = {}>(args?: Subset<T, role$rolepermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userrole<T extends role$userroleArgs<ExtArgs> = {}>(args?: Subset<T, role$userroleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role model
   */
  interface roleFieldRefs {
    readonly role_id: FieldRef<"role", 'Int'>
    readonly role_name: FieldRef<"role", 'String'>
    readonly description: FieldRef<"role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * role findUnique
   */
  export type roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findFirst
   */
  export type roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findMany
   */
  export type roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role create
   */
  export type roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to create a role.
     */
    data: XOR<roleCreateInput, roleUncheckedCreateInput>
  }

  /**
   * role createMany
   */
  export type roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role createManyAndReturn
   */
  export type roleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role update
   */
  export type roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role updateMany
   */
  export type roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * role updateManyAndReturn
   */
  export type roleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * role upsert
   */
  export type roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>
  }

  /**
   * role delete
   */
  export type roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * role.rolepermission
   */
  export type role$rolepermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    where?: rolepermissionWhereInput
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    cursor?: rolepermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolepermissionScalarFieldEnum | RolepermissionScalarFieldEnum[]
  }

  /**
   * role.userrole
   */
  export type role$userroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    cursor?: userroleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * role without action
   */
  export type roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
  }


  /**
   * Model rolepermission
   */

  export type AggregateRolepermission = {
    _count: RolepermissionCountAggregateOutputType | null
    _avg: RolepermissionAvgAggregateOutputType | null
    _sum: RolepermissionSumAggregateOutputType | null
    _min: RolepermissionMinAggregateOutputType | null
    _max: RolepermissionMaxAggregateOutputType | null
  }

  export type RolepermissionAvgAggregateOutputType = {
    role_id: number | null
    permission_id: number | null
  }

  export type RolepermissionSumAggregateOutputType = {
    role_id: number | null
    permission_id: number | null
  }

  export type RolepermissionMinAggregateOutputType = {
    role_id: number | null
    permission_id: number | null
    created_at: Date | null
  }

  export type RolepermissionMaxAggregateOutputType = {
    role_id: number | null
    permission_id: number | null
    created_at: Date | null
  }

  export type RolepermissionCountAggregateOutputType = {
    role_id: number
    permission_id: number
    created_at: number
    _all: number
  }


  export type RolepermissionAvgAggregateInputType = {
    role_id?: true
    permission_id?: true
  }

  export type RolepermissionSumAggregateInputType = {
    role_id?: true
    permission_id?: true
  }

  export type RolepermissionMinAggregateInputType = {
    role_id?: true
    permission_id?: true
    created_at?: true
  }

  export type RolepermissionMaxAggregateInputType = {
    role_id?: true
    permission_id?: true
    created_at?: true
  }

  export type RolepermissionCountAggregateInputType = {
    role_id?: true
    permission_id?: true
    created_at?: true
    _all?: true
  }

  export type RolepermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rolepermission to aggregate.
     */
    where?: rolepermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolepermissions to fetch.
     */
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolepermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolepermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolepermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rolepermissions
    **/
    _count?: true | RolepermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolepermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolepermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolepermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolepermissionMaxAggregateInputType
  }

  export type GetRolepermissionAggregateType<T extends RolepermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolepermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolepermission[P]>
      : GetScalarType<T[P], AggregateRolepermission[P]>
  }




  export type rolepermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolepermissionWhereInput
    orderBy?: rolepermissionOrderByWithAggregationInput | rolepermissionOrderByWithAggregationInput[]
    by: RolepermissionScalarFieldEnum[] | RolepermissionScalarFieldEnum
    having?: rolepermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolepermissionCountAggregateInputType | true
    _avg?: RolepermissionAvgAggregateInputType
    _sum?: RolepermissionSumAggregateInputType
    _min?: RolepermissionMinAggregateInputType
    _max?: RolepermissionMaxAggregateInputType
  }

  export type RolepermissionGroupByOutputType = {
    role_id: number
    permission_id: number
    created_at: Date | null
    _count: RolepermissionCountAggregateOutputType | null
    _avg: RolepermissionAvgAggregateOutputType | null
    _sum: RolepermissionSumAggregateOutputType | null
    _min: RolepermissionMinAggregateOutputType | null
    _max: RolepermissionMaxAggregateOutputType | null
  }

  type GetRolepermissionGroupByPayload<T extends rolepermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolepermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolepermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolepermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolepermissionGroupByOutputType[P]>
        }
      >
    >


  export type rolepermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    permission_id?: boolean
    created_at?: boolean
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolepermission"]>

  export type rolepermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    permission_id?: boolean
    created_at?: boolean
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolepermission"]>

  export type rolepermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    permission_id?: boolean
    created_at?: boolean
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolepermission"]>

  export type rolepermissionSelectScalar = {
    role_id?: boolean
    permission_id?: boolean
    created_at?: boolean
  }

  export type rolepermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"role_id" | "permission_id" | "created_at", ExtArgs["result"]["rolepermission"]>
  export type rolepermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
  }
  export type rolepermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
  }
  export type rolepermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permission?: boolean | permissionDefaultArgs<ExtArgs>
    role?: boolean | roleDefaultArgs<ExtArgs>
  }

  export type $rolepermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rolepermission"
    objects: {
      permission: Prisma.$permissionPayload<ExtArgs>
      role: Prisma.$rolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      permission_id: number
      created_at: Date | null
    }, ExtArgs["result"]["rolepermission"]>
    composites: {}
  }

  type rolepermissionGetPayload<S extends boolean | null | undefined | rolepermissionDefaultArgs> = $Result.GetResult<Prisma.$rolepermissionPayload, S>

  type rolepermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rolepermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolepermissionCountAggregateInputType | true
    }

  export interface rolepermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rolepermission'], meta: { name: 'rolepermission' } }
    /**
     * Find zero or one Rolepermission that matches the filter.
     * @param {rolepermissionFindUniqueArgs} args - Arguments to find a Rolepermission
     * @example
     * // Get one Rolepermission
     * const rolepermission = await prisma.rolepermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolepermissionFindUniqueArgs>(args: SelectSubset<T, rolepermissionFindUniqueArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rolepermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rolepermissionFindUniqueOrThrowArgs} args - Arguments to find a Rolepermission
     * @example
     * // Get one Rolepermission
     * const rolepermission = await prisma.rolepermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolepermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, rolepermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rolepermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolepermissionFindFirstArgs} args - Arguments to find a Rolepermission
     * @example
     * // Get one Rolepermission
     * const rolepermission = await prisma.rolepermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolepermissionFindFirstArgs>(args?: SelectSubset<T, rolepermissionFindFirstArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rolepermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolepermissionFindFirstOrThrowArgs} args - Arguments to find a Rolepermission
     * @example
     * // Get one Rolepermission
     * const rolepermission = await prisma.rolepermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolepermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, rolepermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rolepermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolepermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rolepermissions
     * const rolepermissions = await prisma.rolepermission.findMany()
     * 
     * // Get first 10 Rolepermissions
     * const rolepermissions = await prisma.rolepermission.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const rolepermissionWithRole_idOnly = await prisma.rolepermission.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends rolepermissionFindManyArgs>(args?: SelectSubset<T, rolepermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rolepermission.
     * @param {rolepermissionCreateArgs} args - Arguments to create a Rolepermission.
     * @example
     * // Create one Rolepermission
     * const Rolepermission = await prisma.rolepermission.create({
     *   data: {
     *     // ... data to create a Rolepermission
     *   }
     * })
     * 
     */
    create<T extends rolepermissionCreateArgs>(args: SelectSubset<T, rolepermissionCreateArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rolepermissions.
     * @param {rolepermissionCreateManyArgs} args - Arguments to create many Rolepermissions.
     * @example
     * // Create many Rolepermissions
     * const rolepermission = await prisma.rolepermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolepermissionCreateManyArgs>(args?: SelectSubset<T, rolepermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rolepermissions and returns the data saved in the database.
     * @param {rolepermissionCreateManyAndReturnArgs} args - Arguments to create many Rolepermissions.
     * @example
     * // Create many Rolepermissions
     * const rolepermission = await prisma.rolepermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rolepermissions and only return the `role_id`
     * const rolepermissionWithRole_idOnly = await prisma.rolepermission.createManyAndReturn({
     *   select: { role_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rolepermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, rolepermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rolepermission.
     * @param {rolepermissionDeleteArgs} args - Arguments to delete one Rolepermission.
     * @example
     * // Delete one Rolepermission
     * const Rolepermission = await prisma.rolepermission.delete({
     *   where: {
     *     // ... filter to delete one Rolepermission
     *   }
     * })
     * 
     */
    delete<T extends rolepermissionDeleteArgs>(args: SelectSubset<T, rolepermissionDeleteArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rolepermission.
     * @param {rolepermissionUpdateArgs} args - Arguments to update one Rolepermission.
     * @example
     * // Update one Rolepermission
     * const rolepermission = await prisma.rolepermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolepermissionUpdateArgs>(args: SelectSubset<T, rolepermissionUpdateArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rolepermissions.
     * @param {rolepermissionDeleteManyArgs} args - Arguments to filter Rolepermissions to delete.
     * @example
     * // Delete a few Rolepermissions
     * const { count } = await prisma.rolepermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolepermissionDeleteManyArgs>(args?: SelectSubset<T, rolepermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rolepermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolepermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rolepermissions
     * const rolepermission = await prisma.rolepermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolepermissionUpdateManyArgs>(args: SelectSubset<T, rolepermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rolepermissions and returns the data updated in the database.
     * @param {rolepermissionUpdateManyAndReturnArgs} args - Arguments to update many Rolepermissions.
     * @example
     * // Update many Rolepermissions
     * const rolepermission = await prisma.rolepermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rolepermissions and only return the `role_id`
     * const rolepermissionWithRole_idOnly = await prisma.rolepermission.updateManyAndReturn({
     *   select: { role_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rolepermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, rolepermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rolepermission.
     * @param {rolepermissionUpsertArgs} args - Arguments to update or create a Rolepermission.
     * @example
     * // Update or create a Rolepermission
     * const rolepermission = await prisma.rolepermission.upsert({
     *   create: {
     *     // ... data to create a Rolepermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rolepermission we want to update
     *   }
     * })
     */
    upsert<T extends rolepermissionUpsertArgs>(args: SelectSubset<T, rolepermissionUpsertArgs<ExtArgs>>): Prisma__rolepermissionClient<$Result.GetResult<Prisma.$rolepermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rolepermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolepermissionCountArgs} args - Arguments to filter Rolepermissions to count.
     * @example
     * // Count the number of Rolepermissions
     * const count = await prisma.rolepermission.count({
     *   where: {
     *     // ... the filter for the Rolepermissions we want to count
     *   }
     * })
    **/
    count<T extends rolepermissionCountArgs>(
      args?: Subset<T, rolepermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolepermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rolepermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolepermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolepermissionAggregateArgs>(args: Subset<T, RolepermissionAggregateArgs>): Prisma.PrismaPromise<GetRolepermissionAggregateType<T>>

    /**
     * Group by Rolepermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolepermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolepermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolepermissionGroupByArgs['orderBy'] }
        : { orderBy?: rolepermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolepermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolepermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rolepermission model
   */
  readonly fields: rolepermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rolepermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolepermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permission<T extends permissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, permissionDefaultArgs<ExtArgs>>): Prisma__permissionClient<$Result.GetResult<Prisma.$permissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roleDefaultArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rolepermission model
   */
  interface rolepermissionFieldRefs {
    readonly role_id: FieldRef<"rolepermission", 'Int'>
    readonly permission_id: FieldRef<"rolepermission", 'Int'>
    readonly created_at: FieldRef<"rolepermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * rolepermission findUnique
   */
  export type rolepermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolepermission to fetch.
     */
    where: rolepermissionWhereUniqueInput
  }

  /**
   * rolepermission findUniqueOrThrow
   */
  export type rolepermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolepermission to fetch.
     */
    where: rolepermissionWhereUniqueInput
  }

  /**
   * rolepermission findFirst
   */
  export type rolepermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolepermission to fetch.
     */
    where?: rolepermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolepermissions to fetch.
     */
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rolepermissions.
     */
    cursor?: rolepermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolepermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolepermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rolepermissions.
     */
    distinct?: RolepermissionScalarFieldEnum | RolepermissionScalarFieldEnum[]
  }

  /**
   * rolepermission findFirstOrThrow
   */
  export type rolepermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolepermission to fetch.
     */
    where?: rolepermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolepermissions to fetch.
     */
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rolepermissions.
     */
    cursor?: rolepermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolepermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolepermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rolepermissions.
     */
    distinct?: RolepermissionScalarFieldEnum | RolepermissionScalarFieldEnum[]
  }

  /**
   * rolepermission findMany
   */
  export type rolepermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * Filter, which rolepermissions to fetch.
     */
    where?: rolepermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolepermissions to fetch.
     */
    orderBy?: rolepermissionOrderByWithRelationInput | rolepermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rolepermissions.
     */
    cursor?: rolepermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolepermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolepermissions.
     */
    skip?: number
    distinct?: RolepermissionScalarFieldEnum | RolepermissionScalarFieldEnum[]
  }

  /**
   * rolepermission create
   */
  export type rolepermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a rolepermission.
     */
    data: XOR<rolepermissionCreateInput, rolepermissionUncheckedCreateInput>
  }

  /**
   * rolepermission createMany
   */
  export type rolepermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rolepermissions.
     */
    data: rolepermissionCreateManyInput | rolepermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rolepermission createManyAndReturn
   */
  export type rolepermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * The data used to create many rolepermissions.
     */
    data: rolepermissionCreateManyInput | rolepermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * rolepermission update
   */
  export type rolepermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a rolepermission.
     */
    data: XOR<rolepermissionUpdateInput, rolepermissionUncheckedUpdateInput>
    /**
     * Choose, which rolepermission to update.
     */
    where: rolepermissionWhereUniqueInput
  }

  /**
   * rolepermission updateMany
   */
  export type rolepermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rolepermissions.
     */
    data: XOR<rolepermissionUpdateManyMutationInput, rolepermissionUncheckedUpdateManyInput>
    /**
     * Filter which rolepermissions to update
     */
    where?: rolepermissionWhereInput
    /**
     * Limit how many rolepermissions to update.
     */
    limit?: number
  }

  /**
   * rolepermission updateManyAndReturn
   */
  export type rolepermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * The data used to update rolepermissions.
     */
    data: XOR<rolepermissionUpdateManyMutationInput, rolepermissionUncheckedUpdateManyInput>
    /**
     * Filter which rolepermissions to update
     */
    where?: rolepermissionWhereInput
    /**
     * Limit how many rolepermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * rolepermission upsert
   */
  export type rolepermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the rolepermission to update in case it exists.
     */
    where: rolepermissionWhereUniqueInput
    /**
     * In case the rolepermission found by the `where` argument doesn't exist, create a new rolepermission with this data.
     */
    create: XOR<rolepermissionCreateInput, rolepermissionUncheckedCreateInput>
    /**
     * In case the rolepermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolepermissionUpdateInput, rolepermissionUncheckedUpdateInput>
  }

  /**
   * rolepermission delete
   */
  export type rolepermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
    /**
     * Filter which rolepermission to delete.
     */
    where: rolepermissionWhereUniqueInput
  }

  /**
   * rolepermission deleteMany
   */
  export type rolepermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rolepermissions to delete
     */
    where?: rolepermissionWhereInput
    /**
     * Limit how many rolepermissions to delete.
     */
    limit?: number
  }

  /**
   * rolepermission without action
   */
  export type rolepermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolepermission
     */
    select?: rolepermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rolepermission
     */
    omit?: rolepermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolepermissionInclude<ExtArgs> | null
  }


  /**
   * Model sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsAvgAggregateOutputType = {
    session_id: number | null
    user_id: number | null
  }

  export type SessionsSumAggregateOutputType = {
    session_id: number | null
    user_id: number | null
  }

  export type SessionsMinAggregateOutputType = {
    session_id: number | null
    user_id: number | null
    access_token: string | null
    is_active: boolean | null
    login_at: Date | null
    logout_at: Date | null
  }

  export type SessionsMaxAggregateOutputType = {
    session_id: number | null
    user_id: number | null
    access_token: string | null
    is_active: boolean | null
    login_at: Date | null
    logout_at: Date | null
  }

  export type SessionsCountAggregateOutputType = {
    session_id: number
    user_id: number
    access_token: number
    is_active: number
    login_at: number
    logout_at: number
    _all: number
  }


  export type SessionsAvgAggregateInputType = {
    session_id?: true
    user_id?: true
  }

  export type SessionsSumAggregateInputType = {
    session_id?: true
    user_id?: true
  }

  export type SessionsMinAggregateInputType = {
    session_id?: true
    user_id?: true
    access_token?: true
    is_active?: true
    login_at?: true
    logout_at?: true
  }

  export type SessionsMaxAggregateInputType = {
    session_id?: true
    user_id?: true
    access_token?: true
    is_active?: true
    login_at?: true
    logout_at?: true
  }

  export type SessionsCountAggregateInputType = {
    session_id?: true
    user_id?: true
    access_token?: true
    is_active?: true
    login_at?: true
    logout_at?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _avg?: SessionsAvgAggregateInputType
    _sum?: SessionsSumAggregateInputType
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    session_id: number
    user_id: number | null
    access_token: string | null
    is_active: boolean | null
    login_at: Date | null
    logout_at: Date | null
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_id?: boolean
    user_id?: boolean
    access_token?: boolean
    is_active?: boolean
    login_at?: boolean
    logout_at?: boolean
    auditlog?: boolean | sessions$auditlogArgs<ExtArgs>
    users?: boolean | sessions$usersArgs<ExtArgs>
    _count?: boolean | SessionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_id?: boolean
    user_id?: boolean
    access_token?: boolean
    is_active?: boolean
    login_at?: boolean
    logout_at?: boolean
    users?: boolean | sessions$usersArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    session_id?: boolean
    user_id?: boolean
    access_token?: boolean
    is_active?: boolean
    login_at?: boolean
    logout_at?: boolean
    users?: boolean | sessions$usersArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectScalar = {
    session_id?: boolean
    user_id?: boolean
    access_token?: boolean
    is_active?: boolean
    login_at?: boolean
    logout_at?: boolean
  }

  export type sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"session_id" | "user_id" | "access_token" | "is_active" | "login_at" | "logout_at", ExtArgs["result"]["sessions"]>
  export type sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditlog?: boolean | sessions$auditlogArgs<ExtArgs>
    users?: boolean | sessions$usersArgs<ExtArgs>
    _count?: boolean | SessionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type sessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | sessions$usersArgs<ExtArgs>
  }
  export type sessionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | sessions$usersArgs<ExtArgs>
  }

  export type $sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions"
    objects: {
      auditlog: Prisma.$auditlogPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      session_id: number
      user_id: number | null
      access_token: string | null
      is_active: boolean | null
      login_at: Date | null
      logout_at: Date | null
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }

  type sessionsGetPayload<S extends boolean | null | undefined | sessionsDefaultArgs> = $Result.GetResult<Prisma.$sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionsFindUniqueArgs>(args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionsFindFirstArgs>(args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `session_id`
     * const sessionsWithSession_idOnly = await prisma.sessions.findMany({ select: { session_id: true } })
     * 
     */
    findMany<T extends sessionsFindManyArgs>(args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
     */
    create<T extends sessionsCreateArgs>(args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionsCreateManyArgs>(args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {sessionsCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `session_id`
     * const sessionsWithSession_idOnly = await prisma.sessions.createManyAndReturn({
     *   select: { session_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
     */
    delete<T extends sessionsDeleteArgs>(args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionsUpdateArgs>(args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionsDeleteManyArgs>(args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionsUpdateManyArgs>(args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {sessionsUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `session_id`
     * const sessionsWithSession_idOnly = await prisma.sessions.updateManyAndReturn({
     *   select: { session_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sessionsUpdateManyAndReturnArgs>(args: SelectSubset<T, sessionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
     */
    upsert<T extends sessionsUpsertArgs>(args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditlog<T extends sessions$auditlogArgs<ExtArgs> = {}>(args?: Subset<T, sessions$auditlogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends sessions$usersArgs<ExtArgs> = {}>(args?: Subset<T, sessions$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions model
   */
  interface sessionsFieldRefs {
    readonly session_id: FieldRef<"sessions", 'Int'>
    readonly user_id: FieldRef<"sessions", 'Int'>
    readonly access_token: FieldRef<"sessions", 'String'>
    readonly is_active: FieldRef<"sessions", 'Boolean'>
    readonly login_at: FieldRef<"sessions", 'DateTime'>
    readonly logout_at: FieldRef<"sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data?: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }

  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions createManyAndReturn
   */
  export type sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * sessions updateManyAndReturn
   */
  export type sessionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }

  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * sessions.auditlog
   */
  export type sessions$auditlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    where?: auditlogWhereInput
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    cursor?: auditlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * sessions.users
   */
  export type sessions$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * sessions without action
   */
  export type sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
  }


  /**
   * Model tour
   */

  export type AggregateTour = {
    _count: TourCountAggregateOutputType | null
    _avg: TourAvgAggregateOutputType | null
    _sum: TourSumAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  export type TourAvgAggregateOutputType = {
    tour_id: number | null
  }

  export type TourSumAggregateOutputType = {
    tour_id: number | null
  }

  export type TourMinAggregateOutputType = {
    tour_id: number | null
    tour_name: string | null
    description: string | null
    created_at: Date | null
  }

  export type TourMaxAggregateOutputType = {
    tour_id: number | null
    tour_name: string | null
    description: string | null
    created_at: Date | null
  }

  export type TourCountAggregateOutputType = {
    tour_id: number
    tour_name: number
    description: number
    created_at: number
    _all: number
  }


  export type TourAvgAggregateInputType = {
    tour_id?: true
  }

  export type TourSumAggregateInputType = {
    tour_id?: true
  }

  export type TourMinAggregateInputType = {
    tour_id?: true
    tour_name?: true
    description?: true
    created_at?: true
  }

  export type TourMaxAggregateInputType = {
    tour_id?: true
    tour_name?: true
    description?: true
    created_at?: true
  }

  export type TourCountAggregateInputType = {
    tour_id?: true
    tour_name?: true
    description?: true
    created_at?: true
    _all?: true
  }

  export type TourAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tour to aggregate.
     */
    where?: tourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tours to fetch.
     */
    orderBy?: tourOrderByWithRelationInput | tourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tours
    **/
    _count?: true | TourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourMaxAggregateInputType
  }

  export type GetTourAggregateType<T extends TourAggregateArgs> = {
        [P in keyof T & keyof AggregateTour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTour[P]>
      : GetScalarType<T[P], AggregateTour[P]>
  }




  export type tourGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tourWhereInput
    orderBy?: tourOrderByWithAggregationInput | tourOrderByWithAggregationInput[]
    by: TourScalarFieldEnum[] | TourScalarFieldEnum
    having?: tourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourCountAggregateInputType | true
    _avg?: TourAvgAggregateInputType
    _sum?: TourSumAggregateInputType
    _min?: TourMinAggregateInputType
    _max?: TourMaxAggregateInputType
  }

  export type TourGroupByOutputType = {
    tour_id: number
    tour_name: string
    description: string | null
    created_at: Date | null
    _count: TourCountAggregateOutputType | null
    _avg: TourAvgAggregateOutputType | null
    _sum: TourSumAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  type GetTourGroupByPayload<T extends tourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourGroupByOutputType[P]>
            : GetScalarType<T[P], TourGroupByOutputType[P]>
        }
      >
    >


  export type tourSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tour_id?: boolean
    tour_name?: boolean
    description?: boolean
    created_at?: boolean
    badge?: boolean | tour$badgeArgs<ExtArgs>
    review?: boolean | tour$reviewArgs<ExtArgs>
    tourcheckpoint?: boolean | tour$tourcheckpointArgs<ExtArgs>
    usertourcompletion?: boolean | tour$usertourcompletionArgs<ExtArgs>
    _count?: boolean | TourCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tour"]>

  export type tourSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tour_id?: boolean
    tour_name?: boolean
    description?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["tour"]>

  export type tourSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tour_id?: boolean
    tour_name?: boolean
    description?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["tour"]>

  export type tourSelectScalar = {
    tour_id?: boolean
    tour_name?: boolean
    description?: boolean
    created_at?: boolean
  }

  export type tourOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tour_id" | "tour_name" | "description" | "created_at", ExtArgs["result"]["tour"]>
  export type tourInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | tour$badgeArgs<ExtArgs>
    review?: boolean | tour$reviewArgs<ExtArgs>
    tourcheckpoint?: boolean | tour$tourcheckpointArgs<ExtArgs>
    usertourcompletion?: boolean | tour$usertourcompletionArgs<ExtArgs>
    _count?: boolean | TourCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tourIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tourIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tourPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tour"
    objects: {
      badge: Prisma.$badgePayload<ExtArgs>[]
      review: Prisma.$reviewPayload<ExtArgs>[]
      tourcheckpoint: Prisma.$tourcheckpointPayload<ExtArgs>[]
      usertourcompletion: Prisma.$usertourcompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      tour_id: number
      tour_name: string
      description: string | null
      created_at: Date | null
    }, ExtArgs["result"]["tour"]>
    composites: {}
  }

  type tourGetPayload<S extends boolean | null | undefined | tourDefaultArgs> = $Result.GetResult<Prisma.$tourPayload, S>

  type tourCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tourFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TourCountAggregateInputType | true
    }

  export interface tourDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tour'], meta: { name: 'tour' } }
    /**
     * Find zero or one Tour that matches the filter.
     * @param {tourFindUniqueArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tourFindUniqueArgs>(args: SelectSubset<T, tourFindUniqueArgs<ExtArgs>>): Prisma__tourClient<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tour that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tourFindUniqueOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tourFindUniqueOrThrowArgs>(args: SelectSubset<T, tourFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tourClient<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourFindFirstArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tourFindFirstArgs>(args?: SelectSubset<T, tourFindFirstArgs<ExtArgs>>): Prisma__tourClient<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tour that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourFindFirstOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tourFindFirstOrThrowArgs>(args?: SelectSubset<T, tourFindFirstOrThrowArgs<ExtArgs>>): Prisma__tourClient<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tours
     * const tours = await prisma.tour.findMany()
     * 
     * // Get first 10 Tours
     * const tours = await prisma.tour.findMany({ take: 10 })
     * 
     * // Only select the `tour_id`
     * const tourWithTour_idOnly = await prisma.tour.findMany({ select: { tour_id: true } })
     * 
     */
    findMany<T extends tourFindManyArgs>(args?: SelectSubset<T, tourFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tour.
     * @param {tourCreateArgs} args - Arguments to create a Tour.
     * @example
     * // Create one Tour
     * const Tour = await prisma.tour.create({
     *   data: {
     *     // ... data to create a Tour
     *   }
     * })
     * 
     */
    create<T extends tourCreateArgs>(args: SelectSubset<T, tourCreateArgs<ExtArgs>>): Prisma__tourClient<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tours.
     * @param {tourCreateManyArgs} args - Arguments to create many Tours.
     * @example
     * // Create many Tours
     * const tour = await prisma.tour.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tourCreateManyArgs>(args?: SelectSubset<T, tourCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tours and returns the data saved in the database.
     * @param {tourCreateManyAndReturnArgs} args - Arguments to create many Tours.
     * @example
     * // Create many Tours
     * const tour = await prisma.tour.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tours and only return the `tour_id`
     * const tourWithTour_idOnly = await prisma.tour.createManyAndReturn({
     *   select: { tour_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tourCreateManyAndReturnArgs>(args?: SelectSubset<T, tourCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tour.
     * @param {tourDeleteArgs} args - Arguments to delete one Tour.
     * @example
     * // Delete one Tour
     * const Tour = await prisma.tour.delete({
     *   where: {
     *     // ... filter to delete one Tour
     *   }
     * })
     * 
     */
    delete<T extends tourDeleteArgs>(args: SelectSubset<T, tourDeleteArgs<ExtArgs>>): Prisma__tourClient<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tour.
     * @param {tourUpdateArgs} args - Arguments to update one Tour.
     * @example
     * // Update one Tour
     * const tour = await prisma.tour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tourUpdateArgs>(args: SelectSubset<T, tourUpdateArgs<ExtArgs>>): Prisma__tourClient<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tours.
     * @param {tourDeleteManyArgs} args - Arguments to filter Tours to delete.
     * @example
     * // Delete a few Tours
     * const { count } = await prisma.tour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tourDeleteManyArgs>(args?: SelectSubset<T, tourDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tours
     * const tour = await prisma.tour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tourUpdateManyArgs>(args: SelectSubset<T, tourUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tours and returns the data updated in the database.
     * @param {tourUpdateManyAndReturnArgs} args - Arguments to update many Tours.
     * @example
     * // Update many Tours
     * const tour = await prisma.tour.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tours and only return the `tour_id`
     * const tourWithTour_idOnly = await prisma.tour.updateManyAndReturn({
     *   select: { tour_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tourUpdateManyAndReturnArgs>(args: SelectSubset<T, tourUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tour.
     * @param {tourUpsertArgs} args - Arguments to update or create a Tour.
     * @example
     * // Update or create a Tour
     * const tour = await prisma.tour.upsert({
     *   create: {
     *     // ... data to create a Tour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tour we want to update
     *   }
     * })
     */
    upsert<T extends tourUpsertArgs>(args: SelectSubset<T, tourUpsertArgs<ExtArgs>>): Prisma__tourClient<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourCountArgs} args - Arguments to filter Tours to count.
     * @example
     * // Count the number of Tours
     * const count = await prisma.tour.count({
     *   where: {
     *     // ... the filter for the Tours we want to count
     *   }
     * })
    **/
    count<T extends tourCountArgs>(
      args?: Subset<T, tourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourAggregateArgs>(args: Subset<T, TourAggregateArgs>): Prisma.PrismaPromise<GetTourAggregateType<T>>

    /**
     * Group by Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tourGroupByArgs['orderBy'] }
        : { orderBy?: tourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tour model
   */
  readonly fields: tourFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tourClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badge<T extends tour$badgeArgs<ExtArgs> = {}>(args?: Subset<T, tour$badgeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    review<T extends tour$reviewArgs<ExtArgs> = {}>(args?: Subset<T, tour$reviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tourcheckpoint<T extends tour$tourcheckpointArgs<ExtArgs> = {}>(args?: Subset<T, tour$tourcheckpointArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tourcheckpointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usertourcompletion<T extends tour$usertourcompletionArgs<ExtArgs> = {}>(args?: Subset<T, tour$usertourcompletionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tour model
   */
  interface tourFieldRefs {
    readonly tour_id: FieldRef<"tour", 'Int'>
    readonly tour_name: FieldRef<"tour", 'String'>
    readonly description: FieldRef<"tour", 'String'>
    readonly created_at: FieldRef<"tour", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tour findUnique
   */
  export type tourFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourInclude<ExtArgs> | null
    /**
     * Filter, which tour to fetch.
     */
    where: tourWhereUniqueInput
  }

  /**
   * tour findUniqueOrThrow
   */
  export type tourFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourInclude<ExtArgs> | null
    /**
     * Filter, which tour to fetch.
     */
    where: tourWhereUniqueInput
  }

  /**
   * tour findFirst
   */
  export type tourFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourInclude<ExtArgs> | null
    /**
     * Filter, which tour to fetch.
     */
    where?: tourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tours to fetch.
     */
    orderBy?: tourOrderByWithRelationInput | tourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tours.
     */
    cursor?: tourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tours.
     */
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * tour findFirstOrThrow
   */
  export type tourFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourInclude<ExtArgs> | null
    /**
     * Filter, which tour to fetch.
     */
    where?: tourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tours to fetch.
     */
    orderBy?: tourOrderByWithRelationInput | tourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tours.
     */
    cursor?: tourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tours.
     */
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * tour findMany
   */
  export type tourFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourInclude<ExtArgs> | null
    /**
     * Filter, which tours to fetch.
     */
    where?: tourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tours to fetch.
     */
    orderBy?: tourOrderByWithRelationInput | tourOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tours.
     */
    cursor?: tourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tours.
     */
    skip?: number
    distinct?: TourScalarFieldEnum | TourScalarFieldEnum[]
  }

  /**
   * tour create
   */
  export type tourCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourInclude<ExtArgs> | null
    /**
     * The data needed to create a tour.
     */
    data: XOR<tourCreateInput, tourUncheckedCreateInput>
  }

  /**
   * tour createMany
   */
  export type tourCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tours.
     */
    data: tourCreateManyInput | tourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tour createManyAndReturn
   */
  export type tourCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * The data used to create many tours.
     */
    data: tourCreateManyInput | tourCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tour update
   */
  export type tourUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourInclude<ExtArgs> | null
    /**
     * The data needed to update a tour.
     */
    data: XOR<tourUpdateInput, tourUncheckedUpdateInput>
    /**
     * Choose, which tour to update.
     */
    where: tourWhereUniqueInput
  }

  /**
   * tour updateMany
   */
  export type tourUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tours.
     */
    data: XOR<tourUpdateManyMutationInput, tourUncheckedUpdateManyInput>
    /**
     * Filter which tours to update
     */
    where?: tourWhereInput
    /**
     * Limit how many tours to update.
     */
    limit?: number
  }

  /**
   * tour updateManyAndReturn
   */
  export type tourUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * The data used to update tours.
     */
    data: XOR<tourUpdateManyMutationInput, tourUncheckedUpdateManyInput>
    /**
     * Filter which tours to update
     */
    where?: tourWhereInput
    /**
     * Limit how many tours to update.
     */
    limit?: number
  }

  /**
   * tour upsert
   */
  export type tourUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourInclude<ExtArgs> | null
    /**
     * The filter to search for the tour to update in case it exists.
     */
    where: tourWhereUniqueInput
    /**
     * In case the tour found by the `where` argument doesn't exist, create a new tour with this data.
     */
    create: XOR<tourCreateInput, tourUncheckedCreateInput>
    /**
     * In case the tour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tourUpdateInput, tourUncheckedUpdateInput>
  }

  /**
   * tour delete
   */
  export type tourDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourInclude<ExtArgs> | null
    /**
     * Filter which tour to delete.
     */
    where: tourWhereUniqueInput
  }

  /**
   * tour deleteMany
   */
  export type tourDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tours to delete
     */
    where?: tourWhereInput
    /**
     * Limit how many tours to delete.
     */
    limit?: number
  }

  /**
   * tour.badge
   */
  export type tour$badgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the badge
     */
    select?: badgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the badge
     */
    omit?: badgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: badgeInclude<ExtArgs> | null
    where?: badgeWhereInput
    orderBy?: badgeOrderByWithRelationInput | badgeOrderByWithRelationInput[]
    cursor?: badgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * tour.review
   */
  export type tour$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    where?: reviewWhereInput
    orderBy?: reviewOrderByWithRelationInput | reviewOrderByWithRelationInput[]
    cursor?: reviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * tour.tourcheckpoint
   */
  export type tour$tourcheckpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointInclude<ExtArgs> | null
    where?: tourcheckpointWhereInput
    orderBy?: tourcheckpointOrderByWithRelationInput | tourcheckpointOrderByWithRelationInput[]
    cursor?: tourcheckpointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TourcheckpointScalarFieldEnum | TourcheckpointScalarFieldEnum[]
  }

  /**
   * tour.usertourcompletion
   */
  export type tour$usertourcompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionInclude<ExtArgs> | null
    where?: usertourcompletionWhereInput
    orderBy?: usertourcompletionOrderByWithRelationInput | usertourcompletionOrderByWithRelationInput[]
    cursor?: usertourcompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsertourcompletionScalarFieldEnum | UsertourcompletionScalarFieldEnum[]
  }

  /**
   * tour without action
   */
  export type tourDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourInclude<ExtArgs> | null
  }


  /**
   * Model tourcheckpoint
   */

  export type AggregateTourcheckpoint = {
    _count: TourcheckpointCountAggregateOutputType | null
    _avg: TourcheckpointAvgAggregateOutputType | null
    _sum: TourcheckpointSumAggregateOutputType | null
    _min: TourcheckpointMinAggregateOutputType | null
    _max: TourcheckpointMaxAggregateOutputType | null
  }

  export type TourcheckpointAvgAggregateOutputType = {
    tour_id: number | null
    checkpoint_id: number | null
    checkpoint_order: number | null
  }

  export type TourcheckpointSumAggregateOutputType = {
    tour_id: number | null
    checkpoint_id: number | null
    checkpoint_order: number | null
  }

  export type TourcheckpointMinAggregateOutputType = {
    tour_id: number | null
    checkpoint_id: number | null
    checkpoint_order: number | null
  }

  export type TourcheckpointMaxAggregateOutputType = {
    tour_id: number | null
    checkpoint_id: number | null
    checkpoint_order: number | null
  }

  export type TourcheckpointCountAggregateOutputType = {
    tour_id: number
    checkpoint_id: number
    checkpoint_order: number
    _all: number
  }


  export type TourcheckpointAvgAggregateInputType = {
    tour_id?: true
    checkpoint_id?: true
    checkpoint_order?: true
  }

  export type TourcheckpointSumAggregateInputType = {
    tour_id?: true
    checkpoint_id?: true
    checkpoint_order?: true
  }

  export type TourcheckpointMinAggregateInputType = {
    tour_id?: true
    checkpoint_id?: true
    checkpoint_order?: true
  }

  export type TourcheckpointMaxAggregateInputType = {
    tour_id?: true
    checkpoint_id?: true
    checkpoint_order?: true
  }

  export type TourcheckpointCountAggregateInputType = {
    tour_id?: true
    checkpoint_id?: true
    checkpoint_order?: true
    _all?: true
  }

  export type TourcheckpointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tourcheckpoint to aggregate.
     */
    where?: tourcheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tourcheckpoints to fetch.
     */
    orderBy?: tourcheckpointOrderByWithRelationInput | tourcheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tourcheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tourcheckpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tourcheckpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tourcheckpoints
    **/
    _count?: true | TourcheckpointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourcheckpointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourcheckpointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourcheckpointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourcheckpointMaxAggregateInputType
  }

  export type GetTourcheckpointAggregateType<T extends TourcheckpointAggregateArgs> = {
        [P in keyof T & keyof AggregateTourcheckpoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTourcheckpoint[P]>
      : GetScalarType<T[P], AggregateTourcheckpoint[P]>
  }




  export type tourcheckpointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tourcheckpointWhereInput
    orderBy?: tourcheckpointOrderByWithAggregationInput | tourcheckpointOrderByWithAggregationInput[]
    by: TourcheckpointScalarFieldEnum[] | TourcheckpointScalarFieldEnum
    having?: tourcheckpointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourcheckpointCountAggregateInputType | true
    _avg?: TourcheckpointAvgAggregateInputType
    _sum?: TourcheckpointSumAggregateInputType
    _min?: TourcheckpointMinAggregateInputType
    _max?: TourcheckpointMaxAggregateInputType
  }

  export type TourcheckpointGroupByOutputType = {
    tour_id: number
    checkpoint_id: number
    checkpoint_order: number
    _count: TourcheckpointCountAggregateOutputType | null
    _avg: TourcheckpointAvgAggregateOutputType | null
    _sum: TourcheckpointSumAggregateOutputType | null
    _min: TourcheckpointMinAggregateOutputType | null
    _max: TourcheckpointMaxAggregateOutputType | null
  }

  type GetTourcheckpointGroupByPayload<T extends tourcheckpointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TourcheckpointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourcheckpointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourcheckpointGroupByOutputType[P]>
            : GetScalarType<T[P], TourcheckpointGroupByOutputType[P]>
        }
      >
    >


  export type tourcheckpointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tour_id?: boolean
    checkpoint_id?: boolean
    checkpoint_order?: boolean
    checkpoint?: boolean | checkpointDefaultArgs<ExtArgs>
    tour?: boolean | tourDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tourcheckpoint"]>

  export type tourcheckpointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tour_id?: boolean
    checkpoint_id?: boolean
    checkpoint_order?: boolean
    checkpoint?: boolean | checkpointDefaultArgs<ExtArgs>
    tour?: boolean | tourDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tourcheckpoint"]>

  export type tourcheckpointSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tour_id?: boolean
    checkpoint_id?: boolean
    checkpoint_order?: boolean
    checkpoint?: boolean | checkpointDefaultArgs<ExtArgs>
    tour?: boolean | tourDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tourcheckpoint"]>

  export type tourcheckpointSelectScalar = {
    tour_id?: boolean
    checkpoint_id?: boolean
    checkpoint_order?: boolean
  }

  export type tourcheckpointOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tour_id" | "checkpoint_id" | "checkpoint_order", ExtArgs["result"]["tourcheckpoint"]>
  export type tourcheckpointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoint?: boolean | checkpointDefaultArgs<ExtArgs>
    tour?: boolean | tourDefaultArgs<ExtArgs>
  }
  export type tourcheckpointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoint?: boolean | checkpointDefaultArgs<ExtArgs>
    tour?: boolean | tourDefaultArgs<ExtArgs>
  }
  export type tourcheckpointIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoint?: boolean | checkpointDefaultArgs<ExtArgs>
    tour?: boolean | tourDefaultArgs<ExtArgs>
  }

  export type $tourcheckpointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tourcheckpoint"
    objects: {
      checkpoint: Prisma.$checkpointPayload<ExtArgs>
      tour: Prisma.$tourPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tour_id: number
      checkpoint_id: number
      checkpoint_order: number
    }, ExtArgs["result"]["tourcheckpoint"]>
    composites: {}
  }

  type tourcheckpointGetPayload<S extends boolean | null | undefined | tourcheckpointDefaultArgs> = $Result.GetResult<Prisma.$tourcheckpointPayload, S>

  type tourcheckpointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tourcheckpointFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TourcheckpointCountAggregateInputType | true
    }

  export interface tourcheckpointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tourcheckpoint'], meta: { name: 'tourcheckpoint' } }
    /**
     * Find zero or one Tourcheckpoint that matches the filter.
     * @param {tourcheckpointFindUniqueArgs} args - Arguments to find a Tourcheckpoint
     * @example
     * // Get one Tourcheckpoint
     * const tourcheckpoint = await prisma.tourcheckpoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tourcheckpointFindUniqueArgs>(args: SelectSubset<T, tourcheckpointFindUniqueArgs<ExtArgs>>): Prisma__tourcheckpointClient<$Result.GetResult<Prisma.$tourcheckpointPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tourcheckpoint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tourcheckpointFindUniqueOrThrowArgs} args - Arguments to find a Tourcheckpoint
     * @example
     * // Get one Tourcheckpoint
     * const tourcheckpoint = await prisma.tourcheckpoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tourcheckpointFindUniqueOrThrowArgs>(args: SelectSubset<T, tourcheckpointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tourcheckpointClient<$Result.GetResult<Prisma.$tourcheckpointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tourcheckpoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourcheckpointFindFirstArgs} args - Arguments to find a Tourcheckpoint
     * @example
     * // Get one Tourcheckpoint
     * const tourcheckpoint = await prisma.tourcheckpoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tourcheckpointFindFirstArgs>(args?: SelectSubset<T, tourcheckpointFindFirstArgs<ExtArgs>>): Prisma__tourcheckpointClient<$Result.GetResult<Prisma.$tourcheckpointPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tourcheckpoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourcheckpointFindFirstOrThrowArgs} args - Arguments to find a Tourcheckpoint
     * @example
     * // Get one Tourcheckpoint
     * const tourcheckpoint = await prisma.tourcheckpoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tourcheckpointFindFirstOrThrowArgs>(args?: SelectSubset<T, tourcheckpointFindFirstOrThrowArgs<ExtArgs>>): Prisma__tourcheckpointClient<$Result.GetResult<Prisma.$tourcheckpointPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tourcheckpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourcheckpointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tourcheckpoints
     * const tourcheckpoints = await prisma.tourcheckpoint.findMany()
     * 
     * // Get first 10 Tourcheckpoints
     * const tourcheckpoints = await prisma.tourcheckpoint.findMany({ take: 10 })
     * 
     * // Only select the `tour_id`
     * const tourcheckpointWithTour_idOnly = await prisma.tourcheckpoint.findMany({ select: { tour_id: true } })
     * 
     */
    findMany<T extends tourcheckpointFindManyArgs>(args?: SelectSubset<T, tourcheckpointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tourcheckpointPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tourcheckpoint.
     * @param {tourcheckpointCreateArgs} args - Arguments to create a Tourcheckpoint.
     * @example
     * // Create one Tourcheckpoint
     * const Tourcheckpoint = await prisma.tourcheckpoint.create({
     *   data: {
     *     // ... data to create a Tourcheckpoint
     *   }
     * })
     * 
     */
    create<T extends tourcheckpointCreateArgs>(args: SelectSubset<T, tourcheckpointCreateArgs<ExtArgs>>): Prisma__tourcheckpointClient<$Result.GetResult<Prisma.$tourcheckpointPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tourcheckpoints.
     * @param {tourcheckpointCreateManyArgs} args - Arguments to create many Tourcheckpoints.
     * @example
     * // Create many Tourcheckpoints
     * const tourcheckpoint = await prisma.tourcheckpoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tourcheckpointCreateManyArgs>(args?: SelectSubset<T, tourcheckpointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tourcheckpoints and returns the data saved in the database.
     * @param {tourcheckpointCreateManyAndReturnArgs} args - Arguments to create many Tourcheckpoints.
     * @example
     * // Create many Tourcheckpoints
     * const tourcheckpoint = await prisma.tourcheckpoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tourcheckpoints and only return the `tour_id`
     * const tourcheckpointWithTour_idOnly = await prisma.tourcheckpoint.createManyAndReturn({
     *   select: { tour_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tourcheckpointCreateManyAndReturnArgs>(args?: SelectSubset<T, tourcheckpointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tourcheckpointPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tourcheckpoint.
     * @param {tourcheckpointDeleteArgs} args - Arguments to delete one Tourcheckpoint.
     * @example
     * // Delete one Tourcheckpoint
     * const Tourcheckpoint = await prisma.tourcheckpoint.delete({
     *   where: {
     *     // ... filter to delete one Tourcheckpoint
     *   }
     * })
     * 
     */
    delete<T extends tourcheckpointDeleteArgs>(args: SelectSubset<T, tourcheckpointDeleteArgs<ExtArgs>>): Prisma__tourcheckpointClient<$Result.GetResult<Prisma.$tourcheckpointPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tourcheckpoint.
     * @param {tourcheckpointUpdateArgs} args - Arguments to update one Tourcheckpoint.
     * @example
     * // Update one Tourcheckpoint
     * const tourcheckpoint = await prisma.tourcheckpoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tourcheckpointUpdateArgs>(args: SelectSubset<T, tourcheckpointUpdateArgs<ExtArgs>>): Prisma__tourcheckpointClient<$Result.GetResult<Prisma.$tourcheckpointPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tourcheckpoints.
     * @param {tourcheckpointDeleteManyArgs} args - Arguments to filter Tourcheckpoints to delete.
     * @example
     * // Delete a few Tourcheckpoints
     * const { count } = await prisma.tourcheckpoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tourcheckpointDeleteManyArgs>(args?: SelectSubset<T, tourcheckpointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tourcheckpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourcheckpointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tourcheckpoints
     * const tourcheckpoint = await prisma.tourcheckpoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tourcheckpointUpdateManyArgs>(args: SelectSubset<T, tourcheckpointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tourcheckpoints and returns the data updated in the database.
     * @param {tourcheckpointUpdateManyAndReturnArgs} args - Arguments to update many Tourcheckpoints.
     * @example
     * // Update many Tourcheckpoints
     * const tourcheckpoint = await prisma.tourcheckpoint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tourcheckpoints and only return the `tour_id`
     * const tourcheckpointWithTour_idOnly = await prisma.tourcheckpoint.updateManyAndReturn({
     *   select: { tour_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tourcheckpointUpdateManyAndReturnArgs>(args: SelectSubset<T, tourcheckpointUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tourcheckpointPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tourcheckpoint.
     * @param {tourcheckpointUpsertArgs} args - Arguments to update or create a Tourcheckpoint.
     * @example
     * // Update or create a Tourcheckpoint
     * const tourcheckpoint = await prisma.tourcheckpoint.upsert({
     *   create: {
     *     // ... data to create a Tourcheckpoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tourcheckpoint we want to update
     *   }
     * })
     */
    upsert<T extends tourcheckpointUpsertArgs>(args: SelectSubset<T, tourcheckpointUpsertArgs<ExtArgs>>): Prisma__tourcheckpointClient<$Result.GetResult<Prisma.$tourcheckpointPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tourcheckpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourcheckpointCountArgs} args - Arguments to filter Tourcheckpoints to count.
     * @example
     * // Count the number of Tourcheckpoints
     * const count = await prisma.tourcheckpoint.count({
     *   where: {
     *     // ... the filter for the Tourcheckpoints we want to count
     *   }
     * })
    **/
    count<T extends tourcheckpointCountArgs>(
      args?: Subset<T, tourcheckpointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourcheckpointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tourcheckpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourcheckpointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourcheckpointAggregateArgs>(args: Subset<T, TourcheckpointAggregateArgs>): Prisma.PrismaPromise<GetTourcheckpointAggregateType<T>>

    /**
     * Group by Tourcheckpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tourcheckpointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tourcheckpointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tourcheckpointGroupByArgs['orderBy'] }
        : { orderBy?: tourcheckpointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tourcheckpointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourcheckpointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tourcheckpoint model
   */
  readonly fields: tourcheckpointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tourcheckpoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tourcheckpointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    checkpoint<T extends checkpointDefaultArgs<ExtArgs> = {}>(args?: Subset<T, checkpointDefaultArgs<ExtArgs>>): Prisma__checkpointClient<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tour<T extends tourDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tourDefaultArgs<ExtArgs>>): Prisma__tourClient<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tourcheckpoint model
   */
  interface tourcheckpointFieldRefs {
    readonly tour_id: FieldRef<"tourcheckpoint", 'Int'>
    readonly checkpoint_id: FieldRef<"tourcheckpoint", 'Int'>
    readonly checkpoint_order: FieldRef<"tourcheckpoint", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tourcheckpoint findUnique
   */
  export type tourcheckpointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointInclude<ExtArgs> | null
    /**
     * Filter, which tourcheckpoint to fetch.
     */
    where: tourcheckpointWhereUniqueInput
  }

  /**
   * tourcheckpoint findUniqueOrThrow
   */
  export type tourcheckpointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointInclude<ExtArgs> | null
    /**
     * Filter, which tourcheckpoint to fetch.
     */
    where: tourcheckpointWhereUniqueInput
  }

  /**
   * tourcheckpoint findFirst
   */
  export type tourcheckpointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointInclude<ExtArgs> | null
    /**
     * Filter, which tourcheckpoint to fetch.
     */
    where?: tourcheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tourcheckpoints to fetch.
     */
    orderBy?: tourcheckpointOrderByWithRelationInput | tourcheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tourcheckpoints.
     */
    cursor?: tourcheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tourcheckpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tourcheckpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tourcheckpoints.
     */
    distinct?: TourcheckpointScalarFieldEnum | TourcheckpointScalarFieldEnum[]
  }

  /**
   * tourcheckpoint findFirstOrThrow
   */
  export type tourcheckpointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointInclude<ExtArgs> | null
    /**
     * Filter, which tourcheckpoint to fetch.
     */
    where?: tourcheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tourcheckpoints to fetch.
     */
    orderBy?: tourcheckpointOrderByWithRelationInput | tourcheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tourcheckpoints.
     */
    cursor?: tourcheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tourcheckpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tourcheckpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tourcheckpoints.
     */
    distinct?: TourcheckpointScalarFieldEnum | TourcheckpointScalarFieldEnum[]
  }

  /**
   * tourcheckpoint findMany
   */
  export type tourcheckpointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointInclude<ExtArgs> | null
    /**
     * Filter, which tourcheckpoints to fetch.
     */
    where?: tourcheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tourcheckpoints to fetch.
     */
    orderBy?: tourcheckpointOrderByWithRelationInput | tourcheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tourcheckpoints.
     */
    cursor?: tourcheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tourcheckpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tourcheckpoints.
     */
    skip?: number
    distinct?: TourcheckpointScalarFieldEnum | TourcheckpointScalarFieldEnum[]
  }

  /**
   * tourcheckpoint create
   */
  export type tourcheckpointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointInclude<ExtArgs> | null
    /**
     * The data needed to create a tourcheckpoint.
     */
    data: XOR<tourcheckpointCreateInput, tourcheckpointUncheckedCreateInput>
  }

  /**
   * tourcheckpoint createMany
   */
  export type tourcheckpointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tourcheckpoints.
     */
    data: tourcheckpointCreateManyInput | tourcheckpointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tourcheckpoint createManyAndReturn
   */
  export type tourcheckpointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * The data used to create many tourcheckpoints.
     */
    data: tourcheckpointCreateManyInput | tourcheckpointCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tourcheckpoint update
   */
  export type tourcheckpointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointInclude<ExtArgs> | null
    /**
     * The data needed to update a tourcheckpoint.
     */
    data: XOR<tourcheckpointUpdateInput, tourcheckpointUncheckedUpdateInput>
    /**
     * Choose, which tourcheckpoint to update.
     */
    where: tourcheckpointWhereUniqueInput
  }

  /**
   * tourcheckpoint updateMany
   */
  export type tourcheckpointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tourcheckpoints.
     */
    data: XOR<tourcheckpointUpdateManyMutationInput, tourcheckpointUncheckedUpdateManyInput>
    /**
     * Filter which tourcheckpoints to update
     */
    where?: tourcheckpointWhereInput
    /**
     * Limit how many tourcheckpoints to update.
     */
    limit?: number
  }

  /**
   * tourcheckpoint updateManyAndReturn
   */
  export type tourcheckpointUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * The data used to update tourcheckpoints.
     */
    data: XOR<tourcheckpointUpdateManyMutationInput, tourcheckpointUncheckedUpdateManyInput>
    /**
     * Filter which tourcheckpoints to update
     */
    where?: tourcheckpointWhereInput
    /**
     * Limit how many tourcheckpoints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tourcheckpoint upsert
   */
  export type tourcheckpointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointInclude<ExtArgs> | null
    /**
     * The filter to search for the tourcheckpoint to update in case it exists.
     */
    where: tourcheckpointWhereUniqueInput
    /**
     * In case the tourcheckpoint found by the `where` argument doesn't exist, create a new tourcheckpoint with this data.
     */
    create: XOR<tourcheckpointCreateInput, tourcheckpointUncheckedCreateInput>
    /**
     * In case the tourcheckpoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tourcheckpointUpdateInput, tourcheckpointUncheckedUpdateInput>
  }

  /**
   * tourcheckpoint delete
   */
  export type tourcheckpointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointInclude<ExtArgs> | null
    /**
     * Filter which tourcheckpoint to delete.
     */
    where: tourcheckpointWhereUniqueInput
  }

  /**
   * tourcheckpoint deleteMany
   */
  export type tourcheckpointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tourcheckpoints to delete
     */
    where?: tourcheckpointWhereInput
    /**
     * Limit how many tourcheckpoints to delete.
     */
    limit?: number
  }

  /**
   * tourcheckpoint without action
   */
  export type tourcheckpointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tourcheckpoint
     */
    select?: tourcheckpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tourcheckpoint
     */
    omit?: tourcheckpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourcheckpointInclude<ExtArgs> | null
  }


  /**
   * Model userbadge
   */

  export type AggregateUserbadge = {
    _count: UserbadgeCountAggregateOutputType | null
    _avg: UserbadgeAvgAggregateOutputType | null
    _sum: UserbadgeSumAggregateOutputType | null
    _min: UserbadgeMinAggregateOutputType | null
    _max: UserbadgeMaxAggregateOutputType | null
  }

  export type UserbadgeAvgAggregateOutputType = {
    badge_id: number | null
    user_id: number | null
  }

  export type UserbadgeSumAggregateOutputType = {
    badge_id: number | null
    user_id: number | null
  }

  export type UserbadgeMinAggregateOutputType = {
    badge_id: number | null
    user_id: number | null
    created_at: Date | null
  }

  export type UserbadgeMaxAggregateOutputType = {
    badge_id: number | null
    user_id: number | null
    created_at: Date | null
  }

  export type UserbadgeCountAggregateOutputType = {
    badge_id: number
    user_id: number
    created_at: number
    _all: number
  }


  export type UserbadgeAvgAggregateInputType = {
    badge_id?: true
    user_id?: true
  }

  export type UserbadgeSumAggregateInputType = {
    badge_id?: true
    user_id?: true
  }

  export type UserbadgeMinAggregateInputType = {
    badge_id?: true
    user_id?: true
    created_at?: true
  }

  export type UserbadgeMaxAggregateInputType = {
    badge_id?: true
    user_id?: true
    created_at?: true
  }

  export type UserbadgeCountAggregateInputType = {
    badge_id?: true
    user_id?: true
    created_at?: true
    _all?: true
  }

  export type UserbadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userbadge to aggregate.
     */
    where?: userbadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userbadges to fetch.
     */
    orderBy?: userbadgeOrderByWithRelationInput | userbadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userbadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userbadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userbadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userbadges
    **/
    _count?: true | UserbadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserbadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserbadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserbadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserbadgeMaxAggregateInputType
  }

  export type GetUserbadgeAggregateType<T extends UserbadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserbadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserbadge[P]>
      : GetScalarType<T[P], AggregateUserbadge[P]>
  }




  export type userbadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userbadgeWhereInput
    orderBy?: userbadgeOrderByWithAggregationInput | userbadgeOrderByWithAggregationInput[]
    by: UserbadgeScalarFieldEnum[] | UserbadgeScalarFieldEnum
    having?: userbadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserbadgeCountAggregateInputType | true
    _avg?: UserbadgeAvgAggregateInputType
    _sum?: UserbadgeSumAggregateInputType
    _min?: UserbadgeMinAggregateInputType
    _max?: UserbadgeMaxAggregateInputType
  }

  export type UserbadgeGroupByOutputType = {
    badge_id: number
    user_id: number
    created_at: Date | null
    _count: UserbadgeCountAggregateOutputType | null
    _avg: UserbadgeAvgAggregateOutputType | null
    _sum: UserbadgeSumAggregateOutputType | null
    _min: UserbadgeMinAggregateOutputType | null
    _max: UserbadgeMaxAggregateOutputType | null
  }

  type GetUserbadgeGroupByPayload<T extends userbadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserbadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserbadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserbadgeGroupByOutputType[P]>
            : GetScalarType<T[P], UserbadgeGroupByOutputType[P]>
        }
      >
    >


  export type userbadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    badge_id?: boolean
    user_id?: boolean
    created_at?: boolean
    badge?: boolean | badgeDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userbadge"]>

  export type userbadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    badge_id?: boolean
    user_id?: boolean
    created_at?: boolean
    badge?: boolean | badgeDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userbadge"]>

  export type userbadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    badge_id?: boolean
    user_id?: boolean
    created_at?: boolean
    badge?: boolean | badgeDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userbadge"]>

  export type userbadgeSelectScalar = {
    badge_id?: boolean
    user_id?: boolean
    created_at?: boolean
  }

  export type userbadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"badge_id" | "user_id" | "created_at", ExtArgs["result"]["userbadge"]>
  export type userbadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | badgeDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type userbadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | badgeDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type userbadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badge?: boolean | badgeDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $userbadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userbadge"
    objects: {
      badge: Prisma.$badgePayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      badge_id: number
      user_id: number
      created_at: Date | null
    }, ExtArgs["result"]["userbadge"]>
    composites: {}
  }

  type userbadgeGetPayload<S extends boolean | null | undefined | userbadgeDefaultArgs> = $Result.GetResult<Prisma.$userbadgePayload, S>

  type userbadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userbadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserbadgeCountAggregateInputType | true
    }

  export interface userbadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userbadge'], meta: { name: 'userbadge' } }
    /**
     * Find zero or one Userbadge that matches the filter.
     * @param {userbadgeFindUniqueArgs} args - Arguments to find a Userbadge
     * @example
     * // Get one Userbadge
     * const userbadge = await prisma.userbadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userbadgeFindUniqueArgs>(args: SelectSubset<T, userbadgeFindUniqueArgs<ExtArgs>>): Prisma__userbadgeClient<$Result.GetResult<Prisma.$userbadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userbadge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userbadgeFindUniqueOrThrowArgs} args - Arguments to find a Userbadge
     * @example
     * // Get one Userbadge
     * const userbadge = await prisma.userbadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userbadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, userbadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userbadgeClient<$Result.GetResult<Prisma.$userbadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userbadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userbadgeFindFirstArgs} args - Arguments to find a Userbadge
     * @example
     * // Get one Userbadge
     * const userbadge = await prisma.userbadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userbadgeFindFirstArgs>(args?: SelectSubset<T, userbadgeFindFirstArgs<ExtArgs>>): Prisma__userbadgeClient<$Result.GetResult<Prisma.$userbadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userbadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userbadgeFindFirstOrThrowArgs} args - Arguments to find a Userbadge
     * @example
     * // Get one Userbadge
     * const userbadge = await prisma.userbadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userbadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, userbadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__userbadgeClient<$Result.GetResult<Prisma.$userbadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userbadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userbadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userbadges
     * const userbadges = await prisma.userbadge.findMany()
     * 
     * // Get first 10 Userbadges
     * const userbadges = await prisma.userbadge.findMany({ take: 10 })
     * 
     * // Only select the `badge_id`
     * const userbadgeWithBadge_idOnly = await prisma.userbadge.findMany({ select: { badge_id: true } })
     * 
     */
    findMany<T extends userbadgeFindManyArgs>(args?: SelectSubset<T, userbadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userbadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userbadge.
     * @param {userbadgeCreateArgs} args - Arguments to create a Userbadge.
     * @example
     * // Create one Userbadge
     * const Userbadge = await prisma.userbadge.create({
     *   data: {
     *     // ... data to create a Userbadge
     *   }
     * })
     * 
     */
    create<T extends userbadgeCreateArgs>(args: SelectSubset<T, userbadgeCreateArgs<ExtArgs>>): Prisma__userbadgeClient<$Result.GetResult<Prisma.$userbadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userbadges.
     * @param {userbadgeCreateManyArgs} args - Arguments to create many Userbadges.
     * @example
     * // Create many Userbadges
     * const userbadge = await prisma.userbadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userbadgeCreateManyArgs>(args?: SelectSubset<T, userbadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Userbadges and returns the data saved in the database.
     * @param {userbadgeCreateManyAndReturnArgs} args - Arguments to create many Userbadges.
     * @example
     * // Create many Userbadges
     * const userbadge = await prisma.userbadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Userbadges and only return the `badge_id`
     * const userbadgeWithBadge_idOnly = await prisma.userbadge.createManyAndReturn({
     *   select: { badge_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userbadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, userbadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userbadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Userbadge.
     * @param {userbadgeDeleteArgs} args - Arguments to delete one Userbadge.
     * @example
     * // Delete one Userbadge
     * const Userbadge = await prisma.userbadge.delete({
     *   where: {
     *     // ... filter to delete one Userbadge
     *   }
     * })
     * 
     */
    delete<T extends userbadgeDeleteArgs>(args: SelectSubset<T, userbadgeDeleteArgs<ExtArgs>>): Prisma__userbadgeClient<$Result.GetResult<Prisma.$userbadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userbadge.
     * @param {userbadgeUpdateArgs} args - Arguments to update one Userbadge.
     * @example
     * // Update one Userbadge
     * const userbadge = await prisma.userbadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userbadgeUpdateArgs>(args: SelectSubset<T, userbadgeUpdateArgs<ExtArgs>>): Prisma__userbadgeClient<$Result.GetResult<Prisma.$userbadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userbadges.
     * @param {userbadgeDeleteManyArgs} args - Arguments to filter Userbadges to delete.
     * @example
     * // Delete a few Userbadges
     * const { count } = await prisma.userbadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userbadgeDeleteManyArgs>(args?: SelectSubset<T, userbadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userbadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userbadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userbadges
     * const userbadge = await prisma.userbadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userbadgeUpdateManyArgs>(args: SelectSubset<T, userbadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userbadges and returns the data updated in the database.
     * @param {userbadgeUpdateManyAndReturnArgs} args - Arguments to update many Userbadges.
     * @example
     * // Update many Userbadges
     * const userbadge = await prisma.userbadge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Userbadges and only return the `badge_id`
     * const userbadgeWithBadge_idOnly = await prisma.userbadge.updateManyAndReturn({
     *   select: { badge_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userbadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, userbadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userbadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Userbadge.
     * @param {userbadgeUpsertArgs} args - Arguments to update or create a Userbadge.
     * @example
     * // Update or create a Userbadge
     * const userbadge = await prisma.userbadge.upsert({
     *   create: {
     *     // ... data to create a Userbadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userbadge we want to update
     *   }
     * })
     */
    upsert<T extends userbadgeUpsertArgs>(args: SelectSubset<T, userbadgeUpsertArgs<ExtArgs>>): Prisma__userbadgeClient<$Result.GetResult<Prisma.$userbadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userbadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userbadgeCountArgs} args - Arguments to filter Userbadges to count.
     * @example
     * // Count the number of Userbadges
     * const count = await prisma.userbadge.count({
     *   where: {
     *     // ... the filter for the Userbadges we want to count
     *   }
     * })
    **/
    count<T extends userbadgeCountArgs>(
      args?: Subset<T, userbadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserbadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userbadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserbadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserbadgeAggregateArgs>(args: Subset<T, UserbadgeAggregateArgs>): Prisma.PrismaPromise<GetUserbadgeAggregateType<T>>

    /**
     * Group by Userbadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userbadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userbadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userbadgeGroupByArgs['orderBy'] }
        : { orderBy?: userbadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userbadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserbadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userbadge model
   */
  readonly fields: userbadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userbadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userbadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badge<T extends badgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, badgeDefaultArgs<ExtArgs>>): Prisma__badgeClient<$Result.GetResult<Prisma.$badgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userbadge model
   */
  interface userbadgeFieldRefs {
    readonly badge_id: FieldRef<"userbadge", 'Int'>
    readonly user_id: FieldRef<"userbadge", 'Int'>
    readonly created_at: FieldRef<"userbadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userbadge findUnique
   */
  export type userbadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeInclude<ExtArgs> | null
    /**
     * Filter, which userbadge to fetch.
     */
    where: userbadgeWhereUniqueInput
  }

  /**
   * userbadge findUniqueOrThrow
   */
  export type userbadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeInclude<ExtArgs> | null
    /**
     * Filter, which userbadge to fetch.
     */
    where: userbadgeWhereUniqueInput
  }

  /**
   * userbadge findFirst
   */
  export type userbadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeInclude<ExtArgs> | null
    /**
     * Filter, which userbadge to fetch.
     */
    where?: userbadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userbadges to fetch.
     */
    orderBy?: userbadgeOrderByWithRelationInput | userbadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userbadges.
     */
    cursor?: userbadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userbadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userbadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userbadges.
     */
    distinct?: UserbadgeScalarFieldEnum | UserbadgeScalarFieldEnum[]
  }

  /**
   * userbadge findFirstOrThrow
   */
  export type userbadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeInclude<ExtArgs> | null
    /**
     * Filter, which userbadge to fetch.
     */
    where?: userbadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userbadges to fetch.
     */
    orderBy?: userbadgeOrderByWithRelationInput | userbadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userbadges.
     */
    cursor?: userbadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userbadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userbadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userbadges.
     */
    distinct?: UserbadgeScalarFieldEnum | UserbadgeScalarFieldEnum[]
  }

  /**
   * userbadge findMany
   */
  export type userbadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeInclude<ExtArgs> | null
    /**
     * Filter, which userbadges to fetch.
     */
    where?: userbadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userbadges to fetch.
     */
    orderBy?: userbadgeOrderByWithRelationInput | userbadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userbadges.
     */
    cursor?: userbadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userbadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userbadges.
     */
    skip?: number
    distinct?: UserbadgeScalarFieldEnum | UserbadgeScalarFieldEnum[]
  }

  /**
   * userbadge create
   */
  export type userbadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a userbadge.
     */
    data: XOR<userbadgeCreateInput, userbadgeUncheckedCreateInput>
  }

  /**
   * userbadge createMany
   */
  export type userbadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userbadges.
     */
    data: userbadgeCreateManyInput | userbadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userbadge createManyAndReturn
   */
  export type userbadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * The data used to create many userbadges.
     */
    data: userbadgeCreateManyInput | userbadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userbadge update
   */
  export type userbadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a userbadge.
     */
    data: XOR<userbadgeUpdateInput, userbadgeUncheckedUpdateInput>
    /**
     * Choose, which userbadge to update.
     */
    where: userbadgeWhereUniqueInput
  }

  /**
   * userbadge updateMany
   */
  export type userbadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userbadges.
     */
    data: XOR<userbadgeUpdateManyMutationInput, userbadgeUncheckedUpdateManyInput>
    /**
     * Filter which userbadges to update
     */
    where?: userbadgeWhereInput
    /**
     * Limit how many userbadges to update.
     */
    limit?: number
  }

  /**
   * userbadge updateManyAndReturn
   */
  export type userbadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * The data used to update userbadges.
     */
    data: XOR<userbadgeUpdateManyMutationInput, userbadgeUncheckedUpdateManyInput>
    /**
     * Filter which userbadges to update
     */
    where?: userbadgeWhereInput
    /**
     * Limit how many userbadges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userbadge upsert
   */
  export type userbadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the userbadge to update in case it exists.
     */
    where: userbadgeWhereUniqueInput
    /**
     * In case the userbadge found by the `where` argument doesn't exist, create a new userbadge with this data.
     */
    create: XOR<userbadgeCreateInput, userbadgeUncheckedCreateInput>
    /**
     * In case the userbadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userbadgeUpdateInput, userbadgeUncheckedUpdateInput>
  }

  /**
   * userbadge delete
   */
  export type userbadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeInclude<ExtArgs> | null
    /**
     * Filter which userbadge to delete.
     */
    where: userbadgeWhereUniqueInput
  }

  /**
   * userbadge deleteMany
   */
  export type userbadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userbadges to delete
     */
    where?: userbadgeWhereInput
    /**
     * Limit how many userbadges to delete.
     */
    limit?: number
  }

  /**
   * userbadge without action
   */
  export type userbadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeInclude<ExtArgs> | null
  }


  /**
   * Model usercheckpointattempt
   */

  export type AggregateUsercheckpointattempt = {
    _count: UsercheckpointattemptCountAggregateOutputType | null
    _avg: UsercheckpointattemptAvgAggregateOutputType | null
    _sum: UsercheckpointattemptSumAggregateOutputType | null
    _min: UsercheckpointattemptMinAggregateOutputType | null
    _max: UsercheckpointattemptMaxAggregateOutputType | null
  }

  export type UsercheckpointattemptAvgAggregateOutputType = {
    checkpointattempt_id: number | null
    user_id: number | null
    checkpoint_id: number | null
    tourcompletion_id: number | null
  }

  export type UsercheckpointattemptSumAggregateOutputType = {
    checkpointattempt_id: number | null
    user_id: number | null
    checkpoint_id: number | null
    tourcompletion_id: number | null
  }

  export type UsercheckpointattemptMinAggregateOutputType = {
    checkpointattempt_id: number | null
    user_id: number | null
    checkpoint_id: number | null
    tourcompletion_id: number | null
    created_at: Date | null
  }

  export type UsercheckpointattemptMaxAggregateOutputType = {
    checkpointattempt_id: number | null
    user_id: number | null
    checkpoint_id: number | null
    tourcompletion_id: number | null
    created_at: Date | null
  }

  export type UsercheckpointattemptCountAggregateOutputType = {
    checkpointattempt_id: number
    user_id: number
    checkpoint_id: number
    tourcompletion_id: number
    created_at: number
    _all: number
  }


  export type UsercheckpointattemptAvgAggregateInputType = {
    checkpointattempt_id?: true
    user_id?: true
    checkpoint_id?: true
    tourcompletion_id?: true
  }

  export type UsercheckpointattemptSumAggregateInputType = {
    checkpointattempt_id?: true
    user_id?: true
    checkpoint_id?: true
    tourcompletion_id?: true
  }

  export type UsercheckpointattemptMinAggregateInputType = {
    checkpointattempt_id?: true
    user_id?: true
    checkpoint_id?: true
    tourcompletion_id?: true
    created_at?: true
  }

  export type UsercheckpointattemptMaxAggregateInputType = {
    checkpointattempt_id?: true
    user_id?: true
    checkpoint_id?: true
    tourcompletion_id?: true
    created_at?: true
  }

  export type UsercheckpointattemptCountAggregateInputType = {
    checkpointattempt_id?: true
    user_id?: true
    checkpoint_id?: true
    tourcompletion_id?: true
    created_at?: true
    _all?: true
  }

  export type UsercheckpointattemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usercheckpointattempt to aggregate.
     */
    where?: usercheckpointattemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usercheckpointattempts to fetch.
     */
    orderBy?: usercheckpointattemptOrderByWithRelationInput | usercheckpointattemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usercheckpointattemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usercheckpointattempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usercheckpointattempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usercheckpointattempts
    **/
    _count?: true | UsercheckpointattemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsercheckpointattemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsercheckpointattemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsercheckpointattemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsercheckpointattemptMaxAggregateInputType
  }

  export type GetUsercheckpointattemptAggregateType<T extends UsercheckpointattemptAggregateArgs> = {
        [P in keyof T & keyof AggregateUsercheckpointattempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsercheckpointattempt[P]>
      : GetScalarType<T[P], AggregateUsercheckpointattempt[P]>
  }




  export type usercheckpointattemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usercheckpointattemptWhereInput
    orderBy?: usercheckpointattemptOrderByWithAggregationInput | usercheckpointattemptOrderByWithAggregationInput[]
    by: UsercheckpointattemptScalarFieldEnum[] | UsercheckpointattemptScalarFieldEnum
    having?: usercheckpointattemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsercheckpointattemptCountAggregateInputType | true
    _avg?: UsercheckpointattemptAvgAggregateInputType
    _sum?: UsercheckpointattemptSumAggregateInputType
    _min?: UsercheckpointattemptMinAggregateInputType
    _max?: UsercheckpointattemptMaxAggregateInputType
  }

  export type UsercheckpointattemptGroupByOutputType = {
    checkpointattempt_id: number
    user_id: number
    checkpoint_id: number | null
    tourcompletion_id: number
    created_at: Date | null
    _count: UsercheckpointattemptCountAggregateOutputType | null
    _avg: UsercheckpointattemptAvgAggregateOutputType | null
    _sum: UsercheckpointattemptSumAggregateOutputType | null
    _min: UsercheckpointattemptMinAggregateOutputType | null
    _max: UsercheckpointattemptMaxAggregateOutputType | null
  }

  type GetUsercheckpointattemptGroupByPayload<T extends usercheckpointattemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsercheckpointattemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsercheckpointattemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsercheckpointattemptGroupByOutputType[P]>
            : GetScalarType<T[P], UsercheckpointattemptGroupByOutputType[P]>
        }
      >
    >


  export type usercheckpointattemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    checkpointattempt_id?: boolean
    user_id?: boolean
    checkpoint_id?: boolean
    tourcompletion_id?: boolean
    created_at?: boolean
    checkpoint?: boolean | usercheckpointattempt$checkpointArgs<ExtArgs>
    usertourcompletion?: boolean | usertourcompletionDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usercheckpointattempt"]>

  export type usercheckpointattemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    checkpointattempt_id?: boolean
    user_id?: boolean
    checkpoint_id?: boolean
    tourcompletion_id?: boolean
    created_at?: boolean
    checkpoint?: boolean | usercheckpointattempt$checkpointArgs<ExtArgs>
    usertourcompletion?: boolean | usertourcompletionDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usercheckpointattempt"]>

  export type usercheckpointattemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    checkpointattempt_id?: boolean
    user_id?: boolean
    checkpoint_id?: boolean
    tourcompletion_id?: boolean
    created_at?: boolean
    checkpoint?: boolean | usercheckpointattempt$checkpointArgs<ExtArgs>
    usertourcompletion?: boolean | usertourcompletionDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usercheckpointattempt"]>

  export type usercheckpointattemptSelectScalar = {
    checkpointattempt_id?: boolean
    user_id?: boolean
    checkpoint_id?: boolean
    tourcompletion_id?: boolean
    created_at?: boolean
  }

  export type usercheckpointattemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"checkpointattempt_id" | "user_id" | "checkpoint_id" | "tourcompletion_id" | "created_at", ExtArgs["result"]["usercheckpointattempt"]>
  export type usercheckpointattemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoint?: boolean | usercheckpointattempt$checkpointArgs<ExtArgs>
    usertourcompletion?: boolean | usertourcompletionDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type usercheckpointattemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoint?: boolean | usercheckpointattempt$checkpointArgs<ExtArgs>
    usertourcompletion?: boolean | usertourcompletionDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type usercheckpointattemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoint?: boolean | usercheckpointattempt$checkpointArgs<ExtArgs>
    usertourcompletion?: boolean | usertourcompletionDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $usercheckpointattemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usercheckpointattempt"
    objects: {
      checkpoint: Prisma.$checkpointPayload<ExtArgs> | null
      usertourcompletion: Prisma.$usertourcompletionPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      checkpointattempt_id: number
      user_id: number
      checkpoint_id: number | null
      tourcompletion_id: number
      created_at: Date | null
    }, ExtArgs["result"]["usercheckpointattempt"]>
    composites: {}
  }

  type usercheckpointattemptGetPayload<S extends boolean | null | undefined | usercheckpointattemptDefaultArgs> = $Result.GetResult<Prisma.$usercheckpointattemptPayload, S>

  type usercheckpointattemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usercheckpointattemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsercheckpointattemptCountAggregateInputType | true
    }

  export interface usercheckpointattemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usercheckpointattempt'], meta: { name: 'usercheckpointattempt' } }
    /**
     * Find zero or one Usercheckpointattempt that matches the filter.
     * @param {usercheckpointattemptFindUniqueArgs} args - Arguments to find a Usercheckpointattempt
     * @example
     * // Get one Usercheckpointattempt
     * const usercheckpointattempt = await prisma.usercheckpointattempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usercheckpointattemptFindUniqueArgs>(args: SelectSubset<T, usercheckpointattemptFindUniqueArgs<ExtArgs>>): Prisma__usercheckpointattemptClient<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usercheckpointattempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usercheckpointattemptFindUniqueOrThrowArgs} args - Arguments to find a Usercheckpointattempt
     * @example
     * // Get one Usercheckpointattempt
     * const usercheckpointattempt = await prisma.usercheckpointattempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usercheckpointattemptFindUniqueOrThrowArgs>(args: SelectSubset<T, usercheckpointattemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usercheckpointattemptClient<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usercheckpointattempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usercheckpointattemptFindFirstArgs} args - Arguments to find a Usercheckpointattempt
     * @example
     * // Get one Usercheckpointattempt
     * const usercheckpointattempt = await prisma.usercheckpointattempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usercheckpointattemptFindFirstArgs>(args?: SelectSubset<T, usercheckpointattemptFindFirstArgs<ExtArgs>>): Prisma__usercheckpointattemptClient<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usercheckpointattempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usercheckpointattemptFindFirstOrThrowArgs} args - Arguments to find a Usercheckpointattempt
     * @example
     * // Get one Usercheckpointattempt
     * const usercheckpointattempt = await prisma.usercheckpointattempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usercheckpointattemptFindFirstOrThrowArgs>(args?: SelectSubset<T, usercheckpointattemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__usercheckpointattemptClient<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usercheckpointattempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usercheckpointattemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usercheckpointattempts
     * const usercheckpointattempts = await prisma.usercheckpointattempt.findMany()
     * 
     * // Get first 10 Usercheckpointattempts
     * const usercheckpointattempts = await prisma.usercheckpointattempt.findMany({ take: 10 })
     * 
     * // Only select the `checkpointattempt_id`
     * const usercheckpointattemptWithCheckpointattempt_idOnly = await prisma.usercheckpointattempt.findMany({ select: { checkpointattempt_id: true } })
     * 
     */
    findMany<T extends usercheckpointattemptFindManyArgs>(args?: SelectSubset<T, usercheckpointattemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usercheckpointattempt.
     * @param {usercheckpointattemptCreateArgs} args - Arguments to create a Usercheckpointattempt.
     * @example
     * // Create one Usercheckpointattempt
     * const Usercheckpointattempt = await prisma.usercheckpointattempt.create({
     *   data: {
     *     // ... data to create a Usercheckpointattempt
     *   }
     * })
     * 
     */
    create<T extends usercheckpointattemptCreateArgs>(args: SelectSubset<T, usercheckpointattemptCreateArgs<ExtArgs>>): Prisma__usercheckpointattemptClient<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usercheckpointattempts.
     * @param {usercheckpointattemptCreateManyArgs} args - Arguments to create many Usercheckpointattempts.
     * @example
     * // Create many Usercheckpointattempts
     * const usercheckpointattempt = await prisma.usercheckpointattempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usercheckpointattemptCreateManyArgs>(args?: SelectSubset<T, usercheckpointattemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usercheckpointattempts and returns the data saved in the database.
     * @param {usercheckpointattemptCreateManyAndReturnArgs} args - Arguments to create many Usercheckpointattempts.
     * @example
     * // Create many Usercheckpointattempts
     * const usercheckpointattempt = await prisma.usercheckpointattempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usercheckpointattempts and only return the `checkpointattempt_id`
     * const usercheckpointattemptWithCheckpointattempt_idOnly = await prisma.usercheckpointattempt.createManyAndReturn({
     *   select: { checkpointattempt_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usercheckpointattemptCreateManyAndReturnArgs>(args?: SelectSubset<T, usercheckpointattemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usercheckpointattempt.
     * @param {usercheckpointattemptDeleteArgs} args - Arguments to delete one Usercheckpointattempt.
     * @example
     * // Delete one Usercheckpointattempt
     * const Usercheckpointattempt = await prisma.usercheckpointattempt.delete({
     *   where: {
     *     // ... filter to delete one Usercheckpointattempt
     *   }
     * })
     * 
     */
    delete<T extends usercheckpointattemptDeleteArgs>(args: SelectSubset<T, usercheckpointattemptDeleteArgs<ExtArgs>>): Prisma__usercheckpointattemptClient<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usercheckpointattempt.
     * @param {usercheckpointattemptUpdateArgs} args - Arguments to update one Usercheckpointattempt.
     * @example
     * // Update one Usercheckpointattempt
     * const usercheckpointattempt = await prisma.usercheckpointattempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usercheckpointattemptUpdateArgs>(args: SelectSubset<T, usercheckpointattemptUpdateArgs<ExtArgs>>): Prisma__usercheckpointattemptClient<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usercheckpointattempts.
     * @param {usercheckpointattemptDeleteManyArgs} args - Arguments to filter Usercheckpointattempts to delete.
     * @example
     * // Delete a few Usercheckpointattempts
     * const { count } = await prisma.usercheckpointattempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usercheckpointattemptDeleteManyArgs>(args?: SelectSubset<T, usercheckpointattemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usercheckpointattempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usercheckpointattemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usercheckpointattempts
     * const usercheckpointattempt = await prisma.usercheckpointattempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usercheckpointattemptUpdateManyArgs>(args: SelectSubset<T, usercheckpointattemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usercheckpointattempts and returns the data updated in the database.
     * @param {usercheckpointattemptUpdateManyAndReturnArgs} args - Arguments to update many Usercheckpointattempts.
     * @example
     * // Update many Usercheckpointattempts
     * const usercheckpointattempt = await prisma.usercheckpointattempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usercheckpointattempts and only return the `checkpointattempt_id`
     * const usercheckpointattemptWithCheckpointattempt_idOnly = await prisma.usercheckpointattempt.updateManyAndReturn({
     *   select: { checkpointattempt_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usercheckpointattemptUpdateManyAndReturnArgs>(args: SelectSubset<T, usercheckpointattemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usercheckpointattempt.
     * @param {usercheckpointattemptUpsertArgs} args - Arguments to update or create a Usercheckpointattempt.
     * @example
     * // Update or create a Usercheckpointattempt
     * const usercheckpointattempt = await prisma.usercheckpointattempt.upsert({
     *   create: {
     *     // ... data to create a Usercheckpointattempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usercheckpointattempt we want to update
     *   }
     * })
     */
    upsert<T extends usercheckpointattemptUpsertArgs>(args: SelectSubset<T, usercheckpointattemptUpsertArgs<ExtArgs>>): Prisma__usercheckpointattemptClient<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usercheckpointattempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usercheckpointattemptCountArgs} args - Arguments to filter Usercheckpointattempts to count.
     * @example
     * // Count the number of Usercheckpointattempts
     * const count = await prisma.usercheckpointattempt.count({
     *   where: {
     *     // ... the filter for the Usercheckpointattempts we want to count
     *   }
     * })
    **/
    count<T extends usercheckpointattemptCountArgs>(
      args?: Subset<T, usercheckpointattemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsercheckpointattemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usercheckpointattempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsercheckpointattemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsercheckpointattemptAggregateArgs>(args: Subset<T, UsercheckpointattemptAggregateArgs>): Prisma.PrismaPromise<GetUsercheckpointattemptAggregateType<T>>

    /**
     * Group by Usercheckpointattempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usercheckpointattemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usercheckpointattemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usercheckpointattemptGroupByArgs['orderBy'] }
        : { orderBy?: usercheckpointattemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usercheckpointattemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsercheckpointattemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usercheckpointattempt model
   */
  readonly fields: usercheckpointattemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usercheckpointattempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usercheckpointattemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    checkpoint<T extends usercheckpointattempt$checkpointArgs<ExtArgs> = {}>(args?: Subset<T, usercheckpointattempt$checkpointArgs<ExtArgs>>): Prisma__checkpointClient<$Result.GetResult<Prisma.$checkpointPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usertourcompletion<T extends usertourcompletionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usertourcompletionDefaultArgs<ExtArgs>>): Prisma__usertourcompletionClient<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usercheckpointattempt model
   */
  interface usercheckpointattemptFieldRefs {
    readonly checkpointattempt_id: FieldRef<"usercheckpointattempt", 'Int'>
    readonly user_id: FieldRef<"usercheckpointattempt", 'Int'>
    readonly checkpoint_id: FieldRef<"usercheckpointattempt", 'Int'>
    readonly tourcompletion_id: FieldRef<"usercheckpointattempt", 'Int'>
    readonly created_at: FieldRef<"usercheckpointattempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * usercheckpointattempt findUnique
   */
  export type usercheckpointattemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptInclude<ExtArgs> | null
    /**
     * Filter, which usercheckpointattempt to fetch.
     */
    where: usercheckpointattemptWhereUniqueInput
  }

  /**
   * usercheckpointattempt findUniqueOrThrow
   */
  export type usercheckpointattemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptInclude<ExtArgs> | null
    /**
     * Filter, which usercheckpointattempt to fetch.
     */
    where: usercheckpointattemptWhereUniqueInput
  }

  /**
   * usercheckpointattempt findFirst
   */
  export type usercheckpointattemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptInclude<ExtArgs> | null
    /**
     * Filter, which usercheckpointattempt to fetch.
     */
    where?: usercheckpointattemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usercheckpointattempts to fetch.
     */
    orderBy?: usercheckpointattemptOrderByWithRelationInput | usercheckpointattemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usercheckpointattempts.
     */
    cursor?: usercheckpointattemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usercheckpointattempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usercheckpointattempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usercheckpointattempts.
     */
    distinct?: UsercheckpointattemptScalarFieldEnum | UsercheckpointattemptScalarFieldEnum[]
  }

  /**
   * usercheckpointattempt findFirstOrThrow
   */
  export type usercheckpointattemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptInclude<ExtArgs> | null
    /**
     * Filter, which usercheckpointattempt to fetch.
     */
    where?: usercheckpointattemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usercheckpointattempts to fetch.
     */
    orderBy?: usercheckpointattemptOrderByWithRelationInput | usercheckpointattemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usercheckpointattempts.
     */
    cursor?: usercheckpointattemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usercheckpointattempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usercheckpointattempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usercheckpointattempts.
     */
    distinct?: UsercheckpointattemptScalarFieldEnum | UsercheckpointattemptScalarFieldEnum[]
  }

  /**
   * usercheckpointattempt findMany
   */
  export type usercheckpointattemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptInclude<ExtArgs> | null
    /**
     * Filter, which usercheckpointattempts to fetch.
     */
    where?: usercheckpointattemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usercheckpointattempts to fetch.
     */
    orderBy?: usercheckpointattemptOrderByWithRelationInput | usercheckpointattemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usercheckpointattempts.
     */
    cursor?: usercheckpointattemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usercheckpointattempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usercheckpointattempts.
     */
    skip?: number
    distinct?: UsercheckpointattemptScalarFieldEnum | UsercheckpointattemptScalarFieldEnum[]
  }

  /**
   * usercheckpointattempt create
   */
  export type usercheckpointattemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptInclude<ExtArgs> | null
    /**
     * The data needed to create a usercheckpointattempt.
     */
    data: XOR<usercheckpointattemptCreateInput, usercheckpointattemptUncheckedCreateInput>
  }

  /**
   * usercheckpointattempt createMany
   */
  export type usercheckpointattemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usercheckpointattempts.
     */
    data: usercheckpointattemptCreateManyInput | usercheckpointattemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usercheckpointattempt createManyAndReturn
   */
  export type usercheckpointattemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * The data used to create many usercheckpointattempts.
     */
    data: usercheckpointattemptCreateManyInput | usercheckpointattemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * usercheckpointattempt update
   */
  export type usercheckpointattemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptInclude<ExtArgs> | null
    /**
     * The data needed to update a usercheckpointattempt.
     */
    data: XOR<usercheckpointattemptUpdateInput, usercheckpointattemptUncheckedUpdateInput>
    /**
     * Choose, which usercheckpointattempt to update.
     */
    where: usercheckpointattemptWhereUniqueInput
  }

  /**
   * usercheckpointattempt updateMany
   */
  export type usercheckpointattemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usercheckpointattempts.
     */
    data: XOR<usercheckpointattemptUpdateManyMutationInput, usercheckpointattemptUncheckedUpdateManyInput>
    /**
     * Filter which usercheckpointattempts to update
     */
    where?: usercheckpointattemptWhereInput
    /**
     * Limit how many usercheckpointattempts to update.
     */
    limit?: number
  }

  /**
   * usercheckpointattempt updateManyAndReturn
   */
  export type usercheckpointattemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * The data used to update usercheckpointattempts.
     */
    data: XOR<usercheckpointattemptUpdateManyMutationInput, usercheckpointattemptUncheckedUpdateManyInput>
    /**
     * Filter which usercheckpointattempts to update
     */
    where?: usercheckpointattemptWhereInput
    /**
     * Limit how many usercheckpointattempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * usercheckpointattempt upsert
   */
  export type usercheckpointattemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptInclude<ExtArgs> | null
    /**
     * The filter to search for the usercheckpointattempt to update in case it exists.
     */
    where: usercheckpointattemptWhereUniqueInput
    /**
     * In case the usercheckpointattempt found by the `where` argument doesn't exist, create a new usercheckpointattempt with this data.
     */
    create: XOR<usercheckpointattemptCreateInput, usercheckpointattemptUncheckedCreateInput>
    /**
     * In case the usercheckpointattempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usercheckpointattemptUpdateInput, usercheckpointattemptUncheckedUpdateInput>
  }

  /**
   * usercheckpointattempt delete
   */
  export type usercheckpointattemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptInclude<ExtArgs> | null
    /**
     * Filter which usercheckpointattempt to delete.
     */
    where: usercheckpointattemptWhereUniqueInput
  }

  /**
   * usercheckpointattempt deleteMany
   */
  export type usercheckpointattemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usercheckpointattempts to delete
     */
    where?: usercheckpointattemptWhereInput
    /**
     * Limit how many usercheckpointattempts to delete.
     */
    limit?: number
  }

  /**
   * usercheckpointattempt.checkpoint
   */
  export type usercheckpointattempt$checkpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoint
     */
    select?: checkpointSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checkpoint
     */
    omit?: checkpointOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointInclude<ExtArgs> | null
    where?: checkpointWhereInput
  }

  /**
   * usercheckpointattempt without action
   */
  export type usercheckpointattemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptInclude<ExtArgs> | null
  }


  /**
   * Model userprofile
   */

  export type AggregateUserprofile = {
    _count: UserprofileCountAggregateOutputType | null
    _avg: UserprofileAvgAggregateOutputType | null
    _sum: UserprofileSumAggregateOutputType | null
    _min: UserprofileMinAggregateOutputType | null
    _max: UserprofileMaxAggregateOutputType | null
  }

  export type UserprofileAvgAggregateOutputType = {
    profile_id: number | null
    user_id: number | null
    points: number | null
    level: number | null
  }

  export type UserprofileSumAggregateOutputType = {
    profile_id: number | null
    user_id: number | null
    points: number | null
    level: number | null
  }

  export type UserprofileMinAggregateOutputType = {
    profile_id: number | null
    user_id: number | null
    points: number | null
    level: number | null
    first_name: string | null
    last_name: string | null
    school: string | null
    sec_level: $Enums.sec_level | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserprofileMaxAggregateOutputType = {
    profile_id: number | null
    user_id: number | null
    points: number | null
    level: number | null
    first_name: string | null
    last_name: string | null
    school: string | null
    sec_level: $Enums.sec_level | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserprofileCountAggregateOutputType = {
    profile_id: number
    user_id: number
    points: number
    level: number
    first_name: number
    last_name: number
    school: number
    sec_level: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserprofileAvgAggregateInputType = {
    profile_id?: true
    user_id?: true
    points?: true
    level?: true
  }

  export type UserprofileSumAggregateInputType = {
    profile_id?: true
    user_id?: true
    points?: true
    level?: true
  }

  export type UserprofileMinAggregateInputType = {
    profile_id?: true
    user_id?: true
    points?: true
    level?: true
    first_name?: true
    last_name?: true
    school?: true
    sec_level?: true
    created_at?: true
    updated_at?: true
  }

  export type UserprofileMaxAggregateInputType = {
    profile_id?: true
    user_id?: true
    points?: true
    level?: true
    first_name?: true
    last_name?: true
    school?: true
    sec_level?: true
    created_at?: true
    updated_at?: true
  }

  export type UserprofileCountAggregateInputType = {
    profile_id?: true
    user_id?: true
    points?: true
    level?: true
    first_name?: true
    last_name?: true
    school?: true
    sec_level?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserprofileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userprofile to aggregate.
     */
    where?: userprofileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userprofiles to fetch.
     */
    orderBy?: userprofileOrderByWithRelationInput | userprofileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userprofileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userprofiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userprofiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userprofiles
    **/
    _count?: true | UserprofileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserprofileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserprofileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserprofileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserprofileMaxAggregateInputType
  }

  export type GetUserprofileAggregateType<T extends UserprofileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserprofile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserprofile[P]>
      : GetScalarType<T[P], AggregateUserprofile[P]>
  }




  export type userprofileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userprofileWhereInput
    orderBy?: userprofileOrderByWithAggregationInput | userprofileOrderByWithAggregationInput[]
    by: UserprofileScalarFieldEnum[] | UserprofileScalarFieldEnum
    having?: userprofileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserprofileCountAggregateInputType | true
    _avg?: UserprofileAvgAggregateInputType
    _sum?: UserprofileSumAggregateInputType
    _min?: UserprofileMinAggregateInputType
    _max?: UserprofileMaxAggregateInputType
  }

  export type UserprofileGroupByOutputType = {
    profile_id: number
    user_id: number
    points: number | null
    level: number | null
    first_name: string
    last_name: string
    school: string | null
    sec_level: $Enums.sec_level
    created_at: Date | null
    updated_at: Date | null
    _count: UserprofileCountAggregateOutputType | null
    _avg: UserprofileAvgAggregateOutputType | null
    _sum: UserprofileSumAggregateOutputType | null
    _min: UserprofileMinAggregateOutputType | null
    _max: UserprofileMaxAggregateOutputType | null
  }

  type GetUserprofileGroupByPayload<T extends userprofileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserprofileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserprofileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserprofileGroupByOutputType[P]>
            : GetScalarType<T[P], UserprofileGroupByOutputType[P]>
        }
      >
    >


  export type userprofileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profile_id?: boolean
    user_id?: boolean
    points?: boolean
    level?: boolean
    first_name?: boolean
    last_name?: boolean
    school?: boolean
    sec_level?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userprofile"]>

  export type userprofileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profile_id?: boolean
    user_id?: boolean
    points?: boolean
    level?: boolean
    first_name?: boolean
    last_name?: boolean
    school?: boolean
    sec_level?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userprofile"]>

  export type userprofileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profile_id?: boolean
    user_id?: boolean
    points?: boolean
    level?: boolean
    first_name?: boolean
    last_name?: boolean
    school?: boolean
    sec_level?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userprofile"]>

  export type userprofileSelectScalar = {
    profile_id?: boolean
    user_id?: boolean
    points?: boolean
    level?: boolean
    first_name?: boolean
    last_name?: boolean
    school?: boolean
    sec_level?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type userprofileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"profile_id" | "user_id" | "points" | "level" | "first_name" | "last_name" | "school" | "sec_level" | "created_at" | "updated_at", ExtArgs["result"]["userprofile"]>
  export type userprofileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type userprofileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type userprofileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $userprofilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userprofile"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      profile_id: number
      user_id: number
      points: number | null
      level: number | null
      first_name: string
      last_name: string
      school: string | null
      sec_level: $Enums.sec_level
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["userprofile"]>
    composites: {}
  }

  type userprofileGetPayload<S extends boolean | null | undefined | userprofileDefaultArgs> = $Result.GetResult<Prisma.$userprofilePayload, S>

  type userprofileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userprofileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserprofileCountAggregateInputType | true
    }

  export interface userprofileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userprofile'], meta: { name: 'userprofile' } }
    /**
     * Find zero or one Userprofile that matches the filter.
     * @param {userprofileFindUniqueArgs} args - Arguments to find a Userprofile
     * @example
     * // Get one Userprofile
     * const userprofile = await prisma.userprofile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userprofileFindUniqueArgs>(args: SelectSubset<T, userprofileFindUniqueArgs<ExtArgs>>): Prisma__userprofileClient<$Result.GetResult<Prisma.$userprofilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userprofile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userprofileFindUniqueOrThrowArgs} args - Arguments to find a Userprofile
     * @example
     * // Get one Userprofile
     * const userprofile = await prisma.userprofile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userprofileFindUniqueOrThrowArgs>(args: SelectSubset<T, userprofileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userprofileClient<$Result.GetResult<Prisma.$userprofilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userprofile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userprofileFindFirstArgs} args - Arguments to find a Userprofile
     * @example
     * // Get one Userprofile
     * const userprofile = await prisma.userprofile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userprofileFindFirstArgs>(args?: SelectSubset<T, userprofileFindFirstArgs<ExtArgs>>): Prisma__userprofileClient<$Result.GetResult<Prisma.$userprofilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userprofile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userprofileFindFirstOrThrowArgs} args - Arguments to find a Userprofile
     * @example
     * // Get one Userprofile
     * const userprofile = await prisma.userprofile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userprofileFindFirstOrThrowArgs>(args?: SelectSubset<T, userprofileFindFirstOrThrowArgs<ExtArgs>>): Prisma__userprofileClient<$Result.GetResult<Prisma.$userprofilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userprofiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userprofileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userprofiles
     * const userprofiles = await prisma.userprofile.findMany()
     * 
     * // Get first 10 Userprofiles
     * const userprofiles = await prisma.userprofile.findMany({ take: 10 })
     * 
     * // Only select the `profile_id`
     * const userprofileWithProfile_idOnly = await prisma.userprofile.findMany({ select: { profile_id: true } })
     * 
     */
    findMany<T extends userprofileFindManyArgs>(args?: SelectSubset<T, userprofileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userprofilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userprofile.
     * @param {userprofileCreateArgs} args - Arguments to create a Userprofile.
     * @example
     * // Create one Userprofile
     * const Userprofile = await prisma.userprofile.create({
     *   data: {
     *     // ... data to create a Userprofile
     *   }
     * })
     * 
     */
    create<T extends userprofileCreateArgs>(args: SelectSubset<T, userprofileCreateArgs<ExtArgs>>): Prisma__userprofileClient<$Result.GetResult<Prisma.$userprofilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userprofiles.
     * @param {userprofileCreateManyArgs} args - Arguments to create many Userprofiles.
     * @example
     * // Create many Userprofiles
     * const userprofile = await prisma.userprofile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userprofileCreateManyArgs>(args?: SelectSubset<T, userprofileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Userprofiles and returns the data saved in the database.
     * @param {userprofileCreateManyAndReturnArgs} args - Arguments to create many Userprofiles.
     * @example
     * // Create many Userprofiles
     * const userprofile = await prisma.userprofile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Userprofiles and only return the `profile_id`
     * const userprofileWithProfile_idOnly = await prisma.userprofile.createManyAndReturn({
     *   select: { profile_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userprofileCreateManyAndReturnArgs>(args?: SelectSubset<T, userprofileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userprofilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Userprofile.
     * @param {userprofileDeleteArgs} args - Arguments to delete one Userprofile.
     * @example
     * // Delete one Userprofile
     * const Userprofile = await prisma.userprofile.delete({
     *   where: {
     *     // ... filter to delete one Userprofile
     *   }
     * })
     * 
     */
    delete<T extends userprofileDeleteArgs>(args: SelectSubset<T, userprofileDeleteArgs<ExtArgs>>): Prisma__userprofileClient<$Result.GetResult<Prisma.$userprofilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userprofile.
     * @param {userprofileUpdateArgs} args - Arguments to update one Userprofile.
     * @example
     * // Update one Userprofile
     * const userprofile = await prisma.userprofile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userprofileUpdateArgs>(args: SelectSubset<T, userprofileUpdateArgs<ExtArgs>>): Prisma__userprofileClient<$Result.GetResult<Prisma.$userprofilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userprofiles.
     * @param {userprofileDeleteManyArgs} args - Arguments to filter Userprofiles to delete.
     * @example
     * // Delete a few Userprofiles
     * const { count } = await prisma.userprofile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userprofileDeleteManyArgs>(args?: SelectSubset<T, userprofileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userprofiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userprofileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userprofiles
     * const userprofile = await prisma.userprofile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userprofileUpdateManyArgs>(args: SelectSubset<T, userprofileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userprofiles and returns the data updated in the database.
     * @param {userprofileUpdateManyAndReturnArgs} args - Arguments to update many Userprofiles.
     * @example
     * // Update many Userprofiles
     * const userprofile = await prisma.userprofile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Userprofiles and only return the `profile_id`
     * const userprofileWithProfile_idOnly = await prisma.userprofile.updateManyAndReturn({
     *   select: { profile_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userprofileUpdateManyAndReturnArgs>(args: SelectSubset<T, userprofileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userprofilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Userprofile.
     * @param {userprofileUpsertArgs} args - Arguments to update or create a Userprofile.
     * @example
     * // Update or create a Userprofile
     * const userprofile = await prisma.userprofile.upsert({
     *   create: {
     *     // ... data to create a Userprofile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userprofile we want to update
     *   }
     * })
     */
    upsert<T extends userprofileUpsertArgs>(args: SelectSubset<T, userprofileUpsertArgs<ExtArgs>>): Prisma__userprofileClient<$Result.GetResult<Prisma.$userprofilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userprofiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userprofileCountArgs} args - Arguments to filter Userprofiles to count.
     * @example
     * // Count the number of Userprofiles
     * const count = await prisma.userprofile.count({
     *   where: {
     *     // ... the filter for the Userprofiles we want to count
     *   }
     * })
    **/
    count<T extends userprofileCountArgs>(
      args?: Subset<T, userprofileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserprofileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userprofile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserprofileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserprofileAggregateArgs>(args: Subset<T, UserprofileAggregateArgs>): Prisma.PrismaPromise<GetUserprofileAggregateType<T>>

    /**
     * Group by Userprofile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userprofileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userprofileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userprofileGroupByArgs['orderBy'] }
        : { orderBy?: userprofileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userprofileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserprofileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userprofile model
   */
  readonly fields: userprofileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userprofile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userprofileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userprofile model
   */
  interface userprofileFieldRefs {
    readonly profile_id: FieldRef<"userprofile", 'Int'>
    readonly user_id: FieldRef<"userprofile", 'Int'>
    readonly points: FieldRef<"userprofile", 'Int'>
    readonly level: FieldRef<"userprofile", 'Int'>
    readonly first_name: FieldRef<"userprofile", 'String'>
    readonly last_name: FieldRef<"userprofile", 'String'>
    readonly school: FieldRef<"userprofile", 'String'>
    readonly sec_level: FieldRef<"userprofile", 'sec_level'>
    readonly created_at: FieldRef<"userprofile", 'DateTime'>
    readonly updated_at: FieldRef<"userprofile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userprofile findUnique
   */
  export type userprofileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userprofile
     */
    select?: userprofileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userprofile
     */
    omit?: userprofileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userprofileInclude<ExtArgs> | null
    /**
     * Filter, which userprofile to fetch.
     */
    where: userprofileWhereUniqueInput
  }

  /**
   * userprofile findUniqueOrThrow
   */
  export type userprofileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userprofile
     */
    select?: userprofileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userprofile
     */
    omit?: userprofileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userprofileInclude<ExtArgs> | null
    /**
     * Filter, which userprofile to fetch.
     */
    where: userprofileWhereUniqueInput
  }

  /**
   * userprofile findFirst
   */
  export type userprofileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userprofile
     */
    select?: userprofileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userprofile
     */
    omit?: userprofileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userprofileInclude<ExtArgs> | null
    /**
     * Filter, which userprofile to fetch.
     */
    where?: userprofileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userprofiles to fetch.
     */
    orderBy?: userprofileOrderByWithRelationInput | userprofileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userprofiles.
     */
    cursor?: userprofileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userprofiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userprofiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userprofiles.
     */
    distinct?: UserprofileScalarFieldEnum | UserprofileScalarFieldEnum[]
  }

  /**
   * userprofile findFirstOrThrow
   */
  export type userprofileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userprofile
     */
    select?: userprofileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userprofile
     */
    omit?: userprofileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userprofileInclude<ExtArgs> | null
    /**
     * Filter, which userprofile to fetch.
     */
    where?: userprofileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userprofiles to fetch.
     */
    orderBy?: userprofileOrderByWithRelationInput | userprofileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userprofiles.
     */
    cursor?: userprofileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userprofiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userprofiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userprofiles.
     */
    distinct?: UserprofileScalarFieldEnum | UserprofileScalarFieldEnum[]
  }

  /**
   * userprofile findMany
   */
  export type userprofileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userprofile
     */
    select?: userprofileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userprofile
     */
    omit?: userprofileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userprofileInclude<ExtArgs> | null
    /**
     * Filter, which userprofiles to fetch.
     */
    where?: userprofileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userprofiles to fetch.
     */
    orderBy?: userprofileOrderByWithRelationInput | userprofileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userprofiles.
     */
    cursor?: userprofileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userprofiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userprofiles.
     */
    skip?: number
    distinct?: UserprofileScalarFieldEnum | UserprofileScalarFieldEnum[]
  }

  /**
   * userprofile create
   */
  export type userprofileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userprofile
     */
    select?: userprofileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userprofile
     */
    omit?: userprofileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userprofileInclude<ExtArgs> | null
    /**
     * The data needed to create a userprofile.
     */
    data: XOR<userprofileCreateInput, userprofileUncheckedCreateInput>
  }

  /**
   * userprofile createMany
   */
  export type userprofileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userprofiles.
     */
    data: userprofileCreateManyInput | userprofileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userprofile createManyAndReturn
   */
  export type userprofileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userprofile
     */
    select?: userprofileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userprofile
     */
    omit?: userprofileOmit<ExtArgs> | null
    /**
     * The data used to create many userprofiles.
     */
    data: userprofileCreateManyInput | userprofileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userprofileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userprofile update
   */
  export type userprofileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userprofile
     */
    select?: userprofileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userprofile
     */
    omit?: userprofileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userprofileInclude<ExtArgs> | null
    /**
     * The data needed to update a userprofile.
     */
    data: XOR<userprofileUpdateInput, userprofileUncheckedUpdateInput>
    /**
     * Choose, which userprofile to update.
     */
    where: userprofileWhereUniqueInput
  }

  /**
   * userprofile updateMany
   */
  export type userprofileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userprofiles.
     */
    data: XOR<userprofileUpdateManyMutationInput, userprofileUncheckedUpdateManyInput>
    /**
     * Filter which userprofiles to update
     */
    where?: userprofileWhereInput
    /**
     * Limit how many userprofiles to update.
     */
    limit?: number
  }

  /**
   * userprofile updateManyAndReturn
   */
  export type userprofileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userprofile
     */
    select?: userprofileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userprofile
     */
    omit?: userprofileOmit<ExtArgs> | null
    /**
     * The data used to update userprofiles.
     */
    data: XOR<userprofileUpdateManyMutationInput, userprofileUncheckedUpdateManyInput>
    /**
     * Filter which userprofiles to update
     */
    where?: userprofileWhereInput
    /**
     * Limit how many userprofiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userprofileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userprofile upsert
   */
  export type userprofileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userprofile
     */
    select?: userprofileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userprofile
     */
    omit?: userprofileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userprofileInclude<ExtArgs> | null
    /**
     * The filter to search for the userprofile to update in case it exists.
     */
    where: userprofileWhereUniqueInput
    /**
     * In case the userprofile found by the `where` argument doesn't exist, create a new userprofile with this data.
     */
    create: XOR<userprofileCreateInput, userprofileUncheckedCreateInput>
    /**
     * In case the userprofile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userprofileUpdateInput, userprofileUncheckedUpdateInput>
  }

  /**
   * userprofile delete
   */
  export type userprofileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userprofile
     */
    select?: userprofileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userprofile
     */
    omit?: userprofileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userprofileInclude<ExtArgs> | null
    /**
     * Filter which userprofile to delete.
     */
    where: userprofileWhereUniqueInput
  }

  /**
   * userprofile deleteMany
   */
  export type userprofileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userprofiles to delete
     */
    where?: userprofileWhereInput
    /**
     * Limit how many userprofiles to delete.
     */
    limit?: number
  }

  /**
   * userprofile without action
   */
  export type userprofileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userprofile
     */
    select?: userprofileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userprofile
     */
    omit?: userprofileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userprofileInclude<ExtArgs> | null
  }


  /**
   * Model userquizcompletion
   */

  export type AggregateUserquizcompletion = {
    _count: UserquizcompletionCountAggregateOutputType | null
    _avg: UserquizcompletionAvgAggregateOutputType | null
    _sum: UserquizcompletionSumAggregateOutputType | null
    _min: UserquizcompletionMinAggregateOutputType | null
    _max: UserquizcompletionMaxAggregateOutputType | null
  }

  export type UserquizcompletionAvgAggregateOutputType = {
    quizcompletion_id: number | null
    quiz_id: number | null
    user_id: number | null
    score: number | null
  }

  export type UserquizcompletionSumAggregateOutputType = {
    quizcompletion_id: number | null
    quiz_id: number | null
    user_id: number | null
    score: number | null
  }

  export type UserquizcompletionMinAggregateOutputType = {
    quizcompletion_id: number | null
    quiz_id: number | null
    user_id: number | null
    score: number | null
    created_at: Date | null
  }

  export type UserquizcompletionMaxAggregateOutputType = {
    quizcompletion_id: number | null
    quiz_id: number | null
    user_id: number | null
    score: number | null
    created_at: Date | null
  }

  export type UserquizcompletionCountAggregateOutputType = {
    quizcompletion_id: number
    quiz_id: number
    user_id: number
    score: number
    created_at: number
    _all: number
  }


  export type UserquizcompletionAvgAggregateInputType = {
    quizcompletion_id?: true
    quiz_id?: true
    user_id?: true
    score?: true
  }

  export type UserquizcompletionSumAggregateInputType = {
    quizcompletion_id?: true
    quiz_id?: true
    user_id?: true
    score?: true
  }

  export type UserquizcompletionMinAggregateInputType = {
    quizcompletion_id?: true
    quiz_id?: true
    user_id?: true
    score?: true
    created_at?: true
  }

  export type UserquizcompletionMaxAggregateInputType = {
    quizcompletion_id?: true
    quiz_id?: true
    user_id?: true
    score?: true
    created_at?: true
  }

  export type UserquizcompletionCountAggregateInputType = {
    quizcompletion_id?: true
    quiz_id?: true
    user_id?: true
    score?: true
    created_at?: true
    _all?: true
  }

  export type UserquizcompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userquizcompletion to aggregate.
     */
    where?: userquizcompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userquizcompletions to fetch.
     */
    orderBy?: userquizcompletionOrderByWithRelationInput | userquizcompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userquizcompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userquizcompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userquizcompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userquizcompletions
    **/
    _count?: true | UserquizcompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserquizcompletionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserquizcompletionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserquizcompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserquizcompletionMaxAggregateInputType
  }

  export type GetUserquizcompletionAggregateType<T extends UserquizcompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserquizcompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserquizcompletion[P]>
      : GetScalarType<T[P], AggregateUserquizcompletion[P]>
  }




  export type userquizcompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userquizcompletionWhereInput
    orderBy?: userquizcompletionOrderByWithAggregationInput | userquizcompletionOrderByWithAggregationInput[]
    by: UserquizcompletionScalarFieldEnum[] | UserquizcompletionScalarFieldEnum
    having?: userquizcompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserquizcompletionCountAggregateInputType | true
    _avg?: UserquizcompletionAvgAggregateInputType
    _sum?: UserquizcompletionSumAggregateInputType
    _min?: UserquizcompletionMinAggregateInputType
    _max?: UserquizcompletionMaxAggregateInputType
  }

  export type UserquizcompletionGroupByOutputType = {
    quizcompletion_id: number
    quiz_id: number
    user_id: number
    score: number
    created_at: Date | null
    _count: UserquizcompletionCountAggregateOutputType | null
    _avg: UserquizcompletionAvgAggregateOutputType | null
    _sum: UserquizcompletionSumAggregateOutputType | null
    _min: UserquizcompletionMinAggregateOutputType | null
    _max: UserquizcompletionMaxAggregateOutputType | null
  }

  type GetUserquizcompletionGroupByPayload<T extends userquizcompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserquizcompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserquizcompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserquizcompletionGroupByOutputType[P]>
            : GetScalarType<T[P], UserquizcompletionGroupByOutputType[P]>
        }
      >
    >


  export type userquizcompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    quizcompletion_id?: boolean
    quiz_id?: boolean
    user_id?: boolean
    score?: boolean
    created_at?: boolean
    quiz?: boolean | quizDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userquizcompletion"]>

  export type userquizcompletionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    quizcompletion_id?: boolean
    quiz_id?: boolean
    user_id?: boolean
    score?: boolean
    created_at?: boolean
    quiz?: boolean | quizDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userquizcompletion"]>

  export type userquizcompletionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    quizcompletion_id?: boolean
    quiz_id?: boolean
    user_id?: boolean
    score?: boolean
    created_at?: boolean
    quiz?: boolean | quizDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userquizcompletion"]>

  export type userquizcompletionSelectScalar = {
    quizcompletion_id?: boolean
    quiz_id?: boolean
    user_id?: boolean
    score?: boolean
    created_at?: boolean
  }

  export type userquizcompletionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"quizcompletion_id" | "quiz_id" | "user_id" | "score" | "created_at", ExtArgs["result"]["userquizcompletion"]>
  export type userquizcompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | quizDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type userquizcompletionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | quizDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type userquizcompletionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | quizDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $userquizcompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userquizcompletion"
    objects: {
      quiz: Prisma.$quizPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      quizcompletion_id: number
      quiz_id: number
      user_id: number
      score: number
      created_at: Date | null
    }, ExtArgs["result"]["userquizcompletion"]>
    composites: {}
  }

  type userquizcompletionGetPayload<S extends boolean | null | undefined | userquizcompletionDefaultArgs> = $Result.GetResult<Prisma.$userquizcompletionPayload, S>

  type userquizcompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userquizcompletionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserquizcompletionCountAggregateInputType | true
    }

  export interface userquizcompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userquizcompletion'], meta: { name: 'userquizcompletion' } }
    /**
     * Find zero or one Userquizcompletion that matches the filter.
     * @param {userquizcompletionFindUniqueArgs} args - Arguments to find a Userquizcompletion
     * @example
     * // Get one Userquizcompletion
     * const userquizcompletion = await prisma.userquizcompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userquizcompletionFindUniqueArgs>(args: SelectSubset<T, userquizcompletionFindUniqueArgs<ExtArgs>>): Prisma__userquizcompletionClient<$Result.GetResult<Prisma.$userquizcompletionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userquizcompletion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userquizcompletionFindUniqueOrThrowArgs} args - Arguments to find a Userquizcompletion
     * @example
     * // Get one Userquizcompletion
     * const userquizcompletion = await prisma.userquizcompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userquizcompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, userquizcompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userquizcompletionClient<$Result.GetResult<Prisma.$userquizcompletionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userquizcompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userquizcompletionFindFirstArgs} args - Arguments to find a Userquizcompletion
     * @example
     * // Get one Userquizcompletion
     * const userquizcompletion = await prisma.userquizcompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userquizcompletionFindFirstArgs>(args?: SelectSubset<T, userquizcompletionFindFirstArgs<ExtArgs>>): Prisma__userquizcompletionClient<$Result.GetResult<Prisma.$userquizcompletionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userquizcompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userquizcompletionFindFirstOrThrowArgs} args - Arguments to find a Userquizcompletion
     * @example
     * // Get one Userquizcompletion
     * const userquizcompletion = await prisma.userquizcompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userquizcompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, userquizcompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__userquizcompletionClient<$Result.GetResult<Prisma.$userquizcompletionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userquizcompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userquizcompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userquizcompletions
     * const userquizcompletions = await prisma.userquizcompletion.findMany()
     * 
     * // Get first 10 Userquizcompletions
     * const userquizcompletions = await prisma.userquizcompletion.findMany({ take: 10 })
     * 
     * // Only select the `quizcompletion_id`
     * const userquizcompletionWithQuizcompletion_idOnly = await prisma.userquizcompletion.findMany({ select: { quizcompletion_id: true } })
     * 
     */
    findMany<T extends userquizcompletionFindManyArgs>(args?: SelectSubset<T, userquizcompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userquizcompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userquizcompletion.
     * @param {userquizcompletionCreateArgs} args - Arguments to create a Userquizcompletion.
     * @example
     * // Create one Userquizcompletion
     * const Userquizcompletion = await prisma.userquizcompletion.create({
     *   data: {
     *     // ... data to create a Userquizcompletion
     *   }
     * })
     * 
     */
    create<T extends userquizcompletionCreateArgs>(args: SelectSubset<T, userquizcompletionCreateArgs<ExtArgs>>): Prisma__userquizcompletionClient<$Result.GetResult<Prisma.$userquizcompletionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userquizcompletions.
     * @param {userquizcompletionCreateManyArgs} args - Arguments to create many Userquizcompletions.
     * @example
     * // Create many Userquizcompletions
     * const userquizcompletion = await prisma.userquizcompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userquizcompletionCreateManyArgs>(args?: SelectSubset<T, userquizcompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Userquizcompletions and returns the data saved in the database.
     * @param {userquizcompletionCreateManyAndReturnArgs} args - Arguments to create many Userquizcompletions.
     * @example
     * // Create many Userquizcompletions
     * const userquizcompletion = await prisma.userquizcompletion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Userquizcompletions and only return the `quizcompletion_id`
     * const userquizcompletionWithQuizcompletion_idOnly = await prisma.userquizcompletion.createManyAndReturn({
     *   select: { quizcompletion_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userquizcompletionCreateManyAndReturnArgs>(args?: SelectSubset<T, userquizcompletionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userquizcompletionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Userquizcompletion.
     * @param {userquizcompletionDeleteArgs} args - Arguments to delete one Userquizcompletion.
     * @example
     * // Delete one Userquizcompletion
     * const Userquizcompletion = await prisma.userquizcompletion.delete({
     *   where: {
     *     // ... filter to delete one Userquizcompletion
     *   }
     * })
     * 
     */
    delete<T extends userquizcompletionDeleteArgs>(args: SelectSubset<T, userquizcompletionDeleteArgs<ExtArgs>>): Prisma__userquizcompletionClient<$Result.GetResult<Prisma.$userquizcompletionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userquizcompletion.
     * @param {userquizcompletionUpdateArgs} args - Arguments to update one Userquizcompletion.
     * @example
     * // Update one Userquizcompletion
     * const userquizcompletion = await prisma.userquizcompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userquizcompletionUpdateArgs>(args: SelectSubset<T, userquizcompletionUpdateArgs<ExtArgs>>): Prisma__userquizcompletionClient<$Result.GetResult<Prisma.$userquizcompletionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userquizcompletions.
     * @param {userquizcompletionDeleteManyArgs} args - Arguments to filter Userquizcompletions to delete.
     * @example
     * // Delete a few Userquizcompletions
     * const { count } = await prisma.userquizcompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userquizcompletionDeleteManyArgs>(args?: SelectSubset<T, userquizcompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userquizcompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userquizcompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userquizcompletions
     * const userquizcompletion = await prisma.userquizcompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userquizcompletionUpdateManyArgs>(args: SelectSubset<T, userquizcompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userquizcompletions and returns the data updated in the database.
     * @param {userquizcompletionUpdateManyAndReturnArgs} args - Arguments to update many Userquizcompletions.
     * @example
     * // Update many Userquizcompletions
     * const userquizcompletion = await prisma.userquizcompletion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Userquizcompletions and only return the `quizcompletion_id`
     * const userquizcompletionWithQuizcompletion_idOnly = await prisma.userquizcompletion.updateManyAndReturn({
     *   select: { quizcompletion_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userquizcompletionUpdateManyAndReturnArgs>(args: SelectSubset<T, userquizcompletionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userquizcompletionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Userquizcompletion.
     * @param {userquizcompletionUpsertArgs} args - Arguments to update or create a Userquizcompletion.
     * @example
     * // Update or create a Userquizcompletion
     * const userquizcompletion = await prisma.userquizcompletion.upsert({
     *   create: {
     *     // ... data to create a Userquizcompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userquizcompletion we want to update
     *   }
     * })
     */
    upsert<T extends userquizcompletionUpsertArgs>(args: SelectSubset<T, userquizcompletionUpsertArgs<ExtArgs>>): Prisma__userquizcompletionClient<$Result.GetResult<Prisma.$userquizcompletionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userquizcompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userquizcompletionCountArgs} args - Arguments to filter Userquizcompletions to count.
     * @example
     * // Count the number of Userquizcompletions
     * const count = await prisma.userquizcompletion.count({
     *   where: {
     *     // ... the filter for the Userquizcompletions we want to count
     *   }
     * })
    **/
    count<T extends userquizcompletionCountArgs>(
      args?: Subset<T, userquizcompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserquizcompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userquizcompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserquizcompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserquizcompletionAggregateArgs>(args: Subset<T, UserquizcompletionAggregateArgs>): Prisma.PrismaPromise<GetUserquizcompletionAggregateType<T>>

    /**
     * Group by Userquizcompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userquizcompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userquizcompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userquizcompletionGroupByArgs['orderBy'] }
        : { orderBy?: userquizcompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userquizcompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserquizcompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userquizcompletion model
   */
  readonly fields: userquizcompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userquizcompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userquizcompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends quizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, quizDefaultArgs<ExtArgs>>): Prisma__quizClient<$Result.GetResult<Prisma.$quizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userquizcompletion model
   */
  interface userquizcompletionFieldRefs {
    readonly quizcompletion_id: FieldRef<"userquizcompletion", 'Int'>
    readonly quiz_id: FieldRef<"userquizcompletion", 'Int'>
    readonly user_id: FieldRef<"userquizcompletion", 'Int'>
    readonly score: FieldRef<"userquizcompletion", 'Int'>
    readonly created_at: FieldRef<"userquizcompletion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userquizcompletion findUnique
   */
  export type userquizcompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionInclude<ExtArgs> | null
    /**
     * Filter, which userquizcompletion to fetch.
     */
    where: userquizcompletionWhereUniqueInput
  }

  /**
   * userquizcompletion findUniqueOrThrow
   */
  export type userquizcompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionInclude<ExtArgs> | null
    /**
     * Filter, which userquizcompletion to fetch.
     */
    where: userquizcompletionWhereUniqueInput
  }

  /**
   * userquizcompletion findFirst
   */
  export type userquizcompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionInclude<ExtArgs> | null
    /**
     * Filter, which userquizcompletion to fetch.
     */
    where?: userquizcompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userquizcompletions to fetch.
     */
    orderBy?: userquizcompletionOrderByWithRelationInput | userquizcompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userquizcompletions.
     */
    cursor?: userquizcompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userquizcompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userquizcompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userquizcompletions.
     */
    distinct?: UserquizcompletionScalarFieldEnum | UserquizcompletionScalarFieldEnum[]
  }

  /**
   * userquizcompletion findFirstOrThrow
   */
  export type userquizcompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionInclude<ExtArgs> | null
    /**
     * Filter, which userquizcompletion to fetch.
     */
    where?: userquizcompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userquizcompletions to fetch.
     */
    orderBy?: userquizcompletionOrderByWithRelationInput | userquizcompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userquizcompletions.
     */
    cursor?: userquizcompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userquizcompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userquizcompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userquizcompletions.
     */
    distinct?: UserquizcompletionScalarFieldEnum | UserquizcompletionScalarFieldEnum[]
  }

  /**
   * userquizcompletion findMany
   */
  export type userquizcompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionInclude<ExtArgs> | null
    /**
     * Filter, which userquizcompletions to fetch.
     */
    where?: userquizcompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userquizcompletions to fetch.
     */
    orderBy?: userquizcompletionOrderByWithRelationInput | userquizcompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userquizcompletions.
     */
    cursor?: userquizcompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userquizcompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userquizcompletions.
     */
    skip?: number
    distinct?: UserquizcompletionScalarFieldEnum | UserquizcompletionScalarFieldEnum[]
  }

  /**
   * userquizcompletion create
   */
  export type userquizcompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a userquizcompletion.
     */
    data: XOR<userquizcompletionCreateInput, userquizcompletionUncheckedCreateInput>
  }

  /**
   * userquizcompletion createMany
   */
  export type userquizcompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userquizcompletions.
     */
    data: userquizcompletionCreateManyInput | userquizcompletionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userquizcompletion createManyAndReturn
   */
  export type userquizcompletionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * The data used to create many userquizcompletions.
     */
    data: userquizcompletionCreateManyInput | userquizcompletionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userquizcompletion update
   */
  export type userquizcompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a userquizcompletion.
     */
    data: XOR<userquizcompletionUpdateInput, userquizcompletionUncheckedUpdateInput>
    /**
     * Choose, which userquizcompletion to update.
     */
    where: userquizcompletionWhereUniqueInput
  }

  /**
   * userquizcompletion updateMany
   */
  export type userquizcompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userquizcompletions.
     */
    data: XOR<userquizcompletionUpdateManyMutationInput, userquizcompletionUncheckedUpdateManyInput>
    /**
     * Filter which userquizcompletions to update
     */
    where?: userquizcompletionWhereInput
    /**
     * Limit how many userquizcompletions to update.
     */
    limit?: number
  }

  /**
   * userquizcompletion updateManyAndReturn
   */
  export type userquizcompletionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * The data used to update userquizcompletions.
     */
    data: XOR<userquizcompletionUpdateManyMutationInput, userquizcompletionUncheckedUpdateManyInput>
    /**
     * Filter which userquizcompletions to update
     */
    where?: userquizcompletionWhereInput
    /**
     * Limit how many userquizcompletions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userquizcompletion upsert
   */
  export type userquizcompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the userquizcompletion to update in case it exists.
     */
    where: userquizcompletionWhereUniqueInput
    /**
     * In case the userquizcompletion found by the `where` argument doesn't exist, create a new userquizcompletion with this data.
     */
    create: XOR<userquizcompletionCreateInput, userquizcompletionUncheckedCreateInput>
    /**
     * In case the userquizcompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userquizcompletionUpdateInput, userquizcompletionUncheckedUpdateInput>
  }

  /**
   * userquizcompletion delete
   */
  export type userquizcompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionInclude<ExtArgs> | null
    /**
     * Filter which userquizcompletion to delete.
     */
    where: userquizcompletionWhereUniqueInput
  }

  /**
   * userquizcompletion deleteMany
   */
  export type userquizcompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userquizcompletions to delete
     */
    where?: userquizcompletionWhereInput
    /**
     * Limit how many userquizcompletions to delete.
     */
    limit?: number
  }

  /**
   * userquizcompletion without action
   */
  export type userquizcompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionInclude<ExtArgs> | null
  }


  /**
   * Model userrole
   */

  export type AggregateUserrole = {
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  export type UserroleAvgAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type UserroleSumAggregateOutputType = {
    user_id: number | null
    role_id: number | null
  }

  export type UserroleMinAggregateOutputType = {
    user_id: number | null
    role_id: number | null
    created_at: Date | null
  }

  export type UserroleMaxAggregateOutputType = {
    user_id: number | null
    role_id: number | null
    created_at: Date | null
  }

  export type UserroleCountAggregateOutputType = {
    user_id: number
    role_id: number
    created_at: number
    _all: number
  }


  export type UserroleAvgAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type UserroleSumAggregateInputType = {
    user_id?: true
    role_id?: true
  }

  export type UserroleMinAggregateInputType = {
    user_id?: true
    role_id?: true
    created_at?: true
  }

  export type UserroleMaxAggregateInputType = {
    user_id?: true
    role_id?: true
    created_at?: true
  }

  export type UserroleCountAggregateInputType = {
    user_id?: true
    role_id?: true
    created_at?: true
    _all?: true
  }

  export type UserroleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userrole to aggregate.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userroles
    **/
    _count?: true | UserroleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserroleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserroleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserroleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserroleMaxAggregateInputType
  }

  export type GetUserroleAggregateType<T extends UserroleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserrole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserrole[P]>
      : GetScalarType<T[P], AggregateUserrole[P]>
  }




  export type userroleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithAggregationInput | userroleOrderByWithAggregationInput[]
    by: UserroleScalarFieldEnum[] | UserroleScalarFieldEnum
    having?: userroleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserroleCountAggregateInputType | true
    _avg?: UserroleAvgAggregateInputType
    _sum?: UserroleSumAggregateInputType
    _min?: UserroleMinAggregateInputType
    _max?: UserroleMaxAggregateInputType
  }

  export type UserroleGroupByOutputType = {
    user_id: number
    role_id: number
    created_at: Date | null
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  type GetUserroleGroupByPayload<T extends userroleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserroleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserroleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserroleGroupByOutputType[P]>
            : GetScalarType<T[P], UserroleGroupByOutputType[P]>
        }
      >
    >


  export type userroleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    role_id?: boolean
    created_at?: boolean
    role?: boolean | roleDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>

  export type userroleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    role_id?: boolean
    created_at?: boolean
    role?: boolean | roleDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>

  export type userroleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    role_id?: boolean
    created_at?: boolean
    role?: boolean | roleDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>

  export type userroleSelectScalar = {
    user_id?: boolean
    role_id?: boolean
    created_at?: boolean
  }

  export type userroleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "role_id" | "created_at", ExtArgs["result"]["userrole"]>
  export type userroleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | roleDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type userroleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | roleDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type userroleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | roleDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $userrolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userrole"
    objects: {
      role: Prisma.$rolePayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      role_id: number
      created_at: Date | null
    }, ExtArgs["result"]["userrole"]>
    composites: {}
  }

  type userroleGetPayload<S extends boolean | null | undefined | userroleDefaultArgs> = $Result.GetResult<Prisma.$userrolePayload, S>

  type userroleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userroleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserroleCountAggregateInputType | true
    }

  export interface userroleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userrole'], meta: { name: 'userrole' } }
    /**
     * Find zero or one Userrole that matches the filter.
     * @param {userroleFindUniqueArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userroleFindUniqueArgs>(args: SelectSubset<T, userroleFindUniqueArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userrole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userroleFindUniqueOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userroleFindUniqueOrThrowArgs>(args: SelectSubset<T, userroleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userrole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userroleFindFirstArgs>(args?: SelectSubset<T, userroleFindFirstArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userrole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userroleFindFirstOrThrowArgs>(args?: SelectSubset<T, userroleFindFirstOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userroles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userroles
     * const userroles = await prisma.userrole.findMany()
     * 
     * // Get first 10 Userroles
     * const userroles = await prisma.userrole.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userroleWithUser_idOnly = await prisma.userrole.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends userroleFindManyArgs>(args?: SelectSubset<T, userroleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userrole.
     * @param {userroleCreateArgs} args - Arguments to create a Userrole.
     * @example
     * // Create one Userrole
     * const Userrole = await prisma.userrole.create({
     *   data: {
     *     // ... data to create a Userrole
     *   }
     * })
     * 
     */
    create<T extends userroleCreateArgs>(args: SelectSubset<T, userroleCreateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userroles.
     * @param {userroleCreateManyArgs} args - Arguments to create many Userroles.
     * @example
     * // Create many Userroles
     * const userrole = await prisma.userrole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userroleCreateManyArgs>(args?: SelectSubset<T, userroleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Userroles and returns the data saved in the database.
     * @param {userroleCreateManyAndReturnArgs} args - Arguments to create many Userroles.
     * @example
     * // Create many Userroles
     * const userrole = await prisma.userrole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Userroles and only return the `user_id`
     * const userroleWithUser_idOnly = await prisma.userrole.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userroleCreateManyAndReturnArgs>(args?: SelectSubset<T, userroleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Userrole.
     * @param {userroleDeleteArgs} args - Arguments to delete one Userrole.
     * @example
     * // Delete one Userrole
     * const Userrole = await prisma.userrole.delete({
     *   where: {
     *     // ... filter to delete one Userrole
     *   }
     * })
     * 
     */
    delete<T extends userroleDeleteArgs>(args: SelectSubset<T, userroleDeleteArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userrole.
     * @param {userroleUpdateArgs} args - Arguments to update one Userrole.
     * @example
     * // Update one Userrole
     * const userrole = await prisma.userrole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userroleUpdateArgs>(args: SelectSubset<T, userroleUpdateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userroles.
     * @param {userroleDeleteManyArgs} args - Arguments to filter Userroles to delete.
     * @example
     * // Delete a few Userroles
     * const { count } = await prisma.userrole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userroleDeleteManyArgs>(args?: SelectSubset<T, userroleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userroles
     * const userrole = await prisma.userrole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userroleUpdateManyArgs>(args: SelectSubset<T, userroleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userroles and returns the data updated in the database.
     * @param {userroleUpdateManyAndReturnArgs} args - Arguments to update many Userroles.
     * @example
     * // Update many Userroles
     * const userrole = await prisma.userrole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Userroles and only return the `user_id`
     * const userroleWithUser_idOnly = await prisma.userrole.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userroleUpdateManyAndReturnArgs>(args: SelectSubset<T, userroleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Userrole.
     * @param {userroleUpsertArgs} args - Arguments to update or create a Userrole.
     * @example
     * // Update or create a Userrole
     * const userrole = await prisma.userrole.upsert({
     *   create: {
     *     // ... data to create a Userrole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userrole we want to update
     *   }
     * })
     */
    upsert<T extends userroleUpsertArgs>(args: SelectSubset<T, userroleUpsertArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleCountArgs} args - Arguments to filter Userroles to count.
     * @example
     * // Count the number of Userroles
     * const count = await prisma.userrole.count({
     *   where: {
     *     // ... the filter for the Userroles we want to count
     *   }
     * })
    **/
    count<T extends userroleCountArgs>(
      args?: Subset<T, userroleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserroleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserroleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserroleAggregateArgs>(args: Subset<T, UserroleAggregateArgs>): Prisma.PrismaPromise<GetUserroleAggregateType<T>>

    /**
     * Group by Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userroleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userroleGroupByArgs['orderBy'] }
        : { orderBy?: userroleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userroleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserroleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userrole model
   */
  readonly fields: userroleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userrole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userroleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roleDefaultArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userrole model
   */
  interface userroleFieldRefs {
    readonly user_id: FieldRef<"userrole", 'Int'>
    readonly role_id: FieldRef<"userrole", 'Int'>
    readonly created_at: FieldRef<"userrole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userrole findUnique
   */
  export type userroleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findUniqueOrThrow
   */
  export type userroleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findFirst
   */
  export type userroleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findFirstOrThrow
   */
  export type userroleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findMany
   */
  export type userroleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userroles to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole create
   */
  export type userroleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to create a userrole.
     */
    data: XOR<userroleCreateInput, userroleUncheckedCreateInput>
  }

  /**
   * userrole createMany
   */
  export type userroleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userroles.
     */
    data: userroleCreateManyInput | userroleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userrole createManyAndReturn
   */
  export type userroleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * The data used to create many userroles.
     */
    data: userroleCreateManyInput | userroleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userrole update
   */
  export type userroleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to update a userrole.
     */
    data: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
    /**
     * Choose, which userrole to update.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole updateMany
   */
  export type userroleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userroles.
     */
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyInput>
    /**
     * Filter which userroles to update
     */
    where?: userroleWhereInput
    /**
     * Limit how many userroles to update.
     */
    limit?: number
  }

  /**
   * userrole updateManyAndReturn
   */
  export type userroleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * The data used to update userroles.
     */
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyInput>
    /**
     * Filter which userroles to update
     */
    where?: userroleWhereInput
    /**
     * Limit how many userroles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userrole upsert
   */
  export type userroleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The filter to search for the userrole to update in case it exists.
     */
    where: userroleWhereUniqueInput
    /**
     * In case the userrole found by the `where` argument doesn't exist, create a new userrole with this data.
     */
    create: XOR<userroleCreateInput, userroleUncheckedCreateInput>
    /**
     * In case the userrole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
  }

  /**
   * userrole delete
   */
  export type userroleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter which userrole to delete.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole deleteMany
   */
  export type userroleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userroles to delete
     */
    where?: userroleWhereInput
    /**
     * Limit how many userroles to delete.
     */
    limit?: number
  }

  /**
   * userrole without action
   */
  export type userroleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    user_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    user_id: number | null
  }

  export type UsersMinAggregateOutputType = {
    user_id: number | null
    username: string | null
    email: string | null
    password: string | null
    is_verified: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    user_id: number | null
    username: string | null
    email: string | null
    password: string | null
    is_verified: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    user_id: number
    username: number
    email: number
    password: number
    is_verified: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    user_id?: true
  }

  export type UsersSumAggregateInputType = {
    user_id?: true
  }

  export type UsersMinAggregateInputType = {
    user_id?: true
    username?: true
    email?: true
    password?: true
    is_verified?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    user_id?: true
    username?: true
    email?: true
    password?: true
    is_verified?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    user_id?: true
    username?: true
    email?: true
    password?: true
    is_verified?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    user_id: number
    username: string
    email: string
    password: string
    is_verified: boolean | null
    created_at: Date | null
    updated_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    is_verified?: boolean
    created_at?: boolean
    updated_at?: boolean
    auditlog?: boolean | users$auditlogArgs<ExtArgs>
    review?: boolean | users$reviewArgs<ExtArgs>
    sessions?: boolean | users$sessionsArgs<ExtArgs>
    userbadge?: boolean | users$userbadgeArgs<ExtArgs>
    usercheckpointattempt?: boolean | users$usercheckpointattemptArgs<ExtArgs>
    userprofile?: boolean | users$userprofileArgs<ExtArgs>
    userquizcompletion?: boolean | users$userquizcompletionArgs<ExtArgs>
    userrole?: boolean | users$userroleArgs<ExtArgs>
    usertourcompletion?: boolean | users$usertourcompletionArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    is_verified?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    is_verified?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    user_id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    is_verified?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "username" | "email" | "password" | "is_verified" | "created_at" | "updated_at", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auditlog?: boolean | users$auditlogArgs<ExtArgs>
    review?: boolean | users$reviewArgs<ExtArgs>
    sessions?: boolean | users$sessionsArgs<ExtArgs>
    userbadge?: boolean | users$userbadgeArgs<ExtArgs>
    usercheckpointattempt?: boolean | users$usercheckpointattemptArgs<ExtArgs>
    userprofile?: boolean | users$userprofileArgs<ExtArgs>
    userquizcompletion?: boolean | users$userquizcompletionArgs<ExtArgs>
    userrole?: boolean | users$userroleArgs<ExtArgs>
    usertourcompletion?: boolean | users$usertourcompletionArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      auditlog: Prisma.$auditlogPayload<ExtArgs>[]
      review: Prisma.$reviewPayload<ExtArgs>[]
      sessions: Prisma.$sessionsPayload<ExtArgs>[]
      userbadge: Prisma.$userbadgePayload<ExtArgs>[]
      usercheckpointattempt: Prisma.$usercheckpointattemptPayload<ExtArgs>[]
      userprofile: Prisma.$userprofilePayload<ExtArgs> | null
      userquizcompletion: Prisma.$userquizcompletionPayload<ExtArgs>[]
      userrole: Prisma.$userrolePayload<ExtArgs> | null
      usertourcompletion: Prisma.$usertourcompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      username: string
      email: string
      password: string
      is_verified: boolean | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const usersWithUser_idOnly = await prisma.users.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `user_id`
     * const usersWithUser_idOnly = await prisma.users.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `user_id`
     * const usersWithUser_idOnly = await prisma.users.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auditlog<T extends users$auditlogArgs<ExtArgs> = {}>(args?: Subset<T, users$auditlogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$auditlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    review<T extends users$reviewArgs<ExtArgs> = {}>(args?: Subset<T, users$reviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends users$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, users$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userbadge<T extends users$userbadgeArgs<ExtArgs> = {}>(args?: Subset<T, users$userbadgeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userbadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usercheckpointattempt<T extends users$usercheckpointattemptArgs<ExtArgs> = {}>(args?: Subset<T, users$usercheckpointattemptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userprofile<T extends users$userprofileArgs<ExtArgs> = {}>(args?: Subset<T, users$userprofileArgs<ExtArgs>>): Prisma__userprofileClient<$Result.GetResult<Prisma.$userprofilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    userquizcompletion<T extends users$userquizcompletionArgs<ExtArgs> = {}>(args?: Subset<T, users$userquizcompletionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userquizcompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userrole<T extends users$userroleArgs<ExtArgs> = {}>(args?: Subset<T, users$userroleArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usertourcompletion<T extends users$usertourcompletionArgs<ExtArgs> = {}>(args?: Subset<T, users$usertourcompletionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly user_id: FieldRef<"users", 'Int'>
    readonly username: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly is_verified: FieldRef<"users", 'Boolean'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.auditlog
   */
  export type users$auditlogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the auditlog
     */
    select?: auditlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the auditlog
     */
    omit?: auditlogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditlogInclude<ExtArgs> | null
    where?: auditlogWhereInput
    orderBy?: auditlogOrderByWithRelationInput | auditlogOrderByWithRelationInput[]
    cursor?: auditlogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditlogScalarFieldEnum | AuditlogScalarFieldEnum[]
  }

  /**
   * users.review
   */
  export type users$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the review
     */
    select?: reviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the review
     */
    omit?: reviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewInclude<ExtArgs> | null
    where?: reviewWhereInput
    orderBy?: reviewOrderByWithRelationInput | reviewOrderByWithRelationInput[]
    cursor?: reviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * users.sessions
   */
  export type users$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    cursor?: sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * users.userbadge
   */
  export type users$userbadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userbadge
     */
    select?: userbadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userbadge
     */
    omit?: userbadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userbadgeInclude<ExtArgs> | null
    where?: userbadgeWhereInput
    orderBy?: userbadgeOrderByWithRelationInput | userbadgeOrderByWithRelationInput[]
    cursor?: userbadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserbadgeScalarFieldEnum | UserbadgeScalarFieldEnum[]
  }

  /**
   * users.usercheckpointattempt
   */
  export type users$usercheckpointattemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptInclude<ExtArgs> | null
    where?: usercheckpointattemptWhereInput
    orderBy?: usercheckpointattemptOrderByWithRelationInput | usercheckpointattemptOrderByWithRelationInput[]
    cursor?: usercheckpointattemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsercheckpointattemptScalarFieldEnum | UsercheckpointattemptScalarFieldEnum[]
  }

  /**
   * users.userprofile
   */
  export type users$userprofileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userprofile
     */
    select?: userprofileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userprofile
     */
    omit?: userprofileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userprofileInclude<ExtArgs> | null
    where?: userprofileWhereInput
  }

  /**
   * users.userquizcompletion
   */
  export type users$userquizcompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userquizcompletion
     */
    select?: userquizcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userquizcompletion
     */
    omit?: userquizcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userquizcompletionInclude<ExtArgs> | null
    where?: userquizcompletionWhereInput
    orderBy?: userquizcompletionOrderByWithRelationInput | userquizcompletionOrderByWithRelationInput[]
    cursor?: userquizcompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserquizcompletionScalarFieldEnum | UserquizcompletionScalarFieldEnum[]
  }

  /**
   * users.userrole
   */
  export type users$userroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
  }

  /**
   * users.usertourcompletion
   */
  export type users$usertourcompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionInclude<ExtArgs> | null
    where?: usertourcompletionWhereInput
    orderBy?: usertourcompletionOrderByWithRelationInput | usertourcompletionOrderByWithRelationInput[]
    cursor?: usertourcompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsertourcompletionScalarFieldEnum | UsertourcompletionScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model usertourcompletion
   */

  export type AggregateUsertourcompletion = {
    _count: UsertourcompletionCountAggregateOutputType | null
    _avg: UsertourcompletionAvgAggregateOutputType | null
    _sum: UsertourcompletionSumAggregateOutputType | null
    _min: UsertourcompletionMinAggregateOutputType | null
    _max: UsertourcompletionMaxAggregateOutputType | null
  }

  export type UsertourcompletionAvgAggregateOutputType = {
    tourcompletion_id: number | null
    user_id: number | null
    tour_id: number | null
  }

  export type UsertourcompletionSumAggregateOutputType = {
    tourcompletion_id: number | null
    user_id: number | null
    tour_id: number | null
  }

  export type UsertourcompletionMinAggregateOutputType = {
    tourcompletion_id: number | null
    user_id: number | null
    tour_id: number | null
    completed: boolean | null
    completed_at: Date | null
    created_at: Date | null
  }

  export type UsertourcompletionMaxAggregateOutputType = {
    tourcompletion_id: number | null
    user_id: number | null
    tour_id: number | null
    completed: boolean | null
    completed_at: Date | null
    created_at: Date | null
  }

  export type UsertourcompletionCountAggregateOutputType = {
    tourcompletion_id: number
    user_id: number
    tour_id: number
    completed: number
    completed_at: number
    created_at: number
    _all: number
  }


  export type UsertourcompletionAvgAggregateInputType = {
    tourcompletion_id?: true
    user_id?: true
    tour_id?: true
  }

  export type UsertourcompletionSumAggregateInputType = {
    tourcompletion_id?: true
    user_id?: true
    tour_id?: true
  }

  export type UsertourcompletionMinAggregateInputType = {
    tourcompletion_id?: true
    user_id?: true
    tour_id?: true
    completed?: true
    completed_at?: true
    created_at?: true
  }

  export type UsertourcompletionMaxAggregateInputType = {
    tourcompletion_id?: true
    user_id?: true
    tour_id?: true
    completed?: true
    completed_at?: true
    created_at?: true
  }

  export type UsertourcompletionCountAggregateInputType = {
    tourcompletion_id?: true
    user_id?: true
    tour_id?: true
    completed?: true
    completed_at?: true
    created_at?: true
    _all?: true
  }

  export type UsertourcompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usertourcompletion to aggregate.
     */
    where?: usertourcompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usertourcompletions to fetch.
     */
    orderBy?: usertourcompletionOrderByWithRelationInput | usertourcompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usertourcompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usertourcompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usertourcompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usertourcompletions
    **/
    _count?: true | UsertourcompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsertourcompletionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsertourcompletionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsertourcompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsertourcompletionMaxAggregateInputType
  }

  export type GetUsertourcompletionAggregateType<T extends UsertourcompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateUsertourcompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsertourcompletion[P]>
      : GetScalarType<T[P], AggregateUsertourcompletion[P]>
  }




  export type usertourcompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usertourcompletionWhereInput
    orderBy?: usertourcompletionOrderByWithAggregationInput | usertourcompletionOrderByWithAggregationInput[]
    by: UsertourcompletionScalarFieldEnum[] | UsertourcompletionScalarFieldEnum
    having?: usertourcompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsertourcompletionCountAggregateInputType | true
    _avg?: UsertourcompletionAvgAggregateInputType
    _sum?: UsertourcompletionSumAggregateInputType
    _min?: UsertourcompletionMinAggregateInputType
    _max?: UsertourcompletionMaxAggregateInputType
  }

  export type UsertourcompletionGroupByOutputType = {
    tourcompletion_id: number
    user_id: number
    tour_id: number | null
    completed: boolean | null
    completed_at: Date | null
    created_at: Date | null
    _count: UsertourcompletionCountAggregateOutputType | null
    _avg: UsertourcompletionAvgAggregateOutputType | null
    _sum: UsertourcompletionSumAggregateOutputType | null
    _min: UsertourcompletionMinAggregateOutputType | null
    _max: UsertourcompletionMaxAggregateOutputType | null
  }

  type GetUsertourcompletionGroupByPayload<T extends usertourcompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsertourcompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsertourcompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsertourcompletionGroupByOutputType[P]>
            : GetScalarType<T[P], UsertourcompletionGroupByOutputType[P]>
        }
      >
    >


  export type usertourcompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tourcompletion_id?: boolean
    user_id?: boolean
    tour_id?: boolean
    completed?: boolean
    completed_at?: boolean
    created_at?: boolean
    usercheckpointattempt?: boolean | usertourcompletion$usercheckpointattemptArgs<ExtArgs>
    tour?: boolean | usertourcompletion$tourArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | UsertourcompletionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usertourcompletion"]>

  export type usertourcompletionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tourcompletion_id?: boolean
    user_id?: boolean
    tour_id?: boolean
    completed?: boolean
    completed_at?: boolean
    created_at?: boolean
    tour?: boolean | usertourcompletion$tourArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usertourcompletion"]>

  export type usertourcompletionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tourcompletion_id?: boolean
    user_id?: boolean
    tour_id?: boolean
    completed?: boolean
    completed_at?: boolean
    created_at?: boolean
    tour?: boolean | usertourcompletion$tourArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usertourcompletion"]>

  export type usertourcompletionSelectScalar = {
    tourcompletion_id?: boolean
    user_id?: boolean
    tour_id?: boolean
    completed?: boolean
    completed_at?: boolean
    created_at?: boolean
  }

  export type usertourcompletionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tourcompletion_id" | "user_id" | "tour_id" | "completed" | "completed_at" | "created_at", ExtArgs["result"]["usertourcompletion"]>
  export type usertourcompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usercheckpointattempt?: boolean | usertourcompletion$usercheckpointattemptArgs<ExtArgs>
    tour?: boolean | usertourcompletion$tourArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | UsertourcompletionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usertourcompletionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | usertourcompletion$tourArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type usertourcompletionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tour?: boolean | usertourcompletion$tourArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $usertourcompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usertourcompletion"
    objects: {
      usercheckpointattempt: Prisma.$usercheckpointattemptPayload<ExtArgs>[]
      tour: Prisma.$tourPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tourcompletion_id: number
      user_id: number
      tour_id: number | null
      completed: boolean | null
      completed_at: Date | null
      created_at: Date | null
    }, ExtArgs["result"]["usertourcompletion"]>
    composites: {}
  }

  type usertourcompletionGetPayload<S extends boolean | null | undefined | usertourcompletionDefaultArgs> = $Result.GetResult<Prisma.$usertourcompletionPayload, S>

  type usertourcompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usertourcompletionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsertourcompletionCountAggregateInputType | true
    }

  export interface usertourcompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usertourcompletion'], meta: { name: 'usertourcompletion' } }
    /**
     * Find zero or one Usertourcompletion that matches the filter.
     * @param {usertourcompletionFindUniqueArgs} args - Arguments to find a Usertourcompletion
     * @example
     * // Get one Usertourcompletion
     * const usertourcompletion = await prisma.usertourcompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usertourcompletionFindUniqueArgs>(args: SelectSubset<T, usertourcompletionFindUniqueArgs<ExtArgs>>): Prisma__usertourcompletionClient<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usertourcompletion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usertourcompletionFindUniqueOrThrowArgs} args - Arguments to find a Usertourcompletion
     * @example
     * // Get one Usertourcompletion
     * const usertourcompletion = await prisma.usertourcompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usertourcompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, usertourcompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usertourcompletionClient<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usertourcompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usertourcompletionFindFirstArgs} args - Arguments to find a Usertourcompletion
     * @example
     * // Get one Usertourcompletion
     * const usertourcompletion = await prisma.usertourcompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usertourcompletionFindFirstArgs>(args?: SelectSubset<T, usertourcompletionFindFirstArgs<ExtArgs>>): Prisma__usertourcompletionClient<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usertourcompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usertourcompletionFindFirstOrThrowArgs} args - Arguments to find a Usertourcompletion
     * @example
     * // Get one Usertourcompletion
     * const usertourcompletion = await prisma.usertourcompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usertourcompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, usertourcompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__usertourcompletionClient<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usertourcompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usertourcompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usertourcompletions
     * const usertourcompletions = await prisma.usertourcompletion.findMany()
     * 
     * // Get first 10 Usertourcompletions
     * const usertourcompletions = await prisma.usertourcompletion.findMany({ take: 10 })
     * 
     * // Only select the `tourcompletion_id`
     * const usertourcompletionWithTourcompletion_idOnly = await prisma.usertourcompletion.findMany({ select: { tourcompletion_id: true } })
     * 
     */
    findMany<T extends usertourcompletionFindManyArgs>(args?: SelectSubset<T, usertourcompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usertourcompletion.
     * @param {usertourcompletionCreateArgs} args - Arguments to create a Usertourcompletion.
     * @example
     * // Create one Usertourcompletion
     * const Usertourcompletion = await prisma.usertourcompletion.create({
     *   data: {
     *     // ... data to create a Usertourcompletion
     *   }
     * })
     * 
     */
    create<T extends usertourcompletionCreateArgs>(args: SelectSubset<T, usertourcompletionCreateArgs<ExtArgs>>): Prisma__usertourcompletionClient<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usertourcompletions.
     * @param {usertourcompletionCreateManyArgs} args - Arguments to create many Usertourcompletions.
     * @example
     * // Create many Usertourcompletions
     * const usertourcompletion = await prisma.usertourcompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usertourcompletionCreateManyArgs>(args?: SelectSubset<T, usertourcompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usertourcompletions and returns the data saved in the database.
     * @param {usertourcompletionCreateManyAndReturnArgs} args - Arguments to create many Usertourcompletions.
     * @example
     * // Create many Usertourcompletions
     * const usertourcompletion = await prisma.usertourcompletion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usertourcompletions and only return the `tourcompletion_id`
     * const usertourcompletionWithTourcompletion_idOnly = await prisma.usertourcompletion.createManyAndReturn({
     *   select: { tourcompletion_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usertourcompletionCreateManyAndReturnArgs>(args?: SelectSubset<T, usertourcompletionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usertourcompletion.
     * @param {usertourcompletionDeleteArgs} args - Arguments to delete one Usertourcompletion.
     * @example
     * // Delete one Usertourcompletion
     * const Usertourcompletion = await prisma.usertourcompletion.delete({
     *   where: {
     *     // ... filter to delete one Usertourcompletion
     *   }
     * })
     * 
     */
    delete<T extends usertourcompletionDeleteArgs>(args: SelectSubset<T, usertourcompletionDeleteArgs<ExtArgs>>): Prisma__usertourcompletionClient<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usertourcompletion.
     * @param {usertourcompletionUpdateArgs} args - Arguments to update one Usertourcompletion.
     * @example
     * // Update one Usertourcompletion
     * const usertourcompletion = await prisma.usertourcompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usertourcompletionUpdateArgs>(args: SelectSubset<T, usertourcompletionUpdateArgs<ExtArgs>>): Prisma__usertourcompletionClient<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usertourcompletions.
     * @param {usertourcompletionDeleteManyArgs} args - Arguments to filter Usertourcompletions to delete.
     * @example
     * // Delete a few Usertourcompletions
     * const { count } = await prisma.usertourcompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usertourcompletionDeleteManyArgs>(args?: SelectSubset<T, usertourcompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usertourcompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usertourcompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usertourcompletions
     * const usertourcompletion = await prisma.usertourcompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usertourcompletionUpdateManyArgs>(args: SelectSubset<T, usertourcompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usertourcompletions and returns the data updated in the database.
     * @param {usertourcompletionUpdateManyAndReturnArgs} args - Arguments to update many Usertourcompletions.
     * @example
     * // Update many Usertourcompletions
     * const usertourcompletion = await prisma.usertourcompletion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usertourcompletions and only return the `tourcompletion_id`
     * const usertourcompletionWithTourcompletion_idOnly = await prisma.usertourcompletion.updateManyAndReturn({
     *   select: { tourcompletion_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usertourcompletionUpdateManyAndReturnArgs>(args: SelectSubset<T, usertourcompletionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usertourcompletion.
     * @param {usertourcompletionUpsertArgs} args - Arguments to update or create a Usertourcompletion.
     * @example
     * // Update or create a Usertourcompletion
     * const usertourcompletion = await prisma.usertourcompletion.upsert({
     *   create: {
     *     // ... data to create a Usertourcompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usertourcompletion we want to update
     *   }
     * })
     */
    upsert<T extends usertourcompletionUpsertArgs>(args: SelectSubset<T, usertourcompletionUpsertArgs<ExtArgs>>): Prisma__usertourcompletionClient<$Result.GetResult<Prisma.$usertourcompletionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usertourcompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usertourcompletionCountArgs} args - Arguments to filter Usertourcompletions to count.
     * @example
     * // Count the number of Usertourcompletions
     * const count = await prisma.usertourcompletion.count({
     *   where: {
     *     // ... the filter for the Usertourcompletions we want to count
     *   }
     * })
    **/
    count<T extends usertourcompletionCountArgs>(
      args?: Subset<T, usertourcompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsertourcompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usertourcompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsertourcompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsertourcompletionAggregateArgs>(args: Subset<T, UsertourcompletionAggregateArgs>): Prisma.PrismaPromise<GetUsertourcompletionAggregateType<T>>

    /**
     * Group by Usertourcompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usertourcompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usertourcompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usertourcompletionGroupByArgs['orderBy'] }
        : { orderBy?: usertourcompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usertourcompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsertourcompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usertourcompletion model
   */
  readonly fields: usertourcompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usertourcompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usertourcompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usercheckpointattempt<T extends usertourcompletion$usercheckpointattemptArgs<ExtArgs> = {}>(args?: Subset<T, usertourcompletion$usercheckpointattemptArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usercheckpointattemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tour<T extends usertourcompletion$tourArgs<ExtArgs> = {}>(args?: Subset<T, usertourcompletion$tourArgs<ExtArgs>>): Prisma__tourClient<$Result.GetResult<Prisma.$tourPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usertourcompletion model
   */
  interface usertourcompletionFieldRefs {
    readonly tourcompletion_id: FieldRef<"usertourcompletion", 'Int'>
    readonly user_id: FieldRef<"usertourcompletion", 'Int'>
    readonly tour_id: FieldRef<"usertourcompletion", 'Int'>
    readonly completed: FieldRef<"usertourcompletion", 'Boolean'>
    readonly completed_at: FieldRef<"usertourcompletion", 'DateTime'>
    readonly created_at: FieldRef<"usertourcompletion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * usertourcompletion findUnique
   */
  export type usertourcompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionInclude<ExtArgs> | null
    /**
     * Filter, which usertourcompletion to fetch.
     */
    where: usertourcompletionWhereUniqueInput
  }

  /**
   * usertourcompletion findUniqueOrThrow
   */
  export type usertourcompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionInclude<ExtArgs> | null
    /**
     * Filter, which usertourcompletion to fetch.
     */
    where: usertourcompletionWhereUniqueInput
  }

  /**
   * usertourcompletion findFirst
   */
  export type usertourcompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionInclude<ExtArgs> | null
    /**
     * Filter, which usertourcompletion to fetch.
     */
    where?: usertourcompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usertourcompletions to fetch.
     */
    orderBy?: usertourcompletionOrderByWithRelationInput | usertourcompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usertourcompletions.
     */
    cursor?: usertourcompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usertourcompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usertourcompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usertourcompletions.
     */
    distinct?: UsertourcompletionScalarFieldEnum | UsertourcompletionScalarFieldEnum[]
  }

  /**
   * usertourcompletion findFirstOrThrow
   */
  export type usertourcompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionInclude<ExtArgs> | null
    /**
     * Filter, which usertourcompletion to fetch.
     */
    where?: usertourcompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usertourcompletions to fetch.
     */
    orderBy?: usertourcompletionOrderByWithRelationInput | usertourcompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usertourcompletions.
     */
    cursor?: usertourcompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usertourcompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usertourcompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usertourcompletions.
     */
    distinct?: UsertourcompletionScalarFieldEnum | UsertourcompletionScalarFieldEnum[]
  }

  /**
   * usertourcompletion findMany
   */
  export type usertourcompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionInclude<ExtArgs> | null
    /**
     * Filter, which usertourcompletions to fetch.
     */
    where?: usertourcompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usertourcompletions to fetch.
     */
    orderBy?: usertourcompletionOrderByWithRelationInput | usertourcompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usertourcompletions.
     */
    cursor?: usertourcompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usertourcompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usertourcompletions.
     */
    skip?: number
    distinct?: UsertourcompletionScalarFieldEnum | UsertourcompletionScalarFieldEnum[]
  }

  /**
   * usertourcompletion create
   */
  export type usertourcompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a usertourcompletion.
     */
    data: XOR<usertourcompletionCreateInput, usertourcompletionUncheckedCreateInput>
  }

  /**
   * usertourcompletion createMany
   */
  export type usertourcompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usertourcompletions.
     */
    data: usertourcompletionCreateManyInput | usertourcompletionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usertourcompletion createManyAndReturn
   */
  export type usertourcompletionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * The data used to create many usertourcompletions.
     */
    data: usertourcompletionCreateManyInput | usertourcompletionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * usertourcompletion update
   */
  export type usertourcompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a usertourcompletion.
     */
    data: XOR<usertourcompletionUpdateInput, usertourcompletionUncheckedUpdateInput>
    /**
     * Choose, which usertourcompletion to update.
     */
    where: usertourcompletionWhereUniqueInput
  }

  /**
   * usertourcompletion updateMany
   */
  export type usertourcompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usertourcompletions.
     */
    data: XOR<usertourcompletionUpdateManyMutationInput, usertourcompletionUncheckedUpdateManyInput>
    /**
     * Filter which usertourcompletions to update
     */
    where?: usertourcompletionWhereInput
    /**
     * Limit how many usertourcompletions to update.
     */
    limit?: number
  }

  /**
   * usertourcompletion updateManyAndReturn
   */
  export type usertourcompletionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * The data used to update usertourcompletions.
     */
    data: XOR<usertourcompletionUpdateManyMutationInput, usertourcompletionUncheckedUpdateManyInput>
    /**
     * Filter which usertourcompletions to update
     */
    where?: usertourcompletionWhereInput
    /**
     * Limit how many usertourcompletions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * usertourcompletion upsert
   */
  export type usertourcompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the usertourcompletion to update in case it exists.
     */
    where: usertourcompletionWhereUniqueInput
    /**
     * In case the usertourcompletion found by the `where` argument doesn't exist, create a new usertourcompletion with this data.
     */
    create: XOR<usertourcompletionCreateInput, usertourcompletionUncheckedCreateInput>
    /**
     * In case the usertourcompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usertourcompletionUpdateInput, usertourcompletionUncheckedUpdateInput>
  }

  /**
   * usertourcompletion delete
   */
  export type usertourcompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionInclude<ExtArgs> | null
    /**
     * Filter which usertourcompletion to delete.
     */
    where: usertourcompletionWhereUniqueInput
  }

  /**
   * usertourcompletion deleteMany
   */
  export type usertourcompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usertourcompletions to delete
     */
    where?: usertourcompletionWhereInput
    /**
     * Limit how many usertourcompletions to delete.
     */
    limit?: number
  }

  /**
   * usertourcompletion.usercheckpointattempt
   */
  export type usertourcompletion$usercheckpointattemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usercheckpointattempt
     */
    select?: usercheckpointattemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usercheckpointattempt
     */
    omit?: usercheckpointattemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usercheckpointattemptInclude<ExtArgs> | null
    where?: usercheckpointattemptWhereInput
    orderBy?: usercheckpointattemptOrderByWithRelationInput | usercheckpointattemptOrderByWithRelationInput[]
    cursor?: usercheckpointattemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsercheckpointattemptScalarFieldEnum | UsercheckpointattemptScalarFieldEnum[]
  }

  /**
   * usertourcompletion.tour
   */
  export type usertourcompletion$tourArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tour
     */
    select?: tourSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tour
     */
    omit?: tourOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tourInclude<ExtArgs> | null
    where?: tourWhereInput
  }

  /**
   * usertourcompletion without action
   */
  export type usertourcompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usertourcompletion
     */
    select?: usertourcompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the usertourcompletion
     */
    omit?: usertourcompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usertourcompletionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AuditactionScalarFieldEnum: {
    action_id: 'action_id',
    description: 'description'
  };

  export type AuditactionScalarFieldEnum = (typeof AuditactionScalarFieldEnum)[keyof typeof AuditactionScalarFieldEnum]


  export const AuditlogScalarFieldEnum: {
    log_id: 'log_id',
    user_id: 'user_id',
    session_id: 'session_id',
    action_id: 'action_id',
    target_id: 'target_id',
    target_entity: 'target_entity',
    timestamp: 'timestamp'
  };

  export type AuditlogScalarFieldEnum = (typeof AuditlogScalarFieldEnum)[keyof typeof AuditlogScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    badge_id: 'badge_id',
    tour_id: 'tour_id',
    badge_title: 'badge_title',
    description: 'description',
    image_url: 'image_url'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const CheckpointScalarFieldEnum: {
    checkpoint_id: 'checkpoint_id',
    quiz_id: 'quiz_id',
    location_id: 'location_id',
    points_reward: 'points_reward',
    created_at: 'created_at'
  };

  export type CheckpointScalarFieldEnum = (typeof CheckpointScalarFieldEnum)[keyof typeof CheckpointScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    location_id: 'location_id',
    location_name: 'location_name',
    locationtype_id: 'locationtype_id',
    description: 'description',
    created_at: 'created_at'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const LocationtypeScalarFieldEnum: {
    locationtype_id: 'locationtype_id',
    description: 'description'
  };

  export type LocationtypeScalarFieldEnum = (typeof LocationtypeScalarFieldEnum)[keyof typeof LocationtypeScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    permission_id: 'permission_id',
    permission_name: 'permission_name',
    description: 'description'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    question_id: 'question_id',
    question: 'question',
    quiz_id: 'quiz_id'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const QuestionoptionScalarFieldEnum: {
    option_id: 'option_id',
    option: 'option',
    is_correct: 'is_correct',
    question_id: 'question_id'
  };

  export type QuestionoptionScalarFieldEnum = (typeof QuestionoptionScalarFieldEnum)[keyof typeof QuestionoptionScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    quiz_id: 'quiz_id',
    quiz_title: 'quiz_title',
    description: 'description'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    review_id: 'review_id',
    user_id: 'user_id',
    tour_id: 'tour_id',
    review_text: 'review_text',
    rating: 'rating',
    created_at: 'created_at'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    role_id: 'role_id',
    role_name: 'role_name',
    description: 'description'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const RolepermissionScalarFieldEnum: {
    role_id: 'role_id',
    permission_id: 'permission_id',
    created_at: 'created_at'
  };

  export type RolepermissionScalarFieldEnum = (typeof RolepermissionScalarFieldEnum)[keyof typeof RolepermissionScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    session_id: 'session_id',
    user_id: 'user_id',
    access_token: 'access_token',
    is_active: 'is_active',
    login_at: 'login_at',
    logout_at: 'logout_at'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const TourScalarFieldEnum: {
    tour_id: 'tour_id',
    tour_name: 'tour_name',
    description: 'description',
    created_at: 'created_at'
  };

  export type TourScalarFieldEnum = (typeof TourScalarFieldEnum)[keyof typeof TourScalarFieldEnum]


  export const TourcheckpointScalarFieldEnum: {
    tour_id: 'tour_id',
    checkpoint_id: 'checkpoint_id',
    checkpoint_order: 'checkpoint_order'
  };

  export type TourcheckpointScalarFieldEnum = (typeof TourcheckpointScalarFieldEnum)[keyof typeof TourcheckpointScalarFieldEnum]


  export const UserbadgeScalarFieldEnum: {
    badge_id: 'badge_id',
    user_id: 'user_id',
    created_at: 'created_at'
  };

  export type UserbadgeScalarFieldEnum = (typeof UserbadgeScalarFieldEnum)[keyof typeof UserbadgeScalarFieldEnum]


  export const UsercheckpointattemptScalarFieldEnum: {
    checkpointattempt_id: 'checkpointattempt_id',
    user_id: 'user_id',
    checkpoint_id: 'checkpoint_id',
    tourcompletion_id: 'tourcompletion_id',
    created_at: 'created_at'
  };

  export type UsercheckpointattemptScalarFieldEnum = (typeof UsercheckpointattemptScalarFieldEnum)[keyof typeof UsercheckpointattemptScalarFieldEnum]


  export const UserprofileScalarFieldEnum: {
    profile_id: 'profile_id',
    user_id: 'user_id',
    points: 'points',
    level: 'level',
    first_name: 'first_name',
    last_name: 'last_name',
    school: 'school',
    sec_level: 'sec_level',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserprofileScalarFieldEnum = (typeof UserprofileScalarFieldEnum)[keyof typeof UserprofileScalarFieldEnum]


  export const UserquizcompletionScalarFieldEnum: {
    quizcompletion_id: 'quizcompletion_id',
    quiz_id: 'quiz_id',
    user_id: 'user_id',
    score: 'score',
    created_at: 'created_at'
  };

  export type UserquizcompletionScalarFieldEnum = (typeof UserquizcompletionScalarFieldEnum)[keyof typeof UserquizcompletionScalarFieldEnum]


  export const UserroleScalarFieldEnum: {
    user_id: 'user_id',
    role_id: 'role_id',
    created_at: 'created_at'
  };

  export type UserroleScalarFieldEnum = (typeof UserroleScalarFieldEnum)[keyof typeof UserroleScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    user_id: 'user_id',
    username: 'username',
    email: 'email',
    password: 'password',
    is_verified: 'is_verified',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const UsertourcompletionScalarFieldEnum: {
    tourcompletion_id: 'tourcompletion_id',
    user_id: 'user_id',
    tour_id: 'tour_id',
    completed: 'completed',
    completed_at: 'completed_at',
    created_at: 'created_at'
  };

  export type UsertourcompletionScalarFieldEnum = (typeof UsertourcompletionScalarFieldEnum)[keyof typeof UsertourcompletionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'sec_level'
   */
  export type Enumsec_levelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'sec_level'>
    


  /**
   * Reference to a field of type 'sec_level[]'
   */
  export type ListEnumsec_levelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'sec_level[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type auditactionWhereInput = {
    AND?: auditactionWhereInput | auditactionWhereInput[]
    OR?: auditactionWhereInput[]
    NOT?: auditactionWhereInput | auditactionWhereInput[]
    action_id?: StringFilter<"auditaction"> | string
    description?: StringNullableFilter<"auditaction"> | string | null
    auditlog?: AuditlogListRelationFilter
  }

  export type auditactionOrderByWithRelationInput = {
    action_id?: SortOrder
    description?: SortOrderInput | SortOrder
    auditlog?: auditlogOrderByRelationAggregateInput
  }

  export type auditactionWhereUniqueInput = Prisma.AtLeast<{
    action_id?: string
    AND?: auditactionWhereInput | auditactionWhereInput[]
    OR?: auditactionWhereInput[]
    NOT?: auditactionWhereInput | auditactionWhereInput[]
    description?: StringNullableFilter<"auditaction"> | string | null
    auditlog?: AuditlogListRelationFilter
  }, "action_id">

  export type auditactionOrderByWithAggregationInput = {
    action_id?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: auditactionCountOrderByAggregateInput
    _max?: auditactionMaxOrderByAggregateInput
    _min?: auditactionMinOrderByAggregateInput
  }

  export type auditactionScalarWhereWithAggregatesInput = {
    AND?: auditactionScalarWhereWithAggregatesInput | auditactionScalarWhereWithAggregatesInput[]
    OR?: auditactionScalarWhereWithAggregatesInput[]
    NOT?: auditactionScalarWhereWithAggregatesInput | auditactionScalarWhereWithAggregatesInput[]
    action_id?: StringWithAggregatesFilter<"auditaction"> | string
    description?: StringNullableWithAggregatesFilter<"auditaction"> | string | null
  }

  export type auditlogWhereInput = {
    AND?: auditlogWhereInput | auditlogWhereInput[]
    OR?: auditlogWhereInput[]
    NOT?: auditlogWhereInput | auditlogWhereInput[]
    log_id?: IntFilter<"auditlog"> | number
    user_id?: IntNullableFilter<"auditlog"> | number | null
    session_id?: IntNullableFilter<"auditlog"> | number | null
    action_id?: StringNullableFilter<"auditlog"> | string | null
    target_id?: IntFilter<"auditlog"> | number
    target_entity?: StringNullableFilter<"auditlog"> | string | null
    timestamp?: DateTimeNullableFilter<"auditlog"> | Date | string | null
    auditaction?: XOR<AuditactionNullableScalarRelationFilter, auditactionWhereInput> | null
    sessions?: XOR<SessionsNullableScalarRelationFilter, sessionsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type auditlogOrderByWithRelationInput = {
    log_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    action_id?: SortOrderInput | SortOrder
    target_id?: SortOrder
    target_entity?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    auditaction?: auditactionOrderByWithRelationInput
    sessions?: sessionsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type auditlogWhereUniqueInput = Prisma.AtLeast<{
    log_id?: number
    AND?: auditlogWhereInput | auditlogWhereInput[]
    OR?: auditlogWhereInput[]
    NOT?: auditlogWhereInput | auditlogWhereInput[]
    user_id?: IntNullableFilter<"auditlog"> | number | null
    session_id?: IntNullableFilter<"auditlog"> | number | null
    action_id?: StringNullableFilter<"auditlog"> | string | null
    target_id?: IntFilter<"auditlog"> | number
    target_entity?: StringNullableFilter<"auditlog"> | string | null
    timestamp?: DateTimeNullableFilter<"auditlog"> | Date | string | null
    auditaction?: XOR<AuditactionNullableScalarRelationFilter, auditactionWhereInput> | null
    sessions?: XOR<SessionsNullableScalarRelationFilter, sessionsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "log_id">

  export type auditlogOrderByWithAggregationInput = {
    log_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    action_id?: SortOrderInput | SortOrder
    target_id?: SortOrder
    target_entity?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    _count?: auditlogCountOrderByAggregateInput
    _avg?: auditlogAvgOrderByAggregateInput
    _max?: auditlogMaxOrderByAggregateInput
    _min?: auditlogMinOrderByAggregateInput
    _sum?: auditlogSumOrderByAggregateInput
  }

  export type auditlogScalarWhereWithAggregatesInput = {
    AND?: auditlogScalarWhereWithAggregatesInput | auditlogScalarWhereWithAggregatesInput[]
    OR?: auditlogScalarWhereWithAggregatesInput[]
    NOT?: auditlogScalarWhereWithAggregatesInput | auditlogScalarWhereWithAggregatesInput[]
    log_id?: IntWithAggregatesFilter<"auditlog"> | number
    user_id?: IntNullableWithAggregatesFilter<"auditlog"> | number | null
    session_id?: IntNullableWithAggregatesFilter<"auditlog"> | number | null
    action_id?: StringNullableWithAggregatesFilter<"auditlog"> | string | null
    target_id?: IntWithAggregatesFilter<"auditlog"> | number
    target_entity?: StringNullableWithAggregatesFilter<"auditlog"> | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter<"auditlog"> | Date | string | null
  }

  export type badgeWhereInput = {
    AND?: badgeWhereInput | badgeWhereInput[]
    OR?: badgeWhereInput[]
    NOT?: badgeWhereInput | badgeWhereInput[]
    badge_id?: IntFilter<"badge"> | number
    tour_id?: IntNullableFilter<"badge"> | number | null
    badge_title?: StringFilter<"badge"> | string
    description?: StringFilter<"badge"> | string
    image_url?: StringFilter<"badge"> | string
    tour?: XOR<TourNullableScalarRelationFilter, tourWhereInput> | null
    userbadge?: UserbadgeListRelationFilter
  }

  export type badgeOrderByWithRelationInput = {
    badge_id?: SortOrder
    tour_id?: SortOrderInput | SortOrder
    badge_title?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
    tour?: tourOrderByWithRelationInput
    userbadge?: userbadgeOrderByRelationAggregateInput
  }

  export type badgeWhereUniqueInput = Prisma.AtLeast<{
    badge_id?: number
    badge_title?: string
    AND?: badgeWhereInput | badgeWhereInput[]
    OR?: badgeWhereInput[]
    NOT?: badgeWhereInput | badgeWhereInput[]
    tour_id?: IntNullableFilter<"badge"> | number | null
    description?: StringFilter<"badge"> | string
    image_url?: StringFilter<"badge"> | string
    tour?: XOR<TourNullableScalarRelationFilter, tourWhereInput> | null
    userbadge?: UserbadgeListRelationFilter
  }, "badge_id" | "badge_title">

  export type badgeOrderByWithAggregationInput = {
    badge_id?: SortOrder
    tour_id?: SortOrderInput | SortOrder
    badge_title?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
    _count?: badgeCountOrderByAggregateInput
    _avg?: badgeAvgOrderByAggregateInput
    _max?: badgeMaxOrderByAggregateInput
    _min?: badgeMinOrderByAggregateInput
    _sum?: badgeSumOrderByAggregateInput
  }

  export type badgeScalarWhereWithAggregatesInput = {
    AND?: badgeScalarWhereWithAggregatesInput | badgeScalarWhereWithAggregatesInput[]
    OR?: badgeScalarWhereWithAggregatesInput[]
    NOT?: badgeScalarWhereWithAggregatesInput | badgeScalarWhereWithAggregatesInput[]
    badge_id?: IntWithAggregatesFilter<"badge"> | number
    tour_id?: IntNullableWithAggregatesFilter<"badge"> | number | null
    badge_title?: StringWithAggregatesFilter<"badge"> | string
    description?: StringWithAggregatesFilter<"badge"> | string
    image_url?: StringWithAggregatesFilter<"badge"> | string
  }

  export type checkpointWhereInput = {
    AND?: checkpointWhereInput | checkpointWhereInput[]
    OR?: checkpointWhereInput[]
    NOT?: checkpointWhereInput | checkpointWhereInput[]
    checkpoint_id?: IntFilter<"checkpoint"> | number
    quiz_id?: IntNullableFilter<"checkpoint"> | number | null
    location_id?: IntFilter<"checkpoint"> | number
    points_reward?: IntFilter<"checkpoint"> | number
    created_at?: DateTimeNullableFilter<"checkpoint"> | Date | string | null
    location?: XOR<LocationScalarRelationFilter, locationWhereInput>
    quiz?: XOR<QuizNullableScalarRelationFilter, quizWhereInput> | null
    tourcheckpoint?: TourcheckpointListRelationFilter
    usercheckpointattempt?: UsercheckpointattemptListRelationFilter
  }

  export type checkpointOrderByWithRelationInput = {
    checkpoint_id?: SortOrder
    quiz_id?: SortOrderInput | SortOrder
    location_id?: SortOrder
    points_reward?: SortOrder
    created_at?: SortOrderInput | SortOrder
    location?: locationOrderByWithRelationInput
    quiz?: quizOrderByWithRelationInput
    tourcheckpoint?: tourcheckpointOrderByRelationAggregateInput
    usercheckpointattempt?: usercheckpointattemptOrderByRelationAggregateInput
  }

  export type checkpointWhereUniqueInput = Prisma.AtLeast<{
    checkpoint_id?: number
    AND?: checkpointWhereInput | checkpointWhereInput[]
    OR?: checkpointWhereInput[]
    NOT?: checkpointWhereInput | checkpointWhereInput[]
    quiz_id?: IntNullableFilter<"checkpoint"> | number | null
    location_id?: IntFilter<"checkpoint"> | number
    points_reward?: IntFilter<"checkpoint"> | number
    created_at?: DateTimeNullableFilter<"checkpoint"> | Date | string | null
    location?: XOR<LocationScalarRelationFilter, locationWhereInput>
    quiz?: XOR<QuizNullableScalarRelationFilter, quizWhereInput> | null
    tourcheckpoint?: TourcheckpointListRelationFilter
    usercheckpointattempt?: UsercheckpointattemptListRelationFilter
  }, "checkpoint_id">

  export type checkpointOrderByWithAggregationInput = {
    checkpoint_id?: SortOrder
    quiz_id?: SortOrderInput | SortOrder
    location_id?: SortOrder
    points_reward?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: checkpointCountOrderByAggregateInput
    _avg?: checkpointAvgOrderByAggregateInput
    _max?: checkpointMaxOrderByAggregateInput
    _min?: checkpointMinOrderByAggregateInput
    _sum?: checkpointSumOrderByAggregateInput
  }

  export type checkpointScalarWhereWithAggregatesInput = {
    AND?: checkpointScalarWhereWithAggregatesInput | checkpointScalarWhereWithAggregatesInput[]
    OR?: checkpointScalarWhereWithAggregatesInput[]
    NOT?: checkpointScalarWhereWithAggregatesInput | checkpointScalarWhereWithAggregatesInput[]
    checkpoint_id?: IntWithAggregatesFilter<"checkpoint"> | number
    quiz_id?: IntNullableWithAggregatesFilter<"checkpoint"> | number | null
    location_id?: IntWithAggregatesFilter<"checkpoint"> | number
    points_reward?: IntWithAggregatesFilter<"checkpoint"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"checkpoint"> | Date | string | null
  }

  export type locationWhereInput = {
    AND?: locationWhereInput | locationWhereInput[]
    OR?: locationWhereInput[]
    NOT?: locationWhereInput | locationWhereInput[]
    location_id?: IntFilter<"location"> | number
    location_name?: StringFilter<"location"> | string
    locationtype_id?: StringNullableFilter<"location"> | string | null
    description?: StringNullableFilter<"location"> | string | null
    created_at?: DateTimeNullableFilter<"location"> | Date | string | null
    checkpoint?: CheckpointListRelationFilter
    locationtype?: XOR<LocationtypeNullableScalarRelationFilter, locationtypeWhereInput> | null
  }

  export type locationOrderByWithRelationInput = {
    location_id?: SortOrder
    location_name?: SortOrder
    locationtype_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    checkpoint?: checkpointOrderByRelationAggregateInput
    locationtype?: locationtypeOrderByWithRelationInput
  }

  export type locationWhereUniqueInput = Prisma.AtLeast<{
    location_id?: number
    location_name?: string
    AND?: locationWhereInput | locationWhereInput[]
    OR?: locationWhereInput[]
    NOT?: locationWhereInput | locationWhereInput[]
    locationtype_id?: StringNullableFilter<"location"> | string | null
    description?: StringNullableFilter<"location"> | string | null
    created_at?: DateTimeNullableFilter<"location"> | Date | string | null
    checkpoint?: CheckpointListRelationFilter
    locationtype?: XOR<LocationtypeNullableScalarRelationFilter, locationtypeWhereInput> | null
  }, "location_id" | "location_name">

  export type locationOrderByWithAggregationInput = {
    location_id?: SortOrder
    location_name?: SortOrder
    locationtype_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: locationCountOrderByAggregateInput
    _avg?: locationAvgOrderByAggregateInput
    _max?: locationMaxOrderByAggregateInput
    _min?: locationMinOrderByAggregateInput
    _sum?: locationSumOrderByAggregateInput
  }

  export type locationScalarWhereWithAggregatesInput = {
    AND?: locationScalarWhereWithAggregatesInput | locationScalarWhereWithAggregatesInput[]
    OR?: locationScalarWhereWithAggregatesInput[]
    NOT?: locationScalarWhereWithAggregatesInput | locationScalarWhereWithAggregatesInput[]
    location_id?: IntWithAggregatesFilter<"location"> | number
    location_name?: StringWithAggregatesFilter<"location"> | string
    locationtype_id?: StringNullableWithAggregatesFilter<"location"> | string | null
    description?: StringNullableWithAggregatesFilter<"location"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"location"> | Date | string | null
  }

  export type locationtypeWhereInput = {
    AND?: locationtypeWhereInput | locationtypeWhereInput[]
    OR?: locationtypeWhereInput[]
    NOT?: locationtypeWhereInput | locationtypeWhereInput[]
    locationtype_id?: StringFilter<"locationtype"> | string
    description?: StringNullableFilter<"locationtype"> | string | null
    location?: LocationListRelationFilter
  }

  export type locationtypeOrderByWithRelationInput = {
    locationtype_id?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: locationOrderByRelationAggregateInput
  }

  export type locationtypeWhereUniqueInput = Prisma.AtLeast<{
    locationtype_id?: string
    AND?: locationtypeWhereInput | locationtypeWhereInput[]
    OR?: locationtypeWhereInput[]
    NOT?: locationtypeWhereInput | locationtypeWhereInput[]
    description?: StringNullableFilter<"locationtype"> | string | null
    location?: LocationListRelationFilter
  }, "locationtype_id">

  export type locationtypeOrderByWithAggregationInput = {
    locationtype_id?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: locationtypeCountOrderByAggregateInput
    _max?: locationtypeMaxOrderByAggregateInput
    _min?: locationtypeMinOrderByAggregateInput
  }

  export type locationtypeScalarWhereWithAggregatesInput = {
    AND?: locationtypeScalarWhereWithAggregatesInput | locationtypeScalarWhereWithAggregatesInput[]
    OR?: locationtypeScalarWhereWithAggregatesInput[]
    NOT?: locationtypeScalarWhereWithAggregatesInput | locationtypeScalarWhereWithAggregatesInput[]
    locationtype_id?: StringWithAggregatesFilter<"locationtype"> | string
    description?: StringNullableWithAggregatesFilter<"locationtype"> | string | null
  }

  export type permissionWhereInput = {
    AND?: permissionWhereInput | permissionWhereInput[]
    OR?: permissionWhereInput[]
    NOT?: permissionWhereInput | permissionWhereInput[]
    permission_id?: IntFilter<"permission"> | number
    permission_name?: StringFilter<"permission"> | string
    description?: StringNullableFilter<"permission"> | string | null
    rolepermission?: RolepermissionListRelationFilter
  }

  export type permissionOrderByWithRelationInput = {
    permission_id?: SortOrder
    permission_name?: SortOrder
    description?: SortOrderInput | SortOrder
    rolepermission?: rolepermissionOrderByRelationAggregateInput
  }

  export type permissionWhereUniqueInput = Prisma.AtLeast<{
    permission_id?: number
    permission_name?: string
    AND?: permissionWhereInput | permissionWhereInput[]
    OR?: permissionWhereInput[]
    NOT?: permissionWhereInput | permissionWhereInput[]
    description?: StringNullableFilter<"permission"> | string | null
    rolepermission?: RolepermissionListRelationFilter
  }, "permission_id" | "permission_name">

  export type permissionOrderByWithAggregationInput = {
    permission_id?: SortOrder
    permission_name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: permissionCountOrderByAggregateInput
    _avg?: permissionAvgOrderByAggregateInput
    _max?: permissionMaxOrderByAggregateInput
    _min?: permissionMinOrderByAggregateInput
    _sum?: permissionSumOrderByAggregateInput
  }

  export type permissionScalarWhereWithAggregatesInput = {
    AND?: permissionScalarWhereWithAggregatesInput | permissionScalarWhereWithAggregatesInput[]
    OR?: permissionScalarWhereWithAggregatesInput[]
    NOT?: permissionScalarWhereWithAggregatesInput | permissionScalarWhereWithAggregatesInput[]
    permission_id?: IntWithAggregatesFilter<"permission"> | number
    permission_name?: StringWithAggregatesFilter<"permission"> | string
    description?: StringNullableWithAggregatesFilter<"permission"> | string | null
  }

  export type questionWhereInput = {
    AND?: questionWhereInput | questionWhereInput[]
    OR?: questionWhereInput[]
    NOT?: questionWhereInput | questionWhereInput[]
    question_id?: IntFilter<"question"> | number
    question?: StringFilter<"question"> | string
    quiz_id?: IntNullableFilter<"question"> | number | null
    quiz?: XOR<QuizNullableScalarRelationFilter, quizWhereInput> | null
    questionoption?: QuestionoptionListRelationFilter
  }

  export type questionOrderByWithRelationInput = {
    question_id?: SortOrder
    question?: SortOrder
    quiz_id?: SortOrderInput | SortOrder
    quiz?: quizOrderByWithRelationInput
    questionoption?: questionoptionOrderByRelationAggregateInput
  }

  export type questionWhereUniqueInput = Prisma.AtLeast<{
    question_id?: number
    AND?: questionWhereInput | questionWhereInput[]
    OR?: questionWhereInput[]
    NOT?: questionWhereInput | questionWhereInput[]
    question?: StringFilter<"question"> | string
    quiz_id?: IntNullableFilter<"question"> | number | null
    quiz?: XOR<QuizNullableScalarRelationFilter, quizWhereInput> | null
    questionoption?: QuestionoptionListRelationFilter
  }, "question_id">

  export type questionOrderByWithAggregationInput = {
    question_id?: SortOrder
    question?: SortOrder
    quiz_id?: SortOrderInput | SortOrder
    _count?: questionCountOrderByAggregateInput
    _avg?: questionAvgOrderByAggregateInput
    _max?: questionMaxOrderByAggregateInput
    _min?: questionMinOrderByAggregateInput
    _sum?: questionSumOrderByAggregateInput
  }

  export type questionScalarWhereWithAggregatesInput = {
    AND?: questionScalarWhereWithAggregatesInput | questionScalarWhereWithAggregatesInput[]
    OR?: questionScalarWhereWithAggregatesInput[]
    NOT?: questionScalarWhereWithAggregatesInput | questionScalarWhereWithAggregatesInput[]
    question_id?: IntWithAggregatesFilter<"question"> | number
    question?: StringWithAggregatesFilter<"question"> | string
    quiz_id?: IntNullableWithAggregatesFilter<"question"> | number | null
  }

  export type questionoptionWhereInput = {
    AND?: questionoptionWhereInput | questionoptionWhereInput[]
    OR?: questionoptionWhereInput[]
    NOT?: questionoptionWhereInput | questionoptionWhereInput[]
    option_id?: IntFilter<"questionoption"> | number
    option?: StringFilter<"questionoption"> | string
    is_correct?: BoolFilter<"questionoption"> | boolean
    question_id?: IntFilter<"questionoption"> | number
    question?: XOR<QuestionScalarRelationFilter, questionWhereInput>
  }

  export type questionoptionOrderByWithRelationInput = {
    option_id?: SortOrder
    option?: SortOrder
    is_correct?: SortOrder
    question_id?: SortOrder
    question?: questionOrderByWithRelationInput
  }

  export type questionoptionWhereUniqueInput = Prisma.AtLeast<{
    option_id?: number
    AND?: questionoptionWhereInput | questionoptionWhereInput[]
    OR?: questionoptionWhereInput[]
    NOT?: questionoptionWhereInput | questionoptionWhereInput[]
    option?: StringFilter<"questionoption"> | string
    is_correct?: BoolFilter<"questionoption"> | boolean
    question_id?: IntFilter<"questionoption"> | number
    question?: XOR<QuestionScalarRelationFilter, questionWhereInput>
  }, "option_id">

  export type questionoptionOrderByWithAggregationInput = {
    option_id?: SortOrder
    option?: SortOrder
    is_correct?: SortOrder
    question_id?: SortOrder
    _count?: questionoptionCountOrderByAggregateInput
    _avg?: questionoptionAvgOrderByAggregateInput
    _max?: questionoptionMaxOrderByAggregateInput
    _min?: questionoptionMinOrderByAggregateInput
    _sum?: questionoptionSumOrderByAggregateInput
  }

  export type questionoptionScalarWhereWithAggregatesInput = {
    AND?: questionoptionScalarWhereWithAggregatesInput | questionoptionScalarWhereWithAggregatesInput[]
    OR?: questionoptionScalarWhereWithAggregatesInput[]
    NOT?: questionoptionScalarWhereWithAggregatesInput | questionoptionScalarWhereWithAggregatesInput[]
    option_id?: IntWithAggregatesFilter<"questionoption"> | number
    option?: StringWithAggregatesFilter<"questionoption"> | string
    is_correct?: BoolWithAggregatesFilter<"questionoption"> | boolean
    question_id?: IntWithAggregatesFilter<"questionoption"> | number
  }

  export type quizWhereInput = {
    AND?: quizWhereInput | quizWhereInput[]
    OR?: quizWhereInput[]
    NOT?: quizWhereInput | quizWhereInput[]
    quiz_id?: IntFilter<"quiz"> | number
    quiz_title?: StringFilter<"quiz"> | string
    description?: StringNullableFilter<"quiz"> | string | null
    checkpoint?: CheckpointListRelationFilter
    question?: QuestionListRelationFilter
    userquizcompletion?: UserquizcompletionListRelationFilter
  }

  export type quizOrderByWithRelationInput = {
    quiz_id?: SortOrder
    quiz_title?: SortOrder
    description?: SortOrderInput | SortOrder
    checkpoint?: checkpointOrderByRelationAggregateInput
    question?: questionOrderByRelationAggregateInput
    userquizcompletion?: userquizcompletionOrderByRelationAggregateInput
  }

  export type quizWhereUniqueInput = Prisma.AtLeast<{
    quiz_id?: number
    quiz_title?: string
    AND?: quizWhereInput | quizWhereInput[]
    OR?: quizWhereInput[]
    NOT?: quizWhereInput | quizWhereInput[]
    description?: StringNullableFilter<"quiz"> | string | null
    checkpoint?: CheckpointListRelationFilter
    question?: QuestionListRelationFilter
    userquizcompletion?: UserquizcompletionListRelationFilter
  }, "quiz_id" | "quiz_title">

  export type quizOrderByWithAggregationInput = {
    quiz_id?: SortOrder
    quiz_title?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: quizCountOrderByAggregateInput
    _avg?: quizAvgOrderByAggregateInput
    _max?: quizMaxOrderByAggregateInput
    _min?: quizMinOrderByAggregateInput
    _sum?: quizSumOrderByAggregateInput
  }

  export type quizScalarWhereWithAggregatesInput = {
    AND?: quizScalarWhereWithAggregatesInput | quizScalarWhereWithAggregatesInput[]
    OR?: quizScalarWhereWithAggregatesInput[]
    NOT?: quizScalarWhereWithAggregatesInput | quizScalarWhereWithAggregatesInput[]
    quiz_id?: IntWithAggregatesFilter<"quiz"> | number
    quiz_title?: StringWithAggregatesFilter<"quiz"> | string
    description?: StringNullableWithAggregatesFilter<"quiz"> | string | null
  }

  export type reviewWhereInput = {
    AND?: reviewWhereInput | reviewWhereInput[]
    OR?: reviewWhereInput[]
    NOT?: reviewWhereInput | reviewWhereInput[]
    review_id?: IntFilter<"review"> | number
    user_id?: IntNullableFilter<"review"> | number | null
    tour_id?: IntFilter<"review"> | number
    review_text?: StringFilter<"review"> | string
    rating?: IntFilter<"review"> | number
    created_at?: DateTimeNullableFilter<"review"> | Date | string | null
    tour?: XOR<TourScalarRelationFilter, tourWhereInput>
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type reviewOrderByWithRelationInput = {
    review_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    tour_id?: SortOrder
    review_text?: SortOrder
    rating?: SortOrder
    created_at?: SortOrderInput | SortOrder
    tour?: tourOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type reviewWhereUniqueInput = Prisma.AtLeast<{
    review_id?: number
    AND?: reviewWhereInput | reviewWhereInput[]
    OR?: reviewWhereInput[]
    NOT?: reviewWhereInput | reviewWhereInput[]
    user_id?: IntNullableFilter<"review"> | number | null
    tour_id?: IntFilter<"review"> | number
    review_text?: StringFilter<"review"> | string
    rating?: IntFilter<"review"> | number
    created_at?: DateTimeNullableFilter<"review"> | Date | string | null
    tour?: XOR<TourScalarRelationFilter, tourWhereInput>
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "review_id">

  export type reviewOrderByWithAggregationInput = {
    review_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    tour_id?: SortOrder
    review_text?: SortOrder
    rating?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: reviewCountOrderByAggregateInput
    _avg?: reviewAvgOrderByAggregateInput
    _max?: reviewMaxOrderByAggregateInput
    _min?: reviewMinOrderByAggregateInput
    _sum?: reviewSumOrderByAggregateInput
  }

  export type reviewScalarWhereWithAggregatesInput = {
    AND?: reviewScalarWhereWithAggregatesInput | reviewScalarWhereWithAggregatesInput[]
    OR?: reviewScalarWhereWithAggregatesInput[]
    NOT?: reviewScalarWhereWithAggregatesInput | reviewScalarWhereWithAggregatesInput[]
    review_id?: IntWithAggregatesFilter<"review"> | number
    user_id?: IntNullableWithAggregatesFilter<"review"> | number | null
    tour_id?: IntWithAggregatesFilter<"review"> | number
    review_text?: StringWithAggregatesFilter<"review"> | string
    rating?: IntWithAggregatesFilter<"review"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"review"> | Date | string | null
  }

  export type roleWhereInput = {
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    role_id?: IntFilter<"role"> | number
    role_name?: StringFilter<"role"> | string
    description?: StringNullableFilter<"role"> | string | null
    rolepermission?: RolepermissionListRelationFilter
    userrole?: UserroleListRelationFilter
  }

  export type roleOrderByWithRelationInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    description?: SortOrderInput | SortOrder
    rolepermission?: rolepermissionOrderByRelationAggregateInput
    userrole?: userroleOrderByRelationAggregateInput
  }

  export type roleWhereUniqueInput = Prisma.AtLeast<{
    role_id?: number
    role_name?: string
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    description?: StringNullableFilter<"role"> | string | null
    rolepermission?: RolepermissionListRelationFilter
    userrole?: UserroleListRelationFilter
  }, "role_id" | "role_name">

  export type roleOrderByWithAggregationInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: roleCountOrderByAggregateInput
    _avg?: roleAvgOrderByAggregateInput
    _max?: roleMaxOrderByAggregateInput
    _min?: roleMinOrderByAggregateInput
    _sum?: roleSumOrderByAggregateInput
  }

  export type roleScalarWhereWithAggregatesInput = {
    AND?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    OR?: roleScalarWhereWithAggregatesInput[]
    NOT?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"role"> | number
    role_name?: StringWithAggregatesFilter<"role"> | string
    description?: StringNullableWithAggregatesFilter<"role"> | string | null
  }

  export type rolepermissionWhereInput = {
    AND?: rolepermissionWhereInput | rolepermissionWhereInput[]
    OR?: rolepermissionWhereInput[]
    NOT?: rolepermissionWhereInput | rolepermissionWhereInput[]
    role_id?: IntFilter<"rolepermission"> | number
    permission_id?: IntFilter<"rolepermission"> | number
    created_at?: DateTimeNullableFilter<"rolepermission"> | Date | string | null
    permission?: XOR<PermissionScalarRelationFilter, permissionWhereInput>
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
  }

  export type rolepermissionOrderByWithRelationInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    permission?: permissionOrderByWithRelationInput
    role?: roleOrderByWithRelationInput
  }

  export type rolepermissionWhereUniqueInput = Prisma.AtLeast<{
    role_id_permission_id?: rolepermissionRole_idPermission_idCompoundUniqueInput
    AND?: rolepermissionWhereInput | rolepermissionWhereInput[]
    OR?: rolepermissionWhereInput[]
    NOT?: rolepermissionWhereInput | rolepermissionWhereInput[]
    role_id?: IntFilter<"rolepermission"> | number
    permission_id?: IntFilter<"rolepermission"> | number
    created_at?: DateTimeNullableFilter<"rolepermission"> | Date | string | null
    permission?: XOR<PermissionScalarRelationFilter, permissionWhereInput>
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
  }, "role_id_permission_id">

  export type rolepermissionOrderByWithAggregationInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: rolepermissionCountOrderByAggregateInput
    _avg?: rolepermissionAvgOrderByAggregateInput
    _max?: rolepermissionMaxOrderByAggregateInput
    _min?: rolepermissionMinOrderByAggregateInput
    _sum?: rolepermissionSumOrderByAggregateInput
  }

  export type rolepermissionScalarWhereWithAggregatesInput = {
    AND?: rolepermissionScalarWhereWithAggregatesInput | rolepermissionScalarWhereWithAggregatesInput[]
    OR?: rolepermissionScalarWhereWithAggregatesInput[]
    NOT?: rolepermissionScalarWhereWithAggregatesInput | rolepermissionScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"rolepermission"> | number
    permission_id?: IntWithAggregatesFilter<"rolepermission"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"rolepermission"> | Date | string | null
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    session_id?: IntFilter<"sessions"> | number
    user_id?: IntNullableFilter<"sessions"> | number | null
    access_token?: StringNullableFilter<"sessions"> | string | null
    is_active?: BoolNullableFilter<"sessions"> | boolean | null
    login_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    logout_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    auditlog?: AuditlogListRelationFilter
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type sessionsOrderByWithRelationInput = {
    session_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    login_at?: SortOrderInput | SortOrder
    logout_at?: SortOrderInput | SortOrder
    auditlog?: auditlogOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    session_id?: number
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    user_id?: IntNullableFilter<"sessions"> | number | null
    access_token?: StringNullableFilter<"sessions"> | string | null
    is_active?: BoolNullableFilter<"sessions"> | boolean | null
    login_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    logout_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    auditlog?: AuditlogListRelationFilter
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "session_id">

  export type sessionsOrderByWithAggregationInput = {
    session_id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    login_at?: SortOrderInput | SortOrder
    logout_at?: SortOrderInput | SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _avg?: sessionsAvgOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
    _sum?: sessionsSumOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    session_id?: IntWithAggregatesFilter<"sessions"> | number
    user_id?: IntNullableWithAggregatesFilter<"sessions"> | number | null
    access_token?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"sessions"> | boolean | null
    login_at?: DateTimeNullableWithAggregatesFilter<"sessions"> | Date | string | null
    logout_at?: DateTimeNullableWithAggregatesFilter<"sessions"> | Date | string | null
  }

  export type tourWhereInput = {
    AND?: tourWhereInput | tourWhereInput[]
    OR?: tourWhereInput[]
    NOT?: tourWhereInput | tourWhereInput[]
    tour_id?: IntFilter<"tour"> | number
    tour_name?: StringFilter<"tour"> | string
    description?: StringNullableFilter<"tour"> | string | null
    created_at?: DateTimeNullableFilter<"tour"> | Date | string | null
    badge?: BadgeListRelationFilter
    review?: ReviewListRelationFilter
    tourcheckpoint?: TourcheckpointListRelationFilter
    usertourcompletion?: UsertourcompletionListRelationFilter
  }

  export type tourOrderByWithRelationInput = {
    tour_id?: SortOrder
    tour_name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    badge?: badgeOrderByRelationAggregateInput
    review?: reviewOrderByRelationAggregateInput
    tourcheckpoint?: tourcheckpointOrderByRelationAggregateInput
    usertourcompletion?: usertourcompletionOrderByRelationAggregateInput
  }

  export type tourWhereUniqueInput = Prisma.AtLeast<{
    tour_id?: number
    tour_name?: string
    AND?: tourWhereInput | tourWhereInput[]
    OR?: tourWhereInput[]
    NOT?: tourWhereInput | tourWhereInput[]
    description?: StringNullableFilter<"tour"> | string | null
    created_at?: DateTimeNullableFilter<"tour"> | Date | string | null
    badge?: BadgeListRelationFilter
    review?: ReviewListRelationFilter
    tourcheckpoint?: TourcheckpointListRelationFilter
    usertourcompletion?: UsertourcompletionListRelationFilter
  }, "tour_id" | "tour_name">

  export type tourOrderByWithAggregationInput = {
    tour_id?: SortOrder
    tour_name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: tourCountOrderByAggregateInput
    _avg?: tourAvgOrderByAggregateInput
    _max?: tourMaxOrderByAggregateInput
    _min?: tourMinOrderByAggregateInput
    _sum?: tourSumOrderByAggregateInput
  }

  export type tourScalarWhereWithAggregatesInput = {
    AND?: tourScalarWhereWithAggregatesInput | tourScalarWhereWithAggregatesInput[]
    OR?: tourScalarWhereWithAggregatesInput[]
    NOT?: tourScalarWhereWithAggregatesInput | tourScalarWhereWithAggregatesInput[]
    tour_id?: IntWithAggregatesFilter<"tour"> | number
    tour_name?: StringWithAggregatesFilter<"tour"> | string
    description?: StringNullableWithAggregatesFilter<"tour"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"tour"> | Date | string | null
  }

  export type tourcheckpointWhereInput = {
    AND?: tourcheckpointWhereInput | tourcheckpointWhereInput[]
    OR?: tourcheckpointWhereInput[]
    NOT?: tourcheckpointWhereInput | tourcheckpointWhereInput[]
    tour_id?: IntFilter<"tourcheckpoint"> | number
    checkpoint_id?: IntFilter<"tourcheckpoint"> | number
    checkpoint_order?: IntFilter<"tourcheckpoint"> | number
    checkpoint?: XOR<CheckpointScalarRelationFilter, checkpointWhereInput>
    tour?: XOR<TourScalarRelationFilter, tourWhereInput>
  }

  export type tourcheckpointOrderByWithRelationInput = {
    tour_id?: SortOrder
    checkpoint_id?: SortOrder
    checkpoint_order?: SortOrder
    checkpoint?: checkpointOrderByWithRelationInput
    tour?: tourOrderByWithRelationInput
  }

  export type tourcheckpointWhereUniqueInput = Prisma.AtLeast<{
    tour_id_checkpoint_id?: tourcheckpointTour_idCheckpoint_idCompoundUniqueInput
    AND?: tourcheckpointWhereInput | tourcheckpointWhereInput[]
    OR?: tourcheckpointWhereInput[]
    NOT?: tourcheckpointWhereInput | tourcheckpointWhereInput[]
    tour_id?: IntFilter<"tourcheckpoint"> | number
    checkpoint_id?: IntFilter<"tourcheckpoint"> | number
    checkpoint_order?: IntFilter<"tourcheckpoint"> | number
    checkpoint?: XOR<CheckpointScalarRelationFilter, checkpointWhereInput>
    tour?: XOR<TourScalarRelationFilter, tourWhereInput>
  }, "tour_id_checkpoint_id">

  export type tourcheckpointOrderByWithAggregationInput = {
    tour_id?: SortOrder
    checkpoint_id?: SortOrder
    checkpoint_order?: SortOrder
    _count?: tourcheckpointCountOrderByAggregateInput
    _avg?: tourcheckpointAvgOrderByAggregateInput
    _max?: tourcheckpointMaxOrderByAggregateInput
    _min?: tourcheckpointMinOrderByAggregateInput
    _sum?: tourcheckpointSumOrderByAggregateInput
  }

  export type tourcheckpointScalarWhereWithAggregatesInput = {
    AND?: tourcheckpointScalarWhereWithAggregatesInput | tourcheckpointScalarWhereWithAggregatesInput[]
    OR?: tourcheckpointScalarWhereWithAggregatesInput[]
    NOT?: tourcheckpointScalarWhereWithAggregatesInput | tourcheckpointScalarWhereWithAggregatesInput[]
    tour_id?: IntWithAggregatesFilter<"tourcheckpoint"> | number
    checkpoint_id?: IntWithAggregatesFilter<"tourcheckpoint"> | number
    checkpoint_order?: IntWithAggregatesFilter<"tourcheckpoint"> | number
  }

  export type userbadgeWhereInput = {
    AND?: userbadgeWhereInput | userbadgeWhereInput[]
    OR?: userbadgeWhereInput[]
    NOT?: userbadgeWhereInput | userbadgeWhereInput[]
    badge_id?: IntFilter<"userbadge"> | number
    user_id?: IntFilter<"userbadge"> | number
    created_at?: DateTimeNullableFilter<"userbadge"> | Date | string | null
    badge?: XOR<BadgeScalarRelationFilter, badgeWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type userbadgeOrderByWithRelationInput = {
    badge_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    badge?: badgeOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type userbadgeWhereUniqueInput = Prisma.AtLeast<{
    badge_id_user_id?: userbadgeBadge_idUser_idCompoundUniqueInput
    AND?: userbadgeWhereInput | userbadgeWhereInput[]
    OR?: userbadgeWhereInput[]
    NOT?: userbadgeWhereInput | userbadgeWhereInput[]
    badge_id?: IntFilter<"userbadge"> | number
    user_id?: IntFilter<"userbadge"> | number
    created_at?: DateTimeNullableFilter<"userbadge"> | Date | string | null
    badge?: XOR<BadgeScalarRelationFilter, badgeWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "badge_id_user_id">

  export type userbadgeOrderByWithAggregationInput = {
    badge_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: userbadgeCountOrderByAggregateInput
    _avg?: userbadgeAvgOrderByAggregateInput
    _max?: userbadgeMaxOrderByAggregateInput
    _min?: userbadgeMinOrderByAggregateInput
    _sum?: userbadgeSumOrderByAggregateInput
  }

  export type userbadgeScalarWhereWithAggregatesInput = {
    AND?: userbadgeScalarWhereWithAggregatesInput | userbadgeScalarWhereWithAggregatesInput[]
    OR?: userbadgeScalarWhereWithAggregatesInput[]
    NOT?: userbadgeScalarWhereWithAggregatesInput | userbadgeScalarWhereWithAggregatesInput[]
    badge_id?: IntWithAggregatesFilter<"userbadge"> | number
    user_id?: IntWithAggregatesFilter<"userbadge"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"userbadge"> | Date | string | null
  }

  export type usercheckpointattemptWhereInput = {
    AND?: usercheckpointattemptWhereInput | usercheckpointattemptWhereInput[]
    OR?: usercheckpointattemptWhereInput[]
    NOT?: usercheckpointattemptWhereInput | usercheckpointattemptWhereInput[]
    checkpointattempt_id?: IntFilter<"usercheckpointattempt"> | number
    user_id?: IntFilter<"usercheckpointattempt"> | number
    checkpoint_id?: IntNullableFilter<"usercheckpointattempt"> | number | null
    tourcompletion_id?: IntFilter<"usercheckpointattempt"> | number
    created_at?: DateTimeNullableFilter<"usercheckpointattempt"> | Date | string | null
    checkpoint?: XOR<CheckpointNullableScalarRelationFilter, checkpointWhereInput> | null
    usertourcompletion?: XOR<UsertourcompletionScalarRelationFilter, usertourcompletionWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type usercheckpointattemptOrderByWithRelationInput = {
    checkpointattempt_id?: SortOrder
    user_id?: SortOrder
    checkpoint_id?: SortOrderInput | SortOrder
    tourcompletion_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    checkpoint?: checkpointOrderByWithRelationInput
    usertourcompletion?: usertourcompletionOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type usercheckpointattemptWhereUniqueInput = Prisma.AtLeast<{
    checkpointattempt_id?: number
    AND?: usercheckpointattemptWhereInput | usercheckpointattemptWhereInput[]
    OR?: usercheckpointattemptWhereInput[]
    NOT?: usercheckpointattemptWhereInput | usercheckpointattemptWhereInput[]
    user_id?: IntFilter<"usercheckpointattempt"> | number
    checkpoint_id?: IntNullableFilter<"usercheckpointattempt"> | number | null
    tourcompletion_id?: IntFilter<"usercheckpointattempt"> | number
    created_at?: DateTimeNullableFilter<"usercheckpointattempt"> | Date | string | null
    checkpoint?: XOR<CheckpointNullableScalarRelationFilter, checkpointWhereInput> | null
    usertourcompletion?: XOR<UsertourcompletionScalarRelationFilter, usertourcompletionWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "checkpointattempt_id">

  export type usercheckpointattemptOrderByWithAggregationInput = {
    checkpointattempt_id?: SortOrder
    user_id?: SortOrder
    checkpoint_id?: SortOrderInput | SortOrder
    tourcompletion_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: usercheckpointattemptCountOrderByAggregateInput
    _avg?: usercheckpointattemptAvgOrderByAggregateInput
    _max?: usercheckpointattemptMaxOrderByAggregateInput
    _min?: usercheckpointattemptMinOrderByAggregateInput
    _sum?: usercheckpointattemptSumOrderByAggregateInput
  }

  export type usercheckpointattemptScalarWhereWithAggregatesInput = {
    AND?: usercheckpointattemptScalarWhereWithAggregatesInput | usercheckpointattemptScalarWhereWithAggregatesInput[]
    OR?: usercheckpointattemptScalarWhereWithAggregatesInput[]
    NOT?: usercheckpointattemptScalarWhereWithAggregatesInput | usercheckpointattemptScalarWhereWithAggregatesInput[]
    checkpointattempt_id?: IntWithAggregatesFilter<"usercheckpointattempt"> | number
    user_id?: IntWithAggregatesFilter<"usercheckpointattempt"> | number
    checkpoint_id?: IntNullableWithAggregatesFilter<"usercheckpointattempt"> | number | null
    tourcompletion_id?: IntWithAggregatesFilter<"usercheckpointattempt"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"usercheckpointattempt"> | Date | string | null
  }

  export type userprofileWhereInput = {
    AND?: userprofileWhereInput | userprofileWhereInput[]
    OR?: userprofileWhereInput[]
    NOT?: userprofileWhereInput | userprofileWhereInput[]
    profile_id?: IntFilter<"userprofile"> | number
    user_id?: IntFilter<"userprofile"> | number
    points?: IntNullableFilter<"userprofile"> | number | null
    level?: IntNullableFilter<"userprofile"> | number | null
    first_name?: StringFilter<"userprofile"> | string
    last_name?: StringFilter<"userprofile"> | string
    school?: StringNullableFilter<"userprofile"> | string | null
    sec_level?: Enumsec_levelFilter<"userprofile"> | $Enums.sec_level
    created_at?: DateTimeNullableFilter<"userprofile"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"userprofile"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type userprofileOrderByWithRelationInput = {
    profile_id?: SortOrder
    user_id?: SortOrder
    points?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    school?: SortOrderInput | SortOrder
    sec_level?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type userprofileWhereUniqueInput = Prisma.AtLeast<{
    profile_id?: number
    user_id?: number
    AND?: userprofileWhereInput | userprofileWhereInput[]
    OR?: userprofileWhereInput[]
    NOT?: userprofileWhereInput | userprofileWhereInput[]
    points?: IntNullableFilter<"userprofile"> | number | null
    level?: IntNullableFilter<"userprofile"> | number | null
    first_name?: StringFilter<"userprofile"> | string
    last_name?: StringFilter<"userprofile"> | string
    school?: StringNullableFilter<"userprofile"> | string | null
    sec_level?: Enumsec_levelFilter<"userprofile"> | $Enums.sec_level
    created_at?: DateTimeNullableFilter<"userprofile"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"userprofile"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "profile_id" | "user_id">

  export type userprofileOrderByWithAggregationInput = {
    profile_id?: SortOrder
    user_id?: SortOrder
    points?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    school?: SortOrderInput | SortOrder
    sec_level?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: userprofileCountOrderByAggregateInput
    _avg?: userprofileAvgOrderByAggregateInput
    _max?: userprofileMaxOrderByAggregateInput
    _min?: userprofileMinOrderByAggregateInput
    _sum?: userprofileSumOrderByAggregateInput
  }

  export type userprofileScalarWhereWithAggregatesInput = {
    AND?: userprofileScalarWhereWithAggregatesInput | userprofileScalarWhereWithAggregatesInput[]
    OR?: userprofileScalarWhereWithAggregatesInput[]
    NOT?: userprofileScalarWhereWithAggregatesInput | userprofileScalarWhereWithAggregatesInput[]
    profile_id?: IntWithAggregatesFilter<"userprofile"> | number
    user_id?: IntWithAggregatesFilter<"userprofile"> | number
    points?: IntNullableWithAggregatesFilter<"userprofile"> | number | null
    level?: IntNullableWithAggregatesFilter<"userprofile"> | number | null
    first_name?: StringWithAggregatesFilter<"userprofile"> | string
    last_name?: StringWithAggregatesFilter<"userprofile"> | string
    school?: StringNullableWithAggregatesFilter<"userprofile"> | string | null
    sec_level?: Enumsec_levelWithAggregatesFilter<"userprofile"> | $Enums.sec_level
    created_at?: DateTimeNullableWithAggregatesFilter<"userprofile"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"userprofile"> | Date | string | null
  }

  export type userquizcompletionWhereInput = {
    AND?: userquizcompletionWhereInput | userquizcompletionWhereInput[]
    OR?: userquizcompletionWhereInput[]
    NOT?: userquizcompletionWhereInput | userquizcompletionWhereInput[]
    quizcompletion_id?: IntFilter<"userquizcompletion"> | number
    quiz_id?: IntFilter<"userquizcompletion"> | number
    user_id?: IntFilter<"userquizcompletion"> | number
    score?: IntFilter<"userquizcompletion"> | number
    created_at?: DateTimeNullableFilter<"userquizcompletion"> | Date | string | null
    quiz?: XOR<QuizScalarRelationFilter, quizWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type userquizcompletionOrderByWithRelationInput = {
    quizcompletion_id?: SortOrder
    quiz_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
    created_at?: SortOrderInput | SortOrder
    quiz?: quizOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type userquizcompletionWhereUniqueInput = Prisma.AtLeast<{
    quizcompletion_id?: number
    AND?: userquizcompletionWhereInput | userquizcompletionWhereInput[]
    OR?: userquizcompletionWhereInput[]
    NOT?: userquizcompletionWhereInput | userquizcompletionWhereInput[]
    quiz_id?: IntFilter<"userquizcompletion"> | number
    user_id?: IntFilter<"userquizcompletion"> | number
    score?: IntFilter<"userquizcompletion"> | number
    created_at?: DateTimeNullableFilter<"userquizcompletion"> | Date | string | null
    quiz?: XOR<QuizScalarRelationFilter, quizWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "quizcompletion_id">

  export type userquizcompletionOrderByWithAggregationInput = {
    quizcompletion_id?: SortOrder
    quiz_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: userquizcompletionCountOrderByAggregateInput
    _avg?: userquizcompletionAvgOrderByAggregateInput
    _max?: userquizcompletionMaxOrderByAggregateInput
    _min?: userquizcompletionMinOrderByAggregateInput
    _sum?: userquizcompletionSumOrderByAggregateInput
  }

  export type userquizcompletionScalarWhereWithAggregatesInput = {
    AND?: userquizcompletionScalarWhereWithAggregatesInput | userquizcompletionScalarWhereWithAggregatesInput[]
    OR?: userquizcompletionScalarWhereWithAggregatesInput[]
    NOT?: userquizcompletionScalarWhereWithAggregatesInput | userquizcompletionScalarWhereWithAggregatesInput[]
    quizcompletion_id?: IntWithAggregatesFilter<"userquizcompletion"> | number
    quiz_id?: IntWithAggregatesFilter<"userquizcompletion"> | number
    user_id?: IntWithAggregatesFilter<"userquizcompletion"> | number
    score?: IntWithAggregatesFilter<"userquizcompletion"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"userquizcompletion"> | Date | string | null
  }

  export type userroleWhereInput = {
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    user_id?: IntFilter<"userrole"> | number
    role_id?: IntFilter<"userrole"> | number
    created_at?: DateTimeNullableFilter<"userrole"> | Date | string | null
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type userroleOrderByWithRelationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    role?: roleOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type userroleWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    user_id_role_id?: userroleUser_idRole_idCompoundUniqueInput
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    role_id?: IntFilter<"userrole"> | number
    created_at?: DateTimeNullableFilter<"userrole"> | Date | string | null
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "user_id_role_id" | "user_id">

  export type userroleOrderByWithAggregationInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: userroleCountOrderByAggregateInput
    _avg?: userroleAvgOrderByAggregateInput
    _max?: userroleMaxOrderByAggregateInput
    _min?: userroleMinOrderByAggregateInput
    _sum?: userroleSumOrderByAggregateInput
  }

  export type userroleScalarWhereWithAggregatesInput = {
    AND?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    OR?: userroleScalarWhereWithAggregatesInput[]
    NOT?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"userrole"> | number
    role_id?: IntWithAggregatesFilter<"userrole"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"userrole"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    user_id?: IntFilter<"users"> | number
    username?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    is_verified?: BoolNullableFilter<"users"> | boolean | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    auditlog?: AuditlogListRelationFilter
    review?: ReviewListRelationFilter
    sessions?: SessionsListRelationFilter
    userbadge?: UserbadgeListRelationFilter
    usercheckpointattempt?: UsercheckpointattemptListRelationFilter
    userprofile?: XOR<UserprofileNullableScalarRelationFilter, userprofileWhereInput> | null
    userquizcompletion?: UserquizcompletionListRelationFilter
    userrole?: XOR<UserroleNullableScalarRelationFilter, userroleWhereInput> | null
    usertourcompletion?: UsertourcompletionListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    user_id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    is_verified?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    auditlog?: auditlogOrderByRelationAggregateInput
    review?: reviewOrderByRelationAggregateInput
    sessions?: sessionsOrderByRelationAggregateInput
    userbadge?: userbadgeOrderByRelationAggregateInput
    usercheckpointattempt?: usercheckpointattemptOrderByRelationAggregateInput
    userprofile?: userprofileOrderByWithRelationInput
    userquizcompletion?: userquizcompletionOrderByRelationAggregateInput
    userrole?: userroleOrderByWithRelationInput
    usertourcompletion?: usertourcompletionOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    username?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    is_verified?: BoolNullableFilter<"users"> | boolean | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    auditlog?: AuditlogListRelationFilter
    review?: ReviewListRelationFilter
    sessions?: SessionsListRelationFilter
    userbadge?: UserbadgeListRelationFilter
    usercheckpointattempt?: UsercheckpointattemptListRelationFilter
    userprofile?: XOR<UserprofileNullableScalarRelationFilter, userprofileWhereInput> | null
    userquizcompletion?: UserquizcompletionListRelationFilter
    userrole?: XOR<UserroleNullableScalarRelationFilter, userroleWhereInput> | null
    usertourcompletion?: UsertourcompletionListRelationFilter
  }, "user_id" | "username" | "email">

  export type usersOrderByWithAggregationInput = {
    user_id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    is_verified?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"users"> | number
    username?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    is_verified?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type usertourcompletionWhereInput = {
    AND?: usertourcompletionWhereInput | usertourcompletionWhereInput[]
    OR?: usertourcompletionWhereInput[]
    NOT?: usertourcompletionWhereInput | usertourcompletionWhereInput[]
    tourcompletion_id?: IntFilter<"usertourcompletion"> | number
    user_id?: IntFilter<"usertourcompletion"> | number
    tour_id?: IntNullableFilter<"usertourcompletion"> | number | null
    completed?: BoolNullableFilter<"usertourcompletion"> | boolean | null
    completed_at?: DateTimeNullableFilter<"usertourcompletion"> | Date | string | null
    created_at?: DateTimeNullableFilter<"usertourcompletion"> | Date | string | null
    usercheckpointattempt?: UsercheckpointattemptListRelationFilter
    tour?: XOR<TourNullableScalarRelationFilter, tourWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type usertourcompletionOrderByWithRelationInput = {
    tourcompletion_id?: SortOrder
    user_id?: SortOrder
    tour_id?: SortOrderInput | SortOrder
    completed?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    usercheckpointattempt?: usercheckpointattemptOrderByRelationAggregateInput
    tour?: tourOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type usertourcompletionWhereUniqueInput = Prisma.AtLeast<{
    tourcompletion_id?: number
    AND?: usertourcompletionWhereInput | usertourcompletionWhereInput[]
    OR?: usertourcompletionWhereInput[]
    NOT?: usertourcompletionWhereInput | usertourcompletionWhereInput[]
    user_id?: IntFilter<"usertourcompletion"> | number
    tour_id?: IntNullableFilter<"usertourcompletion"> | number | null
    completed?: BoolNullableFilter<"usertourcompletion"> | boolean | null
    completed_at?: DateTimeNullableFilter<"usertourcompletion"> | Date | string | null
    created_at?: DateTimeNullableFilter<"usertourcompletion"> | Date | string | null
    usercheckpointattempt?: UsercheckpointattemptListRelationFilter
    tour?: XOR<TourNullableScalarRelationFilter, tourWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "tourcompletion_id">

  export type usertourcompletionOrderByWithAggregationInput = {
    tourcompletion_id?: SortOrder
    user_id?: SortOrder
    tour_id?: SortOrderInput | SortOrder
    completed?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: usertourcompletionCountOrderByAggregateInput
    _avg?: usertourcompletionAvgOrderByAggregateInput
    _max?: usertourcompletionMaxOrderByAggregateInput
    _min?: usertourcompletionMinOrderByAggregateInput
    _sum?: usertourcompletionSumOrderByAggregateInput
  }

  export type usertourcompletionScalarWhereWithAggregatesInput = {
    AND?: usertourcompletionScalarWhereWithAggregatesInput | usertourcompletionScalarWhereWithAggregatesInput[]
    OR?: usertourcompletionScalarWhereWithAggregatesInput[]
    NOT?: usertourcompletionScalarWhereWithAggregatesInput | usertourcompletionScalarWhereWithAggregatesInput[]
    tourcompletion_id?: IntWithAggregatesFilter<"usertourcompletion"> | number
    user_id?: IntWithAggregatesFilter<"usertourcompletion"> | number
    tour_id?: IntNullableWithAggregatesFilter<"usertourcompletion"> | number | null
    completed?: BoolNullableWithAggregatesFilter<"usertourcompletion"> | boolean | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"usertourcompletion"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"usertourcompletion"> | Date | string | null
  }

  export type auditactionCreateInput = {
    action_id: string
    description?: string | null
    auditlog?: auditlogCreateNestedManyWithoutAuditactionInput
  }

  export type auditactionUncheckedCreateInput = {
    action_id: string
    description?: string | null
    auditlog?: auditlogUncheckedCreateNestedManyWithoutAuditactionInput
  }

  export type auditactionUpdateInput = {
    action_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    auditlog?: auditlogUpdateManyWithoutAuditactionNestedInput
  }

  export type auditactionUncheckedUpdateInput = {
    action_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    auditlog?: auditlogUncheckedUpdateManyWithoutAuditactionNestedInput
  }

  export type auditactionCreateManyInput = {
    action_id: string
    description?: string | null
  }

  export type auditactionUpdateManyMutationInput = {
    action_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditactionUncheckedUpdateManyInput = {
    action_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditlogCreateInput = {
    target_id: number
    target_entity?: string | null
    timestamp?: Date | string | null
    auditaction?: auditactionCreateNestedOneWithoutAuditlogInput
    sessions?: sessionsCreateNestedOneWithoutAuditlogInput
    users?: usersCreateNestedOneWithoutAuditlogInput
  }

  export type auditlogUncheckedCreateInput = {
    log_id?: number
    user_id?: number | null
    session_id?: number | null
    action_id?: string | null
    target_id: number
    target_entity?: string | null
    timestamp?: Date | string | null
  }

  export type auditlogUpdateInput = {
    target_id?: IntFieldUpdateOperationsInput | number
    target_entity?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditaction?: auditactionUpdateOneWithoutAuditlogNestedInput
    sessions?: sessionsUpdateOneWithoutAuditlogNestedInput
    users?: usersUpdateOneWithoutAuditlogNestedInput
  }

  export type auditlogUncheckedUpdateInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    session_id?: NullableIntFieldUpdateOperationsInput | number | null
    action_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: IntFieldUpdateOperationsInput | number
    target_entity?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auditlogCreateManyInput = {
    log_id?: number
    user_id?: number | null
    session_id?: number | null
    action_id?: string | null
    target_id: number
    target_entity?: string | null
    timestamp?: Date | string | null
  }

  export type auditlogUpdateManyMutationInput = {
    target_id?: IntFieldUpdateOperationsInput | number
    target_entity?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auditlogUncheckedUpdateManyInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    session_id?: NullableIntFieldUpdateOperationsInput | number | null
    action_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: IntFieldUpdateOperationsInput | number
    target_entity?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type badgeCreateInput = {
    badge_title: string
    description: string
    image_url: string
    tour?: tourCreateNestedOneWithoutBadgeInput
    userbadge?: userbadgeCreateNestedManyWithoutBadgeInput
  }

  export type badgeUncheckedCreateInput = {
    badge_id?: number
    tour_id?: number | null
    badge_title: string
    description: string
    image_url: string
    userbadge?: userbadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type badgeUpdateInput = {
    badge_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    tour?: tourUpdateOneWithoutBadgeNestedInput
    userbadge?: userbadgeUpdateManyWithoutBadgeNestedInput
  }

  export type badgeUncheckedUpdateInput = {
    badge_id?: IntFieldUpdateOperationsInput | number
    tour_id?: NullableIntFieldUpdateOperationsInput | number | null
    badge_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    userbadge?: userbadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type badgeCreateManyInput = {
    badge_id?: number
    tour_id?: number | null
    badge_title: string
    description: string
    image_url: string
  }

  export type badgeUpdateManyMutationInput = {
    badge_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type badgeUncheckedUpdateManyInput = {
    badge_id?: IntFieldUpdateOperationsInput | number
    tour_id?: NullableIntFieldUpdateOperationsInput | number | null
    badge_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type checkpointCreateInput = {
    points_reward: number
    created_at?: Date | string | null
    location: locationCreateNestedOneWithoutCheckpointInput
    quiz?: quizCreateNestedOneWithoutCheckpointInput
    tourcheckpoint?: tourcheckpointCreateNestedManyWithoutCheckpointInput
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointUncheckedCreateInput = {
    checkpoint_id?: number
    quiz_id?: number | null
    location_id: number
    points_reward: number
    created_at?: Date | string | null
    tourcheckpoint?: tourcheckpointUncheckedCreateNestedManyWithoutCheckpointInput
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointUpdateInput = {
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: locationUpdateOneRequiredWithoutCheckpointNestedInput
    quiz?: quizUpdateOneWithoutCheckpointNestedInput
    tourcheckpoint?: tourcheckpointUpdateManyWithoutCheckpointNestedInput
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutCheckpointNestedInput
  }

  export type checkpointUncheckedUpdateInput = {
    checkpoint_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: NullableIntFieldUpdateOperationsInput | number | null
    location_id?: IntFieldUpdateOperationsInput | number
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tourcheckpoint?: tourcheckpointUncheckedUpdateManyWithoutCheckpointNestedInput
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutCheckpointNestedInput
  }

  export type checkpointCreateManyInput = {
    checkpoint_id?: number
    quiz_id?: number | null
    location_id: number
    points_reward: number
    created_at?: Date | string | null
  }

  export type checkpointUpdateManyMutationInput = {
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type checkpointUncheckedUpdateManyInput = {
    checkpoint_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: NullableIntFieldUpdateOperationsInput | number | null
    location_id?: IntFieldUpdateOperationsInput | number
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type locationCreateInput = {
    location_name: string
    description?: string | null
    created_at?: Date | string | null
    checkpoint?: checkpointCreateNestedManyWithoutLocationInput
    locationtype?: locationtypeCreateNestedOneWithoutLocationInput
  }

  export type locationUncheckedCreateInput = {
    location_id?: number
    location_name: string
    locationtype_id?: string | null
    description?: string | null
    created_at?: Date | string | null
    checkpoint?: checkpointUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationUpdateInput = {
    location_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpoint?: checkpointUpdateManyWithoutLocationNestedInput
    locationtype?: locationtypeUpdateOneWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateInput = {
    location_id?: IntFieldUpdateOperationsInput | number
    location_name?: StringFieldUpdateOperationsInput | string
    locationtype_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpoint?: checkpointUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type locationCreateManyInput = {
    location_id?: number
    location_name: string
    locationtype_id?: string | null
    description?: string | null
    created_at?: Date | string | null
  }

  export type locationUpdateManyMutationInput = {
    location_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type locationUncheckedUpdateManyInput = {
    location_id?: IntFieldUpdateOperationsInput | number
    location_name?: StringFieldUpdateOperationsInput | string
    locationtype_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type locationtypeCreateInput = {
    locationtype_id: string
    description?: string | null
    location?: locationCreateNestedManyWithoutLocationtypeInput
  }

  export type locationtypeUncheckedCreateInput = {
    locationtype_id: string
    description?: string | null
    location?: locationUncheckedCreateNestedManyWithoutLocationtypeInput
  }

  export type locationtypeUpdateInput = {
    locationtype_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: locationUpdateManyWithoutLocationtypeNestedInput
  }

  export type locationtypeUncheckedUpdateInput = {
    locationtype_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: locationUncheckedUpdateManyWithoutLocationtypeNestedInput
  }

  export type locationtypeCreateManyInput = {
    locationtype_id: string
    description?: string | null
  }

  export type locationtypeUpdateManyMutationInput = {
    locationtype_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locationtypeUncheckedUpdateManyInput = {
    locationtype_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissionCreateInput = {
    permission_id: number
    permission_name: string
    description?: string | null
    rolepermission?: rolepermissionCreateNestedManyWithoutPermissionInput
  }

  export type permissionUncheckedCreateInput = {
    permission_id: number
    permission_name: string
    description?: string | null
    rolepermission?: rolepermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type permissionUpdateInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    permission_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rolepermission?: rolepermissionUpdateManyWithoutPermissionNestedInput
  }

  export type permissionUncheckedUpdateInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    permission_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rolepermission?: rolepermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type permissionCreateManyInput = {
    permission_id: number
    permission_name: string
    description?: string | null
  }

  export type permissionUpdateManyMutationInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    permission_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissionUncheckedUpdateManyInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    permission_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type questionCreateInput = {
    question: string
    quiz?: quizCreateNestedOneWithoutQuestionInput
    questionoption?: questionoptionCreateNestedManyWithoutQuestionInput
  }

  export type questionUncheckedCreateInput = {
    question_id?: number
    question: string
    quiz_id?: number | null
    questionoption?: questionoptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    quiz?: quizUpdateOneWithoutQuestionNestedInput
    questionoption?: questionoptionUpdateManyWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    quiz_id?: NullableIntFieldUpdateOperationsInput | number | null
    questionoption?: questionoptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionCreateManyInput = {
    question_id?: number
    question: string
    quiz_id?: number | null
  }

  export type questionUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
  }

  export type questionUncheckedUpdateManyInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    quiz_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type questionoptionCreateInput = {
    option: string
    is_correct: boolean
    question: questionCreateNestedOneWithoutQuestionoptionInput
  }

  export type questionoptionUncheckedCreateInput = {
    option_id?: number
    option: string
    is_correct: boolean
    question_id: number
  }

  export type questionoptionUpdateInput = {
    option?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    question?: questionUpdateOneRequiredWithoutQuestionoptionNestedInput
  }

  export type questionoptionUncheckedUpdateInput = {
    option_id?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type questionoptionCreateManyInput = {
    option_id?: number
    option: string
    is_correct: boolean
    question_id: number
  }

  export type questionoptionUpdateManyMutationInput = {
    option?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
  }

  export type questionoptionUncheckedUpdateManyInput = {
    option_id?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type quizCreateInput = {
    quiz_title: string
    description?: string | null
    checkpoint?: checkpointCreateNestedManyWithoutQuizInput
    question?: questionCreateNestedManyWithoutQuizInput
    userquizcompletion?: userquizcompletionCreateNestedManyWithoutQuizInput
  }

  export type quizUncheckedCreateInput = {
    quiz_id?: number
    quiz_title: string
    description?: string | null
    checkpoint?: checkpointUncheckedCreateNestedManyWithoutQuizInput
    question?: questionUncheckedCreateNestedManyWithoutQuizInput
    userquizcompletion?: userquizcompletionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type quizUpdateInput = {
    quiz_title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoint?: checkpointUpdateManyWithoutQuizNestedInput
    question?: questionUpdateManyWithoutQuizNestedInput
    userquizcompletion?: userquizcompletionUpdateManyWithoutQuizNestedInput
  }

  export type quizUncheckedUpdateInput = {
    quiz_id?: IntFieldUpdateOperationsInput | number
    quiz_title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoint?: checkpointUncheckedUpdateManyWithoutQuizNestedInput
    question?: questionUncheckedUpdateManyWithoutQuizNestedInput
    userquizcompletion?: userquizcompletionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type quizCreateManyInput = {
    quiz_id?: number
    quiz_title: string
    description?: string | null
  }

  export type quizUpdateManyMutationInput = {
    quiz_title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quizUncheckedUpdateManyInput = {
    quiz_id?: IntFieldUpdateOperationsInput | number
    quiz_title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reviewCreateInput = {
    review_text: string
    rating: number
    created_at?: Date | string | null
    tour: tourCreateNestedOneWithoutReviewInput
    users?: usersCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateInput = {
    review_id?: number
    user_id?: number | null
    tour_id: number
    review_text: string
    rating: number
    created_at?: Date | string | null
  }

  export type reviewUpdateInput = {
    review_text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tour?: tourUpdateOneRequiredWithoutReviewNestedInput
    users?: usersUpdateOneWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    tour_id?: IntFieldUpdateOperationsInput | number
    review_text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewCreateManyInput = {
    review_id?: number
    user_id?: number | null
    tour_id: number
    review_text: string
    rating: number
    created_at?: Date | string | null
  }

  export type reviewUpdateManyMutationInput = {
    review_text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewUncheckedUpdateManyInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    tour_id?: IntFieldUpdateOperationsInput | number
    review_text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type roleCreateInput = {
    role_id: number
    role_name: string
    description?: string | null
    rolepermission?: rolepermissionCreateNestedManyWithoutRoleInput
    userrole?: userroleCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateInput = {
    role_id: number
    role_name: string
    description?: string | null
    rolepermission?: rolepermissionUncheckedCreateNestedManyWithoutRoleInput
    userrole?: userroleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rolepermission?: rolepermissionUpdateManyWithoutRoleNestedInput
    userrole?: userroleUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rolepermission?: rolepermissionUncheckedUpdateManyWithoutRoleNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type roleCreateManyInput = {
    role_id: number
    role_name: string
    description?: string | null
  }

  export type roleUpdateManyMutationInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolepermissionCreateInput = {
    created_at?: Date | string | null
    permission: permissionCreateNestedOneWithoutRolepermissionInput
    role: roleCreateNestedOneWithoutRolepermissionInput
  }

  export type rolepermissionUncheckedCreateInput = {
    role_id: number
    permission_id: number
    created_at?: Date | string | null
  }

  export type rolepermissionUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permission?: permissionUpdateOneRequiredWithoutRolepermissionNestedInput
    role?: roleUpdateOneRequiredWithoutRolepermissionNestedInput
  }

  export type rolepermissionUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionCreateManyInput = {
    role_id: number
    permission_id: number
    created_at?: Date | string | null
  }

  export type rolepermissionUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    permission_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionsCreateInput = {
    access_token?: string | null
    is_active?: boolean | null
    login_at?: Date | string | null
    logout_at?: Date | string | null
    auditlog?: auditlogCreateNestedManyWithoutSessionsInput
    users?: usersCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateInput = {
    session_id?: number
    user_id?: number | null
    access_token?: string | null
    is_active?: boolean | null
    login_at?: Date | string | null
    logout_at?: Date | string | null
    auditlog?: auditlogUncheckedCreateNestedManyWithoutSessionsInput
  }

  export type sessionsUpdateInput = {
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logout_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUpdateManyWithoutSessionsNestedInput
    users?: usersUpdateOneWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logout_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUncheckedUpdateManyWithoutSessionsNestedInput
  }

  export type sessionsCreateManyInput = {
    session_id?: number
    user_id?: number | null
    access_token?: string | null
    is_active?: boolean | null
    login_at?: Date | string | null
    logout_at?: Date | string | null
  }

  export type sessionsUpdateManyMutationInput = {
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logout_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionsUncheckedUpdateManyInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logout_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tourCreateInput = {
    tour_name: string
    description?: string | null
    created_at?: Date | string | null
    badge?: badgeCreateNestedManyWithoutTourInput
    review?: reviewCreateNestedManyWithoutTourInput
    tourcheckpoint?: tourcheckpointCreateNestedManyWithoutTourInput
    usertourcompletion?: usertourcompletionCreateNestedManyWithoutTourInput
  }

  export type tourUncheckedCreateInput = {
    tour_id?: number
    tour_name: string
    description?: string | null
    created_at?: Date | string | null
    badge?: badgeUncheckedCreateNestedManyWithoutTourInput
    review?: reviewUncheckedCreateNestedManyWithoutTourInput
    tourcheckpoint?: tourcheckpointUncheckedCreateNestedManyWithoutTourInput
    usertourcompletion?: usertourcompletionUncheckedCreateNestedManyWithoutTourInput
  }

  export type tourUpdateInput = {
    tour_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUpdateManyWithoutTourNestedInput
    review?: reviewUpdateManyWithoutTourNestedInput
    tourcheckpoint?: tourcheckpointUpdateManyWithoutTourNestedInput
    usertourcompletion?: usertourcompletionUpdateManyWithoutTourNestedInput
  }

  export type tourUncheckedUpdateInput = {
    tour_id?: IntFieldUpdateOperationsInput | number
    tour_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUncheckedUpdateManyWithoutTourNestedInput
    review?: reviewUncheckedUpdateManyWithoutTourNestedInput
    tourcheckpoint?: tourcheckpointUncheckedUpdateManyWithoutTourNestedInput
    usertourcompletion?: usertourcompletionUncheckedUpdateManyWithoutTourNestedInput
  }

  export type tourCreateManyInput = {
    tour_id?: number
    tour_name: string
    description?: string | null
    created_at?: Date | string | null
  }

  export type tourUpdateManyMutationInput = {
    tour_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tourUncheckedUpdateManyInput = {
    tour_id?: IntFieldUpdateOperationsInput | number
    tour_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tourcheckpointCreateInput = {
    checkpoint_order: number
    checkpoint: checkpointCreateNestedOneWithoutTourcheckpointInput
    tour: tourCreateNestedOneWithoutTourcheckpointInput
  }

  export type tourcheckpointUncheckedCreateInput = {
    tour_id: number
    checkpoint_id: number
    checkpoint_order: number
  }

  export type tourcheckpointUpdateInput = {
    checkpoint_order?: IntFieldUpdateOperationsInput | number
    checkpoint?: checkpointUpdateOneRequiredWithoutTourcheckpointNestedInput
    tour?: tourUpdateOneRequiredWithoutTourcheckpointNestedInput
  }

  export type tourcheckpointUncheckedUpdateInput = {
    tour_id?: IntFieldUpdateOperationsInput | number
    checkpoint_id?: IntFieldUpdateOperationsInput | number
    checkpoint_order?: IntFieldUpdateOperationsInput | number
  }

  export type tourcheckpointCreateManyInput = {
    tour_id: number
    checkpoint_id: number
    checkpoint_order: number
  }

  export type tourcheckpointUpdateManyMutationInput = {
    checkpoint_order?: IntFieldUpdateOperationsInput | number
  }

  export type tourcheckpointUncheckedUpdateManyInput = {
    tour_id?: IntFieldUpdateOperationsInput | number
    checkpoint_id?: IntFieldUpdateOperationsInput | number
    checkpoint_order?: IntFieldUpdateOperationsInput | number
  }

  export type userbadgeCreateInput = {
    created_at?: Date | string | null
    badge: badgeCreateNestedOneWithoutUserbadgeInput
    users: usersCreateNestedOneWithoutUserbadgeInput
  }

  export type userbadgeUncheckedCreateInput = {
    badge_id: number
    user_id: number
    created_at?: Date | string | null
  }

  export type userbadgeUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUpdateOneRequiredWithoutUserbadgeNestedInput
    users?: usersUpdateOneRequiredWithoutUserbadgeNestedInput
  }

  export type userbadgeUncheckedUpdateInput = {
    badge_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userbadgeCreateManyInput = {
    badge_id: number
    user_id: number
    created_at?: Date | string | null
  }

  export type userbadgeUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userbadgeUncheckedUpdateManyInput = {
    badge_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usercheckpointattemptCreateInput = {
    created_at?: Date | string | null
    checkpoint?: checkpointCreateNestedOneWithoutUsercheckpointattemptInput
    usertourcompletion: usertourcompletionCreateNestedOneWithoutUsercheckpointattemptInput
    users: usersCreateNestedOneWithoutUsercheckpointattemptInput
  }

  export type usercheckpointattemptUncheckedCreateInput = {
    checkpointattempt_id?: number
    user_id: number
    checkpoint_id?: number | null
    tourcompletion_id: number
    created_at?: Date | string | null
  }

  export type usercheckpointattemptUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpoint?: checkpointUpdateOneWithoutUsercheckpointattemptNestedInput
    usertourcompletion?: usertourcompletionUpdateOneRequiredWithoutUsercheckpointattemptNestedInput
    users?: usersUpdateOneRequiredWithoutUsercheckpointattemptNestedInput
  }

  export type usercheckpointattemptUncheckedUpdateInput = {
    checkpointattempt_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    checkpoint_id?: NullableIntFieldUpdateOperationsInput | number | null
    tourcompletion_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usercheckpointattemptCreateManyInput = {
    checkpointattempt_id?: number
    user_id: number
    checkpoint_id?: number | null
    tourcompletion_id: number
    created_at?: Date | string | null
  }

  export type usercheckpointattemptUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usercheckpointattemptUncheckedUpdateManyInput = {
    checkpointattempt_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    checkpoint_id?: NullableIntFieldUpdateOperationsInput | number | null
    tourcompletion_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userprofileCreateInput = {
    points?: number | null
    level?: number | null
    first_name: string
    last_name: string
    school?: string | null
    sec_level: $Enums.sec_level
    created_at?: Date | string | null
    updated_at?: Date | string | null
    users: usersCreateNestedOneWithoutUserprofileInput
  }

  export type userprofileUncheckedCreateInput = {
    profile_id?: number
    user_id: number
    points?: number | null
    level?: number | null
    first_name: string
    last_name: string
    school?: string | null
    sec_level: $Enums.sec_level
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type userprofileUpdateInput = {
    points?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    school?: NullableStringFieldUpdateOperationsInput | string | null
    sec_level?: Enumsec_levelFieldUpdateOperationsInput | $Enums.sec_level
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutUserprofileNestedInput
  }

  export type userprofileUncheckedUpdateInput = {
    profile_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    points?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    school?: NullableStringFieldUpdateOperationsInput | string | null
    sec_level?: Enumsec_levelFieldUpdateOperationsInput | $Enums.sec_level
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userprofileCreateManyInput = {
    profile_id?: number
    user_id: number
    points?: number | null
    level?: number | null
    first_name: string
    last_name: string
    school?: string | null
    sec_level: $Enums.sec_level
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type userprofileUpdateManyMutationInput = {
    points?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    school?: NullableStringFieldUpdateOperationsInput | string | null
    sec_level?: Enumsec_levelFieldUpdateOperationsInput | $Enums.sec_level
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userprofileUncheckedUpdateManyInput = {
    profile_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    points?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    school?: NullableStringFieldUpdateOperationsInput | string | null
    sec_level?: Enumsec_levelFieldUpdateOperationsInput | $Enums.sec_level
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userquizcompletionCreateInput = {
    score: number
    created_at?: Date | string | null
    quiz: quizCreateNestedOneWithoutUserquizcompletionInput
    users: usersCreateNestedOneWithoutUserquizcompletionInput
  }

  export type userquizcompletionUncheckedCreateInput = {
    quizcompletion_id?: number
    quiz_id: number
    user_id: number
    score: number
    created_at?: Date | string | null
  }

  export type userquizcompletionUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiz?: quizUpdateOneRequiredWithoutUserquizcompletionNestedInput
    users?: usersUpdateOneRequiredWithoutUserquizcompletionNestedInput
  }

  export type userquizcompletionUncheckedUpdateInput = {
    quizcompletion_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userquizcompletionCreateManyInput = {
    quizcompletion_id?: number
    quiz_id: number
    user_id: number
    score: number
    created_at?: Date | string | null
  }

  export type userquizcompletionUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userquizcompletionUncheckedUpdateManyInput = {
    quizcompletion_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleCreateInput = {
    created_at?: Date | string | null
    role?: roleCreateNestedOneWithoutUserroleInput
    users: usersCreateNestedOneWithoutUserroleInput
  }

  export type userroleUncheckedCreateInput = {
    user_id: number
    role_id?: number
    created_at?: Date | string | null
  }

  export type userroleUpdateInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: roleUpdateOneRequiredWithoutUserroleNestedInput
    users?: usersUpdateOneRequiredWithoutUserroleNestedInput
  }

  export type userroleUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleCreateManyInput = {
    user_id: number
    role_id?: number
    created_at?: Date | string | null
  }

  export type userroleUpdateManyMutationInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutUsersInput
    userprofile?: userprofileCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    user_id?: number
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeUncheckedCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutUsersInput
    userprofile?: userprofileUncheckedCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUncheckedUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUncheckedUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    user_id?: number
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usertourcompletionCreateInput = {
    completed?: boolean | null
    completed_at?: Date | string | null
    created_at?: Date | string | null
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutUsertourcompletionInput
    tour?: tourCreateNestedOneWithoutUsertourcompletionInput
    users: usersCreateNestedOneWithoutUsertourcompletionInput
  }

  export type usertourcompletionUncheckedCreateInput = {
    tourcompletion_id?: number
    user_id: number
    tour_id?: number | null
    completed?: boolean | null
    completed_at?: Date | string | null
    created_at?: Date | string | null
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutUsertourcompletionInput
  }

  export type usertourcompletionUpdateInput = {
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutUsertourcompletionNestedInput
    tour?: tourUpdateOneWithoutUsertourcompletionNestedInput
    users?: usersUpdateOneRequiredWithoutUsertourcompletionNestedInput
  }

  export type usertourcompletionUncheckedUpdateInput = {
    tourcompletion_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    tour_id?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutUsertourcompletionNestedInput
  }

  export type usertourcompletionCreateManyInput = {
    tourcompletion_id?: number
    user_id: number
    tour_id?: number | null
    completed?: boolean | null
    completed_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type usertourcompletionUpdateManyMutationInput = {
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usertourcompletionUncheckedUpdateManyInput = {
    tourcompletion_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    tour_id?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AuditlogListRelationFilter = {
    every?: auditlogWhereInput
    some?: auditlogWhereInput
    none?: auditlogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type auditlogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type auditactionCountOrderByAggregateInput = {
    action_id?: SortOrder
    description?: SortOrder
  }

  export type auditactionMaxOrderByAggregateInput = {
    action_id?: SortOrder
    description?: SortOrder
  }

  export type auditactionMinOrderByAggregateInput = {
    action_id?: SortOrder
    description?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AuditactionNullableScalarRelationFilter = {
    is?: auditactionWhereInput | null
    isNot?: auditactionWhereInput | null
  }

  export type SessionsNullableScalarRelationFilter = {
    is?: sessionsWhereInput | null
    isNot?: sessionsWhereInput | null
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type auditlogCountOrderByAggregateInput = {
    log_id?: SortOrder
    user_id?: SortOrder
    session_id?: SortOrder
    action_id?: SortOrder
    target_id?: SortOrder
    target_entity?: SortOrder
    timestamp?: SortOrder
  }

  export type auditlogAvgOrderByAggregateInput = {
    log_id?: SortOrder
    user_id?: SortOrder
    session_id?: SortOrder
    target_id?: SortOrder
  }

  export type auditlogMaxOrderByAggregateInput = {
    log_id?: SortOrder
    user_id?: SortOrder
    session_id?: SortOrder
    action_id?: SortOrder
    target_id?: SortOrder
    target_entity?: SortOrder
    timestamp?: SortOrder
  }

  export type auditlogMinOrderByAggregateInput = {
    log_id?: SortOrder
    user_id?: SortOrder
    session_id?: SortOrder
    action_id?: SortOrder
    target_id?: SortOrder
    target_entity?: SortOrder
    timestamp?: SortOrder
  }

  export type auditlogSumOrderByAggregateInput = {
    log_id?: SortOrder
    user_id?: SortOrder
    session_id?: SortOrder
    target_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TourNullableScalarRelationFilter = {
    is?: tourWhereInput | null
    isNot?: tourWhereInput | null
  }

  export type UserbadgeListRelationFilter = {
    every?: userbadgeWhereInput
    some?: userbadgeWhereInput
    none?: userbadgeWhereInput
  }

  export type userbadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type badgeCountOrderByAggregateInput = {
    badge_id?: SortOrder
    tour_id?: SortOrder
    badge_title?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
  }

  export type badgeAvgOrderByAggregateInput = {
    badge_id?: SortOrder
    tour_id?: SortOrder
  }

  export type badgeMaxOrderByAggregateInput = {
    badge_id?: SortOrder
    tour_id?: SortOrder
    badge_title?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
  }

  export type badgeMinOrderByAggregateInput = {
    badge_id?: SortOrder
    tour_id?: SortOrder
    badge_title?: SortOrder
    description?: SortOrder
    image_url?: SortOrder
  }

  export type badgeSumOrderByAggregateInput = {
    badge_id?: SortOrder
    tour_id?: SortOrder
  }

  export type LocationScalarRelationFilter = {
    is?: locationWhereInput
    isNot?: locationWhereInput
  }

  export type QuizNullableScalarRelationFilter = {
    is?: quizWhereInput | null
    isNot?: quizWhereInput | null
  }

  export type TourcheckpointListRelationFilter = {
    every?: tourcheckpointWhereInput
    some?: tourcheckpointWhereInput
    none?: tourcheckpointWhereInput
  }

  export type UsercheckpointattemptListRelationFilter = {
    every?: usercheckpointattemptWhereInput
    some?: usercheckpointattemptWhereInput
    none?: usercheckpointattemptWhereInput
  }

  export type tourcheckpointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usercheckpointattemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type checkpointCountOrderByAggregateInput = {
    checkpoint_id?: SortOrder
    quiz_id?: SortOrder
    location_id?: SortOrder
    points_reward?: SortOrder
    created_at?: SortOrder
  }

  export type checkpointAvgOrderByAggregateInput = {
    checkpoint_id?: SortOrder
    quiz_id?: SortOrder
    location_id?: SortOrder
    points_reward?: SortOrder
  }

  export type checkpointMaxOrderByAggregateInput = {
    checkpoint_id?: SortOrder
    quiz_id?: SortOrder
    location_id?: SortOrder
    points_reward?: SortOrder
    created_at?: SortOrder
  }

  export type checkpointMinOrderByAggregateInput = {
    checkpoint_id?: SortOrder
    quiz_id?: SortOrder
    location_id?: SortOrder
    points_reward?: SortOrder
    created_at?: SortOrder
  }

  export type checkpointSumOrderByAggregateInput = {
    checkpoint_id?: SortOrder
    quiz_id?: SortOrder
    location_id?: SortOrder
    points_reward?: SortOrder
  }

  export type CheckpointListRelationFilter = {
    every?: checkpointWhereInput
    some?: checkpointWhereInput
    none?: checkpointWhereInput
  }

  export type LocationtypeNullableScalarRelationFilter = {
    is?: locationtypeWhereInput | null
    isNot?: locationtypeWhereInput | null
  }

  export type checkpointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type locationCountOrderByAggregateInput = {
    location_id?: SortOrder
    location_name?: SortOrder
    locationtype_id?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type locationAvgOrderByAggregateInput = {
    location_id?: SortOrder
  }

  export type locationMaxOrderByAggregateInput = {
    location_id?: SortOrder
    location_name?: SortOrder
    locationtype_id?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type locationMinOrderByAggregateInput = {
    location_id?: SortOrder
    location_name?: SortOrder
    locationtype_id?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type locationSumOrderByAggregateInput = {
    location_id?: SortOrder
  }

  export type LocationListRelationFilter = {
    every?: locationWhereInput
    some?: locationWhereInput
    none?: locationWhereInput
  }

  export type locationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type locationtypeCountOrderByAggregateInput = {
    locationtype_id?: SortOrder
    description?: SortOrder
  }

  export type locationtypeMaxOrderByAggregateInput = {
    locationtype_id?: SortOrder
    description?: SortOrder
  }

  export type locationtypeMinOrderByAggregateInput = {
    locationtype_id?: SortOrder
    description?: SortOrder
  }

  export type RolepermissionListRelationFilter = {
    every?: rolepermissionWhereInput
    some?: rolepermissionWhereInput
    none?: rolepermissionWhereInput
  }

  export type rolepermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissionCountOrderByAggregateInput = {
    permission_id?: SortOrder
    permission_name?: SortOrder
    description?: SortOrder
  }

  export type permissionAvgOrderByAggregateInput = {
    permission_id?: SortOrder
  }

  export type permissionMaxOrderByAggregateInput = {
    permission_id?: SortOrder
    permission_name?: SortOrder
    description?: SortOrder
  }

  export type permissionMinOrderByAggregateInput = {
    permission_id?: SortOrder
    permission_name?: SortOrder
    description?: SortOrder
  }

  export type permissionSumOrderByAggregateInput = {
    permission_id?: SortOrder
  }

  export type QuestionoptionListRelationFilter = {
    every?: questionoptionWhereInput
    some?: questionoptionWhereInput
    none?: questionoptionWhereInput
  }

  export type questionoptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type questionCountOrderByAggregateInput = {
    question_id?: SortOrder
    question?: SortOrder
    quiz_id?: SortOrder
  }

  export type questionAvgOrderByAggregateInput = {
    question_id?: SortOrder
    quiz_id?: SortOrder
  }

  export type questionMaxOrderByAggregateInput = {
    question_id?: SortOrder
    question?: SortOrder
    quiz_id?: SortOrder
  }

  export type questionMinOrderByAggregateInput = {
    question_id?: SortOrder
    question?: SortOrder
    quiz_id?: SortOrder
  }

  export type questionSumOrderByAggregateInput = {
    question_id?: SortOrder
    quiz_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type QuestionScalarRelationFilter = {
    is?: questionWhereInput
    isNot?: questionWhereInput
  }

  export type questionoptionCountOrderByAggregateInput = {
    option_id?: SortOrder
    option?: SortOrder
    is_correct?: SortOrder
    question_id?: SortOrder
  }

  export type questionoptionAvgOrderByAggregateInput = {
    option_id?: SortOrder
    question_id?: SortOrder
  }

  export type questionoptionMaxOrderByAggregateInput = {
    option_id?: SortOrder
    option?: SortOrder
    is_correct?: SortOrder
    question_id?: SortOrder
  }

  export type questionoptionMinOrderByAggregateInput = {
    option_id?: SortOrder
    option?: SortOrder
    is_correct?: SortOrder
    question_id?: SortOrder
  }

  export type questionoptionSumOrderByAggregateInput = {
    option_id?: SortOrder
    question_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type QuestionListRelationFilter = {
    every?: questionWhereInput
    some?: questionWhereInput
    none?: questionWhereInput
  }

  export type UserquizcompletionListRelationFilter = {
    every?: userquizcompletionWhereInput
    some?: userquizcompletionWhereInput
    none?: userquizcompletionWhereInput
  }

  export type questionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userquizcompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quizCountOrderByAggregateInput = {
    quiz_id?: SortOrder
    quiz_title?: SortOrder
    description?: SortOrder
  }

  export type quizAvgOrderByAggregateInput = {
    quiz_id?: SortOrder
  }

  export type quizMaxOrderByAggregateInput = {
    quiz_id?: SortOrder
    quiz_title?: SortOrder
    description?: SortOrder
  }

  export type quizMinOrderByAggregateInput = {
    quiz_id?: SortOrder
    quiz_title?: SortOrder
    description?: SortOrder
  }

  export type quizSumOrderByAggregateInput = {
    quiz_id?: SortOrder
  }

  export type TourScalarRelationFilter = {
    is?: tourWhereInput
    isNot?: tourWhereInput
  }

  export type reviewCountOrderByAggregateInput = {
    review_id?: SortOrder
    user_id?: SortOrder
    tour_id?: SortOrder
    review_text?: SortOrder
    rating?: SortOrder
    created_at?: SortOrder
  }

  export type reviewAvgOrderByAggregateInput = {
    review_id?: SortOrder
    user_id?: SortOrder
    tour_id?: SortOrder
    rating?: SortOrder
  }

  export type reviewMaxOrderByAggregateInput = {
    review_id?: SortOrder
    user_id?: SortOrder
    tour_id?: SortOrder
    review_text?: SortOrder
    rating?: SortOrder
    created_at?: SortOrder
  }

  export type reviewMinOrderByAggregateInput = {
    review_id?: SortOrder
    user_id?: SortOrder
    tour_id?: SortOrder
    review_text?: SortOrder
    rating?: SortOrder
    created_at?: SortOrder
  }

  export type reviewSumOrderByAggregateInput = {
    review_id?: SortOrder
    user_id?: SortOrder
    tour_id?: SortOrder
    rating?: SortOrder
  }

  export type UserroleListRelationFilter = {
    every?: userroleWhereInput
    some?: userroleWhereInput
    none?: userroleWhereInput
  }

  export type userroleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roleCountOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    description?: SortOrder
  }

  export type roleAvgOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type roleMaxOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    description?: SortOrder
  }

  export type roleMinOrderByAggregateInput = {
    role_id?: SortOrder
    role_name?: SortOrder
    description?: SortOrder
  }

  export type roleSumOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type PermissionScalarRelationFilter = {
    is?: permissionWhereInput
    isNot?: permissionWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: roleWhereInput
    isNot?: roleWhereInput
  }

  export type rolepermissionRole_idPermission_idCompoundUniqueInput = {
    role_id: number
    permission_id: number
  }

  export type rolepermissionCountOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
    created_at?: SortOrder
  }

  export type rolepermissionAvgOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type rolepermissionMaxOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
    created_at?: SortOrder
  }

  export type rolepermissionMinOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
    created_at?: SortOrder
  }

  export type rolepermissionSumOrderByAggregateInput = {
    role_id?: SortOrder
    permission_id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type sessionsCountOrderByAggregateInput = {
    session_id?: SortOrder
    user_id?: SortOrder
    access_token?: SortOrder
    is_active?: SortOrder
    login_at?: SortOrder
    logout_at?: SortOrder
  }

  export type sessionsAvgOrderByAggregateInput = {
    session_id?: SortOrder
    user_id?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    session_id?: SortOrder
    user_id?: SortOrder
    access_token?: SortOrder
    is_active?: SortOrder
    login_at?: SortOrder
    logout_at?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    session_id?: SortOrder
    user_id?: SortOrder
    access_token?: SortOrder
    is_active?: SortOrder
    login_at?: SortOrder
    logout_at?: SortOrder
  }

  export type sessionsSumOrderByAggregateInput = {
    session_id?: SortOrder
    user_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BadgeListRelationFilter = {
    every?: badgeWhereInput
    some?: badgeWhereInput
    none?: badgeWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: reviewWhereInput
    some?: reviewWhereInput
    none?: reviewWhereInput
  }

  export type UsertourcompletionListRelationFilter = {
    every?: usertourcompletionWhereInput
    some?: usertourcompletionWhereInput
    none?: usertourcompletionWhereInput
  }

  export type badgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usertourcompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tourCountOrderByAggregateInput = {
    tour_id?: SortOrder
    tour_name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type tourAvgOrderByAggregateInput = {
    tour_id?: SortOrder
  }

  export type tourMaxOrderByAggregateInput = {
    tour_id?: SortOrder
    tour_name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type tourMinOrderByAggregateInput = {
    tour_id?: SortOrder
    tour_name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type tourSumOrderByAggregateInput = {
    tour_id?: SortOrder
  }

  export type CheckpointScalarRelationFilter = {
    is?: checkpointWhereInput
    isNot?: checkpointWhereInput
  }

  export type tourcheckpointTour_idCheckpoint_idCompoundUniqueInput = {
    tour_id: number
    checkpoint_id: number
  }

  export type tourcheckpointCountOrderByAggregateInput = {
    tour_id?: SortOrder
    checkpoint_id?: SortOrder
    checkpoint_order?: SortOrder
  }

  export type tourcheckpointAvgOrderByAggregateInput = {
    tour_id?: SortOrder
    checkpoint_id?: SortOrder
    checkpoint_order?: SortOrder
  }

  export type tourcheckpointMaxOrderByAggregateInput = {
    tour_id?: SortOrder
    checkpoint_id?: SortOrder
    checkpoint_order?: SortOrder
  }

  export type tourcheckpointMinOrderByAggregateInput = {
    tour_id?: SortOrder
    checkpoint_id?: SortOrder
    checkpoint_order?: SortOrder
  }

  export type tourcheckpointSumOrderByAggregateInput = {
    tour_id?: SortOrder
    checkpoint_id?: SortOrder
    checkpoint_order?: SortOrder
  }

  export type BadgeScalarRelationFilter = {
    is?: badgeWhereInput
    isNot?: badgeWhereInput
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type userbadgeBadge_idUser_idCompoundUniqueInput = {
    badge_id: number
    user_id: number
  }

  export type userbadgeCountOrderByAggregateInput = {
    badge_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
  }

  export type userbadgeAvgOrderByAggregateInput = {
    badge_id?: SortOrder
    user_id?: SortOrder
  }

  export type userbadgeMaxOrderByAggregateInput = {
    badge_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
  }

  export type userbadgeMinOrderByAggregateInput = {
    badge_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
  }

  export type userbadgeSumOrderByAggregateInput = {
    badge_id?: SortOrder
    user_id?: SortOrder
  }

  export type CheckpointNullableScalarRelationFilter = {
    is?: checkpointWhereInput | null
    isNot?: checkpointWhereInput | null
  }

  export type UsertourcompletionScalarRelationFilter = {
    is?: usertourcompletionWhereInput
    isNot?: usertourcompletionWhereInput
  }

  export type usercheckpointattemptCountOrderByAggregateInput = {
    checkpointattempt_id?: SortOrder
    user_id?: SortOrder
    checkpoint_id?: SortOrder
    tourcompletion_id?: SortOrder
    created_at?: SortOrder
  }

  export type usercheckpointattemptAvgOrderByAggregateInput = {
    checkpointattempt_id?: SortOrder
    user_id?: SortOrder
    checkpoint_id?: SortOrder
    tourcompletion_id?: SortOrder
  }

  export type usercheckpointattemptMaxOrderByAggregateInput = {
    checkpointattempt_id?: SortOrder
    user_id?: SortOrder
    checkpoint_id?: SortOrder
    tourcompletion_id?: SortOrder
    created_at?: SortOrder
  }

  export type usercheckpointattemptMinOrderByAggregateInput = {
    checkpointattempt_id?: SortOrder
    user_id?: SortOrder
    checkpoint_id?: SortOrder
    tourcompletion_id?: SortOrder
    created_at?: SortOrder
  }

  export type usercheckpointattemptSumOrderByAggregateInput = {
    checkpointattempt_id?: SortOrder
    user_id?: SortOrder
    checkpoint_id?: SortOrder
    tourcompletion_id?: SortOrder
  }

  export type Enumsec_levelFilter<$PrismaModel = never> = {
    equals?: $Enums.sec_level | Enumsec_levelFieldRefInput<$PrismaModel>
    in?: $Enums.sec_level[] | ListEnumsec_levelFieldRefInput<$PrismaModel>
    notIn?: $Enums.sec_level[] | ListEnumsec_levelFieldRefInput<$PrismaModel>
    not?: NestedEnumsec_levelFilter<$PrismaModel> | $Enums.sec_level
  }

  export type userprofileCountOrderByAggregateInput = {
    profile_id?: SortOrder
    user_id?: SortOrder
    points?: SortOrder
    level?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    school?: SortOrder
    sec_level?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type userprofileAvgOrderByAggregateInput = {
    profile_id?: SortOrder
    user_id?: SortOrder
    points?: SortOrder
    level?: SortOrder
  }

  export type userprofileMaxOrderByAggregateInput = {
    profile_id?: SortOrder
    user_id?: SortOrder
    points?: SortOrder
    level?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    school?: SortOrder
    sec_level?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type userprofileMinOrderByAggregateInput = {
    profile_id?: SortOrder
    user_id?: SortOrder
    points?: SortOrder
    level?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    school?: SortOrder
    sec_level?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type userprofileSumOrderByAggregateInput = {
    profile_id?: SortOrder
    user_id?: SortOrder
    points?: SortOrder
    level?: SortOrder
  }

  export type Enumsec_levelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.sec_level | Enumsec_levelFieldRefInput<$PrismaModel>
    in?: $Enums.sec_level[] | ListEnumsec_levelFieldRefInput<$PrismaModel>
    notIn?: $Enums.sec_level[] | ListEnumsec_levelFieldRefInput<$PrismaModel>
    not?: NestedEnumsec_levelWithAggregatesFilter<$PrismaModel> | $Enums.sec_level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsec_levelFilter<$PrismaModel>
    _max?: NestedEnumsec_levelFilter<$PrismaModel>
  }

  export type QuizScalarRelationFilter = {
    is?: quizWhereInput
    isNot?: quizWhereInput
  }

  export type userquizcompletionCountOrderByAggregateInput = {
    quizcompletion_id?: SortOrder
    quiz_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
    created_at?: SortOrder
  }

  export type userquizcompletionAvgOrderByAggregateInput = {
    quizcompletion_id?: SortOrder
    quiz_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
  }

  export type userquizcompletionMaxOrderByAggregateInput = {
    quizcompletion_id?: SortOrder
    quiz_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
    created_at?: SortOrder
  }

  export type userquizcompletionMinOrderByAggregateInput = {
    quizcompletion_id?: SortOrder
    quiz_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
    created_at?: SortOrder
  }

  export type userquizcompletionSumOrderByAggregateInput = {
    quizcompletion_id?: SortOrder
    quiz_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
  }

  export type userroleUser_idRole_idCompoundUniqueInput = {
    user_id: number
    role_id: number
  }

  export type userroleCountOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
  }

  export type userroleAvgOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type userroleMaxOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
  }

  export type userroleMinOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
    created_at?: SortOrder
  }

  export type userroleSumOrderByAggregateInput = {
    user_id?: SortOrder
    role_id?: SortOrder
  }

  export type SessionsListRelationFilter = {
    every?: sessionsWhereInput
    some?: sessionsWhereInput
    none?: sessionsWhereInput
  }

  export type UserprofileNullableScalarRelationFilter = {
    is?: userprofileWhereInput | null
    isNot?: userprofileWhereInput | null
  }

  export type UserroleNullableScalarRelationFilter = {
    is?: userroleWhereInput | null
    isNot?: userroleWhereInput | null
  }

  export type sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    is_verified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    is_verified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    user_id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    is_verified?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type usertourcompletionCountOrderByAggregateInput = {
    tourcompletion_id?: SortOrder
    user_id?: SortOrder
    tour_id?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
  }

  export type usertourcompletionAvgOrderByAggregateInput = {
    tourcompletion_id?: SortOrder
    user_id?: SortOrder
    tour_id?: SortOrder
  }

  export type usertourcompletionMaxOrderByAggregateInput = {
    tourcompletion_id?: SortOrder
    user_id?: SortOrder
    tour_id?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
  }

  export type usertourcompletionMinOrderByAggregateInput = {
    tourcompletion_id?: SortOrder
    user_id?: SortOrder
    tour_id?: SortOrder
    completed?: SortOrder
    completed_at?: SortOrder
    created_at?: SortOrder
  }

  export type usertourcompletionSumOrderByAggregateInput = {
    tourcompletion_id?: SortOrder
    user_id?: SortOrder
    tour_id?: SortOrder
  }

  export type auditlogCreateNestedManyWithoutAuditactionInput = {
    create?: XOR<auditlogCreateWithoutAuditactionInput, auditlogUncheckedCreateWithoutAuditactionInput> | auditlogCreateWithoutAuditactionInput[] | auditlogUncheckedCreateWithoutAuditactionInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutAuditactionInput | auditlogCreateOrConnectWithoutAuditactionInput[]
    createMany?: auditlogCreateManyAuditactionInputEnvelope
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
  }

  export type auditlogUncheckedCreateNestedManyWithoutAuditactionInput = {
    create?: XOR<auditlogCreateWithoutAuditactionInput, auditlogUncheckedCreateWithoutAuditactionInput> | auditlogCreateWithoutAuditactionInput[] | auditlogUncheckedCreateWithoutAuditactionInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutAuditactionInput | auditlogCreateOrConnectWithoutAuditactionInput[]
    createMany?: auditlogCreateManyAuditactionInputEnvelope
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type auditlogUpdateManyWithoutAuditactionNestedInput = {
    create?: XOR<auditlogCreateWithoutAuditactionInput, auditlogUncheckedCreateWithoutAuditactionInput> | auditlogCreateWithoutAuditactionInput[] | auditlogUncheckedCreateWithoutAuditactionInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutAuditactionInput | auditlogCreateOrConnectWithoutAuditactionInput[]
    upsert?: auditlogUpsertWithWhereUniqueWithoutAuditactionInput | auditlogUpsertWithWhereUniqueWithoutAuditactionInput[]
    createMany?: auditlogCreateManyAuditactionInputEnvelope
    set?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    disconnect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    delete?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    update?: auditlogUpdateWithWhereUniqueWithoutAuditactionInput | auditlogUpdateWithWhereUniqueWithoutAuditactionInput[]
    updateMany?: auditlogUpdateManyWithWhereWithoutAuditactionInput | auditlogUpdateManyWithWhereWithoutAuditactionInput[]
    deleteMany?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
  }

  export type auditlogUncheckedUpdateManyWithoutAuditactionNestedInput = {
    create?: XOR<auditlogCreateWithoutAuditactionInput, auditlogUncheckedCreateWithoutAuditactionInput> | auditlogCreateWithoutAuditactionInput[] | auditlogUncheckedCreateWithoutAuditactionInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutAuditactionInput | auditlogCreateOrConnectWithoutAuditactionInput[]
    upsert?: auditlogUpsertWithWhereUniqueWithoutAuditactionInput | auditlogUpsertWithWhereUniqueWithoutAuditactionInput[]
    createMany?: auditlogCreateManyAuditactionInputEnvelope
    set?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    disconnect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    delete?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    update?: auditlogUpdateWithWhereUniqueWithoutAuditactionInput | auditlogUpdateWithWhereUniqueWithoutAuditactionInput[]
    updateMany?: auditlogUpdateManyWithWhereWithoutAuditactionInput | auditlogUpdateManyWithWhereWithoutAuditactionInput[]
    deleteMany?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
  }

  export type auditactionCreateNestedOneWithoutAuditlogInput = {
    create?: XOR<auditactionCreateWithoutAuditlogInput, auditactionUncheckedCreateWithoutAuditlogInput>
    connectOrCreate?: auditactionCreateOrConnectWithoutAuditlogInput
    connect?: auditactionWhereUniqueInput
  }

  export type sessionsCreateNestedOneWithoutAuditlogInput = {
    create?: XOR<sessionsCreateWithoutAuditlogInput, sessionsUncheckedCreateWithoutAuditlogInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutAuditlogInput
    connect?: sessionsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutAuditlogInput = {
    create?: XOR<usersCreateWithoutAuditlogInput, usersUncheckedCreateWithoutAuditlogInput>
    connectOrCreate?: usersCreateOrConnectWithoutAuditlogInput
    connect?: usersWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type auditactionUpdateOneWithoutAuditlogNestedInput = {
    create?: XOR<auditactionCreateWithoutAuditlogInput, auditactionUncheckedCreateWithoutAuditlogInput>
    connectOrCreate?: auditactionCreateOrConnectWithoutAuditlogInput
    upsert?: auditactionUpsertWithoutAuditlogInput
    disconnect?: auditactionWhereInput | boolean
    delete?: auditactionWhereInput | boolean
    connect?: auditactionWhereUniqueInput
    update?: XOR<XOR<auditactionUpdateToOneWithWhereWithoutAuditlogInput, auditactionUpdateWithoutAuditlogInput>, auditactionUncheckedUpdateWithoutAuditlogInput>
  }

  export type sessionsUpdateOneWithoutAuditlogNestedInput = {
    create?: XOR<sessionsCreateWithoutAuditlogInput, sessionsUncheckedCreateWithoutAuditlogInput>
    connectOrCreate?: sessionsCreateOrConnectWithoutAuditlogInput
    upsert?: sessionsUpsertWithoutAuditlogInput
    disconnect?: sessionsWhereInput | boolean
    delete?: sessionsWhereInput | boolean
    connect?: sessionsWhereUniqueInput
    update?: XOR<XOR<sessionsUpdateToOneWithWhereWithoutAuditlogInput, sessionsUpdateWithoutAuditlogInput>, sessionsUncheckedUpdateWithoutAuditlogInput>
  }

  export type usersUpdateOneWithoutAuditlogNestedInput = {
    create?: XOR<usersCreateWithoutAuditlogInput, usersUncheckedCreateWithoutAuditlogInput>
    connectOrCreate?: usersCreateOrConnectWithoutAuditlogInput
    upsert?: usersUpsertWithoutAuditlogInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAuditlogInput, usersUpdateWithoutAuditlogInput>, usersUncheckedUpdateWithoutAuditlogInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type tourCreateNestedOneWithoutBadgeInput = {
    create?: XOR<tourCreateWithoutBadgeInput, tourUncheckedCreateWithoutBadgeInput>
    connectOrCreate?: tourCreateOrConnectWithoutBadgeInput
    connect?: tourWhereUniqueInput
  }

  export type userbadgeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<userbadgeCreateWithoutBadgeInput, userbadgeUncheckedCreateWithoutBadgeInput> | userbadgeCreateWithoutBadgeInput[] | userbadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: userbadgeCreateOrConnectWithoutBadgeInput | userbadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: userbadgeCreateManyBadgeInputEnvelope
    connect?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
  }

  export type userbadgeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<userbadgeCreateWithoutBadgeInput, userbadgeUncheckedCreateWithoutBadgeInput> | userbadgeCreateWithoutBadgeInput[] | userbadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: userbadgeCreateOrConnectWithoutBadgeInput | userbadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: userbadgeCreateManyBadgeInputEnvelope
    connect?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
  }

  export type tourUpdateOneWithoutBadgeNestedInput = {
    create?: XOR<tourCreateWithoutBadgeInput, tourUncheckedCreateWithoutBadgeInput>
    connectOrCreate?: tourCreateOrConnectWithoutBadgeInput
    upsert?: tourUpsertWithoutBadgeInput
    disconnect?: tourWhereInput | boolean
    delete?: tourWhereInput | boolean
    connect?: tourWhereUniqueInput
    update?: XOR<XOR<tourUpdateToOneWithWhereWithoutBadgeInput, tourUpdateWithoutBadgeInput>, tourUncheckedUpdateWithoutBadgeInput>
  }

  export type userbadgeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<userbadgeCreateWithoutBadgeInput, userbadgeUncheckedCreateWithoutBadgeInput> | userbadgeCreateWithoutBadgeInput[] | userbadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: userbadgeCreateOrConnectWithoutBadgeInput | userbadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: userbadgeUpsertWithWhereUniqueWithoutBadgeInput | userbadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: userbadgeCreateManyBadgeInputEnvelope
    set?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    disconnect?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    delete?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    connect?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    update?: userbadgeUpdateWithWhereUniqueWithoutBadgeInput | userbadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: userbadgeUpdateManyWithWhereWithoutBadgeInput | userbadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: userbadgeScalarWhereInput | userbadgeScalarWhereInput[]
  }

  export type userbadgeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<userbadgeCreateWithoutBadgeInput, userbadgeUncheckedCreateWithoutBadgeInput> | userbadgeCreateWithoutBadgeInput[] | userbadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: userbadgeCreateOrConnectWithoutBadgeInput | userbadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: userbadgeUpsertWithWhereUniqueWithoutBadgeInput | userbadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: userbadgeCreateManyBadgeInputEnvelope
    set?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    disconnect?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    delete?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    connect?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    update?: userbadgeUpdateWithWhereUniqueWithoutBadgeInput | userbadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: userbadgeUpdateManyWithWhereWithoutBadgeInput | userbadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: userbadgeScalarWhereInput | userbadgeScalarWhereInput[]
  }

  export type locationCreateNestedOneWithoutCheckpointInput = {
    create?: XOR<locationCreateWithoutCheckpointInput, locationUncheckedCreateWithoutCheckpointInput>
    connectOrCreate?: locationCreateOrConnectWithoutCheckpointInput
    connect?: locationWhereUniqueInput
  }

  export type quizCreateNestedOneWithoutCheckpointInput = {
    create?: XOR<quizCreateWithoutCheckpointInput, quizUncheckedCreateWithoutCheckpointInput>
    connectOrCreate?: quizCreateOrConnectWithoutCheckpointInput
    connect?: quizWhereUniqueInput
  }

  export type tourcheckpointCreateNestedManyWithoutCheckpointInput = {
    create?: XOR<tourcheckpointCreateWithoutCheckpointInput, tourcheckpointUncheckedCreateWithoutCheckpointInput> | tourcheckpointCreateWithoutCheckpointInput[] | tourcheckpointUncheckedCreateWithoutCheckpointInput[]
    connectOrCreate?: tourcheckpointCreateOrConnectWithoutCheckpointInput | tourcheckpointCreateOrConnectWithoutCheckpointInput[]
    createMany?: tourcheckpointCreateManyCheckpointInputEnvelope
    connect?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
  }

  export type usercheckpointattemptCreateNestedManyWithoutCheckpointInput = {
    create?: XOR<usercheckpointattemptCreateWithoutCheckpointInput, usercheckpointattemptUncheckedCreateWithoutCheckpointInput> | usercheckpointattemptCreateWithoutCheckpointInput[] | usercheckpointattemptUncheckedCreateWithoutCheckpointInput[]
    connectOrCreate?: usercheckpointattemptCreateOrConnectWithoutCheckpointInput | usercheckpointattemptCreateOrConnectWithoutCheckpointInput[]
    createMany?: usercheckpointattemptCreateManyCheckpointInputEnvelope
    connect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
  }

  export type tourcheckpointUncheckedCreateNestedManyWithoutCheckpointInput = {
    create?: XOR<tourcheckpointCreateWithoutCheckpointInput, tourcheckpointUncheckedCreateWithoutCheckpointInput> | tourcheckpointCreateWithoutCheckpointInput[] | tourcheckpointUncheckedCreateWithoutCheckpointInput[]
    connectOrCreate?: tourcheckpointCreateOrConnectWithoutCheckpointInput | tourcheckpointCreateOrConnectWithoutCheckpointInput[]
    createMany?: tourcheckpointCreateManyCheckpointInputEnvelope
    connect?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
  }

  export type usercheckpointattemptUncheckedCreateNestedManyWithoutCheckpointInput = {
    create?: XOR<usercheckpointattemptCreateWithoutCheckpointInput, usercheckpointattemptUncheckedCreateWithoutCheckpointInput> | usercheckpointattemptCreateWithoutCheckpointInput[] | usercheckpointattemptUncheckedCreateWithoutCheckpointInput[]
    connectOrCreate?: usercheckpointattemptCreateOrConnectWithoutCheckpointInput | usercheckpointattemptCreateOrConnectWithoutCheckpointInput[]
    createMany?: usercheckpointattemptCreateManyCheckpointInputEnvelope
    connect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
  }

  export type locationUpdateOneRequiredWithoutCheckpointNestedInput = {
    create?: XOR<locationCreateWithoutCheckpointInput, locationUncheckedCreateWithoutCheckpointInput>
    connectOrCreate?: locationCreateOrConnectWithoutCheckpointInput
    upsert?: locationUpsertWithoutCheckpointInput
    connect?: locationWhereUniqueInput
    update?: XOR<XOR<locationUpdateToOneWithWhereWithoutCheckpointInput, locationUpdateWithoutCheckpointInput>, locationUncheckedUpdateWithoutCheckpointInput>
  }

  export type quizUpdateOneWithoutCheckpointNestedInput = {
    create?: XOR<quizCreateWithoutCheckpointInput, quizUncheckedCreateWithoutCheckpointInput>
    connectOrCreate?: quizCreateOrConnectWithoutCheckpointInput
    upsert?: quizUpsertWithoutCheckpointInput
    disconnect?: quizWhereInput | boolean
    delete?: quizWhereInput | boolean
    connect?: quizWhereUniqueInput
    update?: XOR<XOR<quizUpdateToOneWithWhereWithoutCheckpointInput, quizUpdateWithoutCheckpointInput>, quizUncheckedUpdateWithoutCheckpointInput>
  }

  export type tourcheckpointUpdateManyWithoutCheckpointNestedInput = {
    create?: XOR<tourcheckpointCreateWithoutCheckpointInput, tourcheckpointUncheckedCreateWithoutCheckpointInput> | tourcheckpointCreateWithoutCheckpointInput[] | tourcheckpointUncheckedCreateWithoutCheckpointInput[]
    connectOrCreate?: tourcheckpointCreateOrConnectWithoutCheckpointInput | tourcheckpointCreateOrConnectWithoutCheckpointInput[]
    upsert?: tourcheckpointUpsertWithWhereUniqueWithoutCheckpointInput | tourcheckpointUpsertWithWhereUniqueWithoutCheckpointInput[]
    createMany?: tourcheckpointCreateManyCheckpointInputEnvelope
    set?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    disconnect?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    delete?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    connect?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    update?: tourcheckpointUpdateWithWhereUniqueWithoutCheckpointInput | tourcheckpointUpdateWithWhereUniqueWithoutCheckpointInput[]
    updateMany?: tourcheckpointUpdateManyWithWhereWithoutCheckpointInput | tourcheckpointUpdateManyWithWhereWithoutCheckpointInput[]
    deleteMany?: tourcheckpointScalarWhereInput | tourcheckpointScalarWhereInput[]
  }

  export type usercheckpointattemptUpdateManyWithoutCheckpointNestedInput = {
    create?: XOR<usercheckpointattemptCreateWithoutCheckpointInput, usercheckpointattemptUncheckedCreateWithoutCheckpointInput> | usercheckpointattemptCreateWithoutCheckpointInput[] | usercheckpointattemptUncheckedCreateWithoutCheckpointInput[]
    connectOrCreate?: usercheckpointattemptCreateOrConnectWithoutCheckpointInput | usercheckpointattemptCreateOrConnectWithoutCheckpointInput[]
    upsert?: usercheckpointattemptUpsertWithWhereUniqueWithoutCheckpointInput | usercheckpointattemptUpsertWithWhereUniqueWithoutCheckpointInput[]
    createMany?: usercheckpointattemptCreateManyCheckpointInputEnvelope
    set?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    disconnect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    delete?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    connect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    update?: usercheckpointattemptUpdateWithWhereUniqueWithoutCheckpointInput | usercheckpointattemptUpdateWithWhereUniqueWithoutCheckpointInput[]
    updateMany?: usercheckpointattemptUpdateManyWithWhereWithoutCheckpointInput | usercheckpointattemptUpdateManyWithWhereWithoutCheckpointInput[]
    deleteMany?: usercheckpointattemptScalarWhereInput | usercheckpointattemptScalarWhereInput[]
  }

  export type tourcheckpointUncheckedUpdateManyWithoutCheckpointNestedInput = {
    create?: XOR<tourcheckpointCreateWithoutCheckpointInput, tourcheckpointUncheckedCreateWithoutCheckpointInput> | tourcheckpointCreateWithoutCheckpointInput[] | tourcheckpointUncheckedCreateWithoutCheckpointInput[]
    connectOrCreate?: tourcheckpointCreateOrConnectWithoutCheckpointInput | tourcheckpointCreateOrConnectWithoutCheckpointInput[]
    upsert?: tourcheckpointUpsertWithWhereUniqueWithoutCheckpointInput | tourcheckpointUpsertWithWhereUniqueWithoutCheckpointInput[]
    createMany?: tourcheckpointCreateManyCheckpointInputEnvelope
    set?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    disconnect?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    delete?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    connect?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    update?: tourcheckpointUpdateWithWhereUniqueWithoutCheckpointInput | tourcheckpointUpdateWithWhereUniqueWithoutCheckpointInput[]
    updateMany?: tourcheckpointUpdateManyWithWhereWithoutCheckpointInput | tourcheckpointUpdateManyWithWhereWithoutCheckpointInput[]
    deleteMany?: tourcheckpointScalarWhereInput | tourcheckpointScalarWhereInput[]
  }

  export type usercheckpointattemptUncheckedUpdateManyWithoutCheckpointNestedInput = {
    create?: XOR<usercheckpointattemptCreateWithoutCheckpointInput, usercheckpointattemptUncheckedCreateWithoutCheckpointInput> | usercheckpointattemptCreateWithoutCheckpointInput[] | usercheckpointattemptUncheckedCreateWithoutCheckpointInput[]
    connectOrCreate?: usercheckpointattemptCreateOrConnectWithoutCheckpointInput | usercheckpointattemptCreateOrConnectWithoutCheckpointInput[]
    upsert?: usercheckpointattemptUpsertWithWhereUniqueWithoutCheckpointInput | usercheckpointattemptUpsertWithWhereUniqueWithoutCheckpointInput[]
    createMany?: usercheckpointattemptCreateManyCheckpointInputEnvelope
    set?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    disconnect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    delete?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    connect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    update?: usercheckpointattemptUpdateWithWhereUniqueWithoutCheckpointInput | usercheckpointattemptUpdateWithWhereUniqueWithoutCheckpointInput[]
    updateMany?: usercheckpointattemptUpdateManyWithWhereWithoutCheckpointInput | usercheckpointattemptUpdateManyWithWhereWithoutCheckpointInput[]
    deleteMany?: usercheckpointattemptScalarWhereInput | usercheckpointattemptScalarWhereInput[]
  }

  export type checkpointCreateNestedManyWithoutLocationInput = {
    create?: XOR<checkpointCreateWithoutLocationInput, checkpointUncheckedCreateWithoutLocationInput> | checkpointCreateWithoutLocationInput[] | checkpointUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: checkpointCreateOrConnectWithoutLocationInput | checkpointCreateOrConnectWithoutLocationInput[]
    createMany?: checkpointCreateManyLocationInputEnvelope
    connect?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
  }

  export type locationtypeCreateNestedOneWithoutLocationInput = {
    create?: XOR<locationtypeCreateWithoutLocationInput, locationtypeUncheckedCreateWithoutLocationInput>
    connectOrCreate?: locationtypeCreateOrConnectWithoutLocationInput
    connect?: locationtypeWhereUniqueInput
  }

  export type checkpointUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<checkpointCreateWithoutLocationInput, checkpointUncheckedCreateWithoutLocationInput> | checkpointCreateWithoutLocationInput[] | checkpointUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: checkpointCreateOrConnectWithoutLocationInput | checkpointCreateOrConnectWithoutLocationInput[]
    createMany?: checkpointCreateManyLocationInputEnvelope
    connect?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
  }

  export type checkpointUpdateManyWithoutLocationNestedInput = {
    create?: XOR<checkpointCreateWithoutLocationInput, checkpointUncheckedCreateWithoutLocationInput> | checkpointCreateWithoutLocationInput[] | checkpointUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: checkpointCreateOrConnectWithoutLocationInput | checkpointCreateOrConnectWithoutLocationInput[]
    upsert?: checkpointUpsertWithWhereUniqueWithoutLocationInput | checkpointUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: checkpointCreateManyLocationInputEnvelope
    set?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    disconnect?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    delete?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    connect?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    update?: checkpointUpdateWithWhereUniqueWithoutLocationInput | checkpointUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: checkpointUpdateManyWithWhereWithoutLocationInput | checkpointUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: checkpointScalarWhereInput | checkpointScalarWhereInput[]
  }

  export type locationtypeUpdateOneWithoutLocationNestedInput = {
    create?: XOR<locationtypeCreateWithoutLocationInput, locationtypeUncheckedCreateWithoutLocationInput>
    connectOrCreate?: locationtypeCreateOrConnectWithoutLocationInput
    upsert?: locationtypeUpsertWithoutLocationInput
    disconnect?: locationtypeWhereInput | boolean
    delete?: locationtypeWhereInput | boolean
    connect?: locationtypeWhereUniqueInput
    update?: XOR<XOR<locationtypeUpdateToOneWithWhereWithoutLocationInput, locationtypeUpdateWithoutLocationInput>, locationtypeUncheckedUpdateWithoutLocationInput>
  }

  export type checkpointUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<checkpointCreateWithoutLocationInput, checkpointUncheckedCreateWithoutLocationInput> | checkpointCreateWithoutLocationInput[] | checkpointUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: checkpointCreateOrConnectWithoutLocationInput | checkpointCreateOrConnectWithoutLocationInput[]
    upsert?: checkpointUpsertWithWhereUniqueWithoutLocationInput | checkpointUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: checkpointCreateManyLocationInputEnvelope
    set?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    disconnect?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    delete?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    connect?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    update?: checkpointUpdateWithWhereUniqueWithoutLocationInput | checkpointUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: checkpointUpdateManyWithWhereWithoutLocationInput | checkpointUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: checkpointScalarWhereInput | checkpointScalarWhereInput[]
  }

  export type locationCreateNestedManyWithoutLocationtypeInput = {
    create?: XOR<locationCreateWithoutLocationtypeInput, locationUncheckedCreateWithoutLocationtypeInput> | locationCreateWithoutLocationtypeInput[] | locationUncheckedCreateWithoutLocationtypeInput[]
    connectOrCreate?: locationCreateOrConnectWithoutLocationtypeInput | locationCreateOrConnectWithoutLocationtypeInput[]
    createMany?: locationCreateManyLocationtypeInputEnvelope
    connect?: locationWhereUniqueInput | locationWhereUniqueInput[]
  }

  export type locationUncheckedCreateNestedManyWithoutLocationtypeInput = {
    create?: XOR<locationCreateWithoutLocationtypeInput, locationUncheckedCreateWithoutLocationtypeInput> | locationCreateWithoutLocationtypeInput[] | locationUncheckedCreateWithoutLocationtypeInput[]
    connectOrCreate?: locationCreateOrConnectWithoutLocationtypeInput | locationCreateOrConnectWithoutLocationtypeInput[]
    createMany?: locationCreateManyLocationtypeInputEnvelope
    connect?: locationWhereUniqueInput | locationWhereUniqueInput[]
  }

  export type locationUpdateManyWithoutLocationtypeNestedInput = {
    create?: XOR<locationCreateWithoutLocationtypeInput, locationUncheckedCreateWithoutLocationtypeInput> | locationCreateWithoutLocationtypeInput[] | locationUncheckedCreateWithoutLocationtypeInput[]
    connectOrCreate?: locationCreateOrConnectWithoutLocationtypeInput | locationCreateOrConnectWithoutLocationtypeInput[]
    upsert?: locationUpsertWithWhereUniqueWithoutLocationtypeInput | locationUpsertWithWhereUniqueWithoutLocationtypeInput[]
    createMany?: locationCreateManyLocationtypeInputEnvelope
    set?: locationWhereUniqueInput | locationWhereUniqueInput[]
    disconnect?: locationWhereUniqueInput | locationWhereUniqueInput[]
    delete?: locationWhereUniqueInput | locationWhereUniqueInput[]
    connect?: locationWhereUniqueInput | locationWhereUniqueInput[]
    update?: locationUpdateWithWhereUniqueWithoutLocationtypeInput | locationUpdateWithWhereUniqueWithoutLocationtypeInput[]
    updateMany?: locationUpdateManyWithWhereWithoutLocationtypeInput | locationUpdateManyWithWhereWithoutLocationtypeInput[]
    deleteMany?: locationScalarWhereInput | locationScalarWhereInput[]
  }

  export type locationUncheckedUpdateManyWithoutLocationtypeNestedInput = {
    create?: XOR<locationCreateWithoutLocationtypeInput, locationUncheckedCreateWithoutLocationtypeInput> | locationCreateWithoutLocationtypeInput[] | locationUncheckedCreateWithoutLocationtypeInput[]
    connectOrCreate?: locationCreateOrConnectWithoutLocationtypeInput | locationCreateOrConnectWithoutLocationtypeInput[]
    upsert?: locationUpsertWithWhereUniqueWithoutLocationtypeInput | locationUpsertWithWhereUniqueWithoutLocationtypeInput[]
    createMany?: locationCreateManyLocationtypeInputEnvelope
    set?: locationWhereUniqueInput | locationWhereUniqueInput[]
    disconnect?: locationWhereUniqueInput | locationWhereUniqueInput[]
    delete?: locationWhereUniqueInput | locationWhereUniqueInput[]
    connect?: locationWhereUniqueInput | locationWhereUniqueInput[]
    update?: locationUpdateWithWhereUniqueWithoutLocationtypeInput | locationUpdateWithWhereUniqueWithoutLocationtypeInput[]
    updateMany?: locationUpdateManyWithWhereWithoutLocationtypeInput | locationUpdateManyWithWhereWithoutLocationtypeInput[]
    deleteMany?: locationScalarWhereInput | locationScalarWhereInput[]
  }

  export type rolepermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<rolepermissionCreateWithoutPermissionInput, rolepermissionUncheckedCreateWithoutPermissionInput> | rolepermissionCreateWithoutPermissionInput[] | rolepermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutPermissionInput | rolepermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: rolepermissionCreateManyPermissionInputEnvelope
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
  }

  export type rolepermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<rolepermissionCreateWithoutPermissionInput, rolepermissionUncheckedCreateWithoutPermissionInput> | rolepermissionCreateWithoutPermissionInput[] | rolepermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutPermissionInput | rolepermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: rolepermissionCreateManyPermissionInputEnvelope
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
  }

  export type rolepermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<rolepermissionCreateWithoutPermissionInput, rolepermissionUncheckedCreateWithoutPermissionInput> | rolepermissionCreateWithoutPermissionInput[] | rolepermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutPermissionInput | rolepermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: rolepermissionUpsertWithWhereUniqueWithoutPermissionInput | rolepermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: rolepermissionCreateManyPermissionInputEnvelope
    set?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    disconnect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    delete?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    update?: rolepermissionUpdateWithWhereUniqueWithoutPermissionInput | rolepermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: rolepermissionUpdateManyWithWhereWithoutPermissionInput | rolepermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
  }

  export type rolepermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<rolepermissionCreateWithoutPermissionInput, rolepermissionUncheckedCreateWithoutPermissionInput> | rolepermissionCreateWithoutPermissionInput[] | rolepermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutPermissionInput | rolepermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: rolepermissionUpsertWithWhereUniqueWithoutPermissionInput | rolepermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: rolepermissionCreateManyPermissionInputEnvelope
    set?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    disconnect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    delete?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    update?: rolepermissionUpdateWithWhereUniqueWithoutPermissionInput | rolepermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: rolepermissionUpdateManyWithWhereWithoutPermissionInput | rolepermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
  }

  export type quizCreateNestedOneWithoutQuestionInput = {
    create?: XOR<quizCreateWithoutQuestionInput, quizUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: quizCreateOrConnectWithoutQuestionInput
    connect?: quizWhereUniqueInput
  }

  export type questionoptionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<questionoptionCreateWithoutQuestionInput, questionoptionUncheckedCreateWithoutQuestionInput> | questionoptionCreateWithoutQuestionInput[] | questionoptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: questionoptionCreateOrConnectWithoutQuestionInput | questionoptionCreateOrConnectWithoutQuestionInput[]
    createMany?: questionoptionCreateManyQuestionInputEnvelope
    connect?: questionoptionWhereUniqueInput | questionoptionWhereUniqueInput[]
  }

  export type questionoptionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<questionoptionCreateWithoutQuestionInput, questionoptionUncheckedCreateWithoutQuestionInput> | questionoptionCreateWithoutQuestionInput[] | questionoptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: questionoptionCreateOrConnectWithoutQuestionInput | questionoptionCreateOrConnectWithoutQuestionInput[]
    createMany?: questionoptionCreateManyQuestionInputEnvelope
    connect?: questionoptionWhereUniqueInput | questionoptionWhereUniqueInput[]
  }

  export type quizUpdateOneWithoutQuestionNestedInput = {
    create?: XOR<quizCreateWithoutQuestionInput, quizUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: quizCreateOrConnectWithoutQuestionInput
    upsert?: quizUpsertWithoutQuestionInput
    disconnect?: quizWhereInput | boolean
    delete?: quizWhereInput | boolean
    connect?: quizWhereUniqueInput
    update?: XOR<XOR<quizUpdateToOneWithWhereWithoutQuestionInput, quizUpdateWithoutQuestionInput>, quizUncheckedUpdateWithoutQuestionInput>
  }

  export type questionoptionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<questionoptionCreateWithoutQuestionInput, questionoptionUncheckedCreateWithoutQuestionInput> | questionoptionCreateWithoutQuestionInput[] | questionoptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: questionoptionCreateOrConnectWithoutQuestionInput | questionoptionCreateOrConnectWithoutQuestionInput[]
    upsert?: questionoptionUpsertWithWhereUniqueWithoutQuestionInput | questionoptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: questionoptionCreateManyQuestionInputEnvelope
    set?: questionoptionWhereUniqueInput | questionoptionWhereUniqueInput[]
    disconnect?: questionoptionWhereUniqueInput | questionoptionWhereUniqueInput[]
    delete?: questionoptionWhereUniqueInput | questionoptionWhereUniqueInput[]
    connect?: questionoptionWhereUniqueInput | questionoptionWhereUniqueInput[]
    update?: questionoptionUpdateWithWhereUniqueWithoutQuestionInput | questionoptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: questionoptionUpdateManyWithWhereWithoutQuestionInput | questionoptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: questionoptionScalarWhereInput | questionoptionScalarWhereInput[]
  }

  export type questionoptionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<questionoptionCreateWithoutQuestionInput, questionoptionUncheckedCreateWithoutQuestionInput> | questionoptionCreateWithoutQuestionInput[] | questionoptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: questionoptionCreateOrConnectWithoutQuestionInput | questionoptionCreateOrConnectWithoutQuestionInput[]
    upsert?: questionoptionUpsertWithWhereUniqueWithoutQuestionInput | questionoptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: questionoptionCreateManyQuestionInputEnvelope
    set?: questionoptionWhereUniqueInput | questionoptionWhereUniqueInput[]
    disconnect?: questionoptionWhereUniqueInput | questionoptionWhereUniqueInput[]
    delete?: questionoptionWhereUniqueInput | questionoptionWhereUniqueInput[]
    connect?: questionoptionWhereUniqueInput | questionoptionWhereUniqueInput[]
    update?: questionoptionUpdateWithWhereUniqueWithoutQuestionInput | questionoptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: questionoptionUpdateManyWithWhereWithoutQuestionInput | questionoptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: questionoptionScalarWhereInput | questionoptionScalarWhereInput[]
  }

  export type questionCreateNestedOneWithoutQuestionoptionInput = {
    create?: XOR<questionCreateWithoutQuestionoptionInput, questionUncheckedCreateWithoutQuestionoptionInput>
    connectOrCreate?: questionCreateOrConnectWithoutQuestionoptionInput
    connect?: questionWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type questionUpdateOneRequiredWithoutQuestionoptionNestedInput = {
    create?: XOR<questionCreateWithoutQuestionoptionInput, questionUncheckedCreateWithoutQuestionoptionInput>
    connectOrCreate?: questionCreateOrConnectWithoutQuestionoptionInput
    upsert?: questionUpsertWithoutQuestionoptionInput
    connect?: questionWhereUniqueInput
    update?: XOR<XOR<questionUpdateToOneWithWhereWithoutQuestionoptionInput, questionUpdateWithoutQuestionoptionInput>, questionUncheckedUpdateWithoutQuestionoptionInput>
  }

  export type checkpointCreateNestedManyWithoutQuizInput = {
    create?: XOR<checkpointCreateWithoutQuizInput, checkpointUncheckedCreateWithoutQuizInput> | checkpointCreateWithoutQuizInput[] | checkpointUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: checkpointCreateOrConnectWithoutQuizInput | checkpointCreateOrConnectWithoutQuizInput[]
    createMany?: checkpointCreateManyQuizInputEnvelope
    connect?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
  }

  export type questionCreateNestedManyWithoutQuizInput = {
    create?: XOR<questionCreateWithoutQuizInput, questionUncheckedCreateWithoutQuizInput> | questionCreateWithoutQuizInput[] | questionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: questionCreateOrConnectWithoutQuizInput | questionCreateOrConnectWithoutQuizInput[]
    createMany?: questionCreateManyQuizInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type userquizcompletionCreateNestedManyWithoutQuizInput = {
    create?: XOR<userquizcompletionCreateWithoutQuizInput, userquizcompletionUncheckedCreateWithoutQuizInput> | userquizcompletionCreateWithoutQuizInput[] | userquizcompletionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: userquizcompletionCreateOrConnectWithoutQuizInput | userquizcompletionCreateOrConnectWithoutQuizInput[]
    createMany?: userquizcompletionCreateManyQuizInputEnvelope
    connect?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
  }

  export type checkpointUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<checkpointCreateWithoutQuizInput, checkpointUncheckedCreateWithoutQuizInput> | checkpointCreateWithoutQuizInput[] | checkpointUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: checkpointCreateOrConnectWithoutQuizInput | checkpointCreateOrConnectWithoutQuizInput[]
    createMany?: checkpointCreateManyQuizInputEnvelope
    connect?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
  }

  export type questionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<questionCreateWithoutQuizInput, questionUncheckedCreateWithoutQuizInput> | questionCreateWithoutQuizInput[] | questionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: questionCreateOrConnectWithoutQuizInput | questionCreateOrConnectWithoutQuizInput[]
    createMany?: questionCreateManyQuizInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type userquizcompletionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<userquizcompletionCreateWithoutQuizInput, userquizcompletionUncheckedCreateWithoutQuizInput> | userquizcompletionCreateWithoutQuizInput[] | userquizcompletionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: userquizcompletionCreateOrConnectWithoutQuizInput | userquizcompletionCreateOrConnectWithoutQuizInput[]
    createMany?: userquizcompletionCreateManyQuizInputEnvelope
    connect?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
  }

  export type checkpointUpdateManyWithoutQuizNestedInput = {
    create?: XOR<checkpointCreateWithoutQuizInput, checkpointUncheckedCreateWithoutQuizInput> | checkpointCreateWithoutQuizInput[] | checkpointUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: checkpointCreateOrConnectWithoutQuizInput | checkpointCreateOrConnectWithoutQuizInput[]
    upsert?: checkpointUpsertWithWhereUniqueWithoutQuizInput | checkpointUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: checkpointCreateManyQuizInputEnvelope
    set?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    disconnect?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    delete?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    connect?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    update?: checkpointUpdateWithWhereUniqueWithoutQuizInput | checkpointUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: checkpointUpdateManyWithWhereWithoutQuizInput | checkpointUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: checkpointScalarWhereInput | checkpointScalarWhereInput[]
  }

  export type questionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<questionCreateWithoutQuizInput, questionUncheckedCreateWithoutQuizInput> | questionCreateWithoutQuizInput[] | questionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: questionCreateOrConnectWithoutQuizInput | questionCreateOrConnectWithoutQuizInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutQuizInput | questionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: questionCreateManyQuizInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutQuizInput | questionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: questionUpdateManyWithWhereWithoutQuizInput | questionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type userquizcompletionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<userquizcompletionCreateWithoutQuizInput, userquizcompletionUncheckedCreateWithoutQuizInput> | userquizcompletionCreateWithoutQuizInput[] | userquizcompletionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: userquizcompletionCreateOrConnectWithoutQuizInput | userquizcompletionCreateOrConnectWithoutQuizInput[]
    upsert?: userquizcompletionUpsertWithWhereUniqueWithoutQuizInput | userquizcompletionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: userquizcompletionCreateManyQuizInputEnvelope
    set?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    disconnect?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    delete?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    connect?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    update?: userquizcompletionUpdateWithWhereUniqueWithoutQuizInput | userquizcompletionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: userquizcompletionUpdateManyWithWhereWithoutQuizInput | userquizcompletionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: userquizcompletionScalarWhereInput | userquizcompletionScalarWhereInput[]
  }

  export type checkpointUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<checkpointCreateWithoutQuizInput, checkpointUncheckedCreateWithoutQuizInput> | checkpointCreateWithoutQuizInput[] | checkpointUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: checkpointCreateOrConnectWithoutQuizInput | checkpointCreateOrConnectWithoutQuizInput[]
    upsert?: checkpointUpsertWithWhereUniqueWithoutQuizInput | checkpointUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: checkpointCreateManyQuizInputEnvelope
    set?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    disconnect?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    delete?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    connect?: checkpointWhereUniqueInput | checkpointWhereUniqueInput[]
    update?: checkpointUpdateWithWhereUniqueWithoutQuizInput | checkpointUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: checkpointUpdateManyWithWhereWithoutQuizInput | checkpointUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: checkpointScalarWhereInput | checkpointScalarWhereInput[]
  }

  export type questionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<questionCreateWithoutQuizInput, questionUncheckedCreateWithoutQuizInput> | questionCreateWithoutQuizInput[] | questionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: questionCreateOrConnectWithoutQuizInput | questionCreateOrConnectWithoutQuizInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutQuizInput | questionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: questionCreateManyQuizInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutQuizInput | questionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: questionUpdateManyWithWhereWithoutQuizInput | questionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type userquizcompletionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<userquizcompletionCreateWithoutQuizInput, userquizcompletionUncheckedCreateWithoutQuizInput> | userquizcompletionCreateWithoutQuizInput[] | userquizcompletionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: userquizcompletionCreateOrConnectWithoutQuizInput | userquizcompletionCreateOrConnectWithoutQuizInput[]
    upsert?: userquizcompletionUpsertWithWhereUniqueWithoutQuizInput | userquizcompletionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: userquizcompletionCreateManyQuizInputEnvelope
    set?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    disconnect?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    delete?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    connect?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    update?: userquizcompletionUpdateWithWhereUniqueWithoutQuizInput | userquizcompletionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: userquizcompletionUpdateManyWithWhereWithoutQuizInput | userquizcompletionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: userquizcompletionScalarWhereInput | userquizcompletionScalarWhereInput[]
  }

  export type tourCreateNestedOneWithoutReviewInput = {
    create?: XOR<tourCreateWithoutReviewInput, tourUncheckedCreateWithoutReviewInput>
    connectOrCreate?: tourCreateOrConnectWithoutReviewInput
    connect?: tourWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutReviewInput = {
    create?: XOR<usersCreateWithoutReviewInput, usersUncheckedCreateWithoutReviewInput>
    connectOrCreate?: usersCreateOrConnectWithoutReviewInput
    connect?: usersWhereUniqueInput
  }

  export type tourUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<tourCreateWithoutReviewInput, tourUncheckedCreateWithoutReviewInput>
    connectOrCreate?: tourCreateOrConnectWithoutReviewInput
    upsert?: tourUpsertWithoutReviewInput
    connect?: tourWhereUniqueInput
    update?: XOR<XOR<tourUpdateToOneWithWhereWithoutReviewInput, tourUpdateWithoutReviewInput>, tourUncheckedUpdateWithoutReviewInput>
  }

  export type usersUpdateOneWithoutReviewNestedInput = {
    create?: XOR<usersCreateWithoutReviewInput, usersUncheckedCreateWithoutReviewInput>
    connectOrCreate?: usersCreateOrConnectWithoutReviewInput
    upsert?: usersUpsertWithoutReviewInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutReviewInput, usersUpdateWithoutReviewInput>, usersUncheckedUpdateWithoutReviewInput>
  }

  export type rolepermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<rolepermissionCreateWithoutRoleInput, rolepermissionUncheckedCreateWithoutRoleInput> | rolepermissionCreateWithoutRoleInput[] | rolepermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutRoleInput | rolepermissionCreateOrConnectWithoutRoleInput[]
    createMany?: rolepermissionCreateManyRoleInputEnvelope
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
  }

  export type userroleCreateNestedManyWithoutRoleInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type rolepermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<rolepermissionCreateWithoutRoleInput, rolepermissionUncheckedCreateWithoutRoleInput> | rolepermissionCreateWithoutRoleInput[] | rolepermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutRoleInput | rolepermissionCreateOrConnectWithoutRoleInput[]
    createMany?: rolepermissionCreateManyRoleInputEnvelope
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type rolepermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<rolepermissionCreateWithoutRoleInput, rolepermissionUncheckedCreateWithoutRoleInput> | rolepermissionCreateWithoutRoleInput[] | rolepermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutRoleInput | rolepermissionCreateOrConnectWithoutRoleInput[]
    upsert?: rolepermissionUpsertWithWhereUniqueWithoutRoleInput | rolepermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: rolepermissionCreateManyRoleInputEnvelope
    set?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    disconnect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    delete?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    update?: rolepermissionUpdateWithWhereUniqueWithoutRoleInput | rolepermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: rolepermissionUpdateManyWithWhereWithoutRoleInput | rolepermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
  }

  export type userroleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutRoleInput | userroleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutRoleInput | userroleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutRoleInput | userroleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type rolepermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<rolepermissionCreateWithoutRoleInput, rolepermissionUncheckedCreateWithoutRoleInput> | rolepermissionCreateWithoutRoleInput[] | rolepermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: rolepermissionCreateOrConnectWithoutRoleInput | rolepermissionCreateOrConnectWithoutRoleInput[]
    upsert?: rolepermissionUpsertWithWhereUniqueWithoutRoleInput | rolepermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: rolepermissionCreateManyRoleInputEnvelope
    set?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    disconnect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    delete?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    connect?: rolepermissionWhereUniqueInput | rolepermissionWhereUniqueInput[]
    update?: rolepermissionUpdateWithWhereUniqueWithoutRoleInput | rolepermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: rolepermissionUpdateManyWithWhereWithoutRoleInput | rolepermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
  }

  export type userroleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutRoleInput | userroleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutRoleInput | userroleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutRoleInput | userroleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type permissionCreateNestedOneWithoutRolepermissionInput = {
    create?: XOR<permissionCreateWithoutRolepermissionInput, permissionUncheckedCreateWithoutRolepermissionInput>
    connectOrCreate?: permissionCreateOrConnectWithoutRolepermissionInput
    connect?: permissionWhereUniqueInput
  }

  export type roleCreateNestedOneWithoutRolepermissionInput = {
    create?: XOR<roleCreateWithoutRolepermissionInput, roleUncheckedCreateWithoutRolepermissionInput>
    connectOrCreate?: roleCreateOrConnectWithoutRolepermissionInput
    connect?: roleWhereUniqueInput
  }

  export type permissionUpdateOneRequiredWithoutRolepermissionNestedInput = {
    create?: XOR<permissionCreateWithoutRolepermissionInput, permissionUncheckedCreateWithoutRolepermissionInput>
    connectOrCreate?: permissionCreateOrConnectWithoutRolepermissionInput
    upsert?: permissionUpsertWithoutRolepermissionInput
    connect?: permissionWhereUniqueInput
    update?: XOR<XOR<permissionUpdateToOneWithWhereWithoutRolepermissionInput, permissionUpdateWithoutRolepermissionInput>, permissionUncheckedUpdateWithoutRolepermissionInput>
  }

  export type roleUpdateOneRequiredWithoutRolepermissionNestedInput = {
    create?: XOR<roleCreateWithoutRolepermissionInput, roleUncheckedCreateWithoutRolepermissionInput>
    connectOrCreate?: roleCreateOrConnectWithoutRolepermissionInput
    upsert?: roleUpsertWithoutRolepermissionInput
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutRolepermissionInput, roleUpdateWithoutRolepermissionInput>, roleUncheckedUpdateWithoutRolepermissionInput>
  }

  export type auditlogCreateNestedManyWithoutSessionsInput = {
    create?: XOR<auditlogCreateWithoutSessionsInput, auditlogUncheckedCreateWithoutSessionsInput> | auditlogCreateWithoutSessionsInput[] | auditlogUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutSessionsInput | auditlogCreateOrConnectWithoutSessionsInput[]
    createMany?: auditlogCreateManySessionsInputEnvelope
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutSessionsInput = {
    create?: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput
    connect?: usersWhereUniqueInput
  }

  export type auditlogUncheckedCreateNestedManyWithoutSessionsInput = {
    create?: XOR<auditlogCreateWithoutSessionsInput, auditlogUncheckedCreateWithoutSessionsInput> | auditlogCreateWithoutSessionsInput[] | auditlogUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutSessionsInput | auditlogCreateOrConnectWithoutSessionsInput[]
    createMany?: auditlogCreateManySessionsInputEnvelope
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type auditlogUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<auditlogCreateWithoutSessionsInput, auditlogUncheckedCreateWithoutSessionsInput> | auditlogCreateWithoutSessionsInput[] | auditlogUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutSessionsInput | auditlogCreateOrConnectWithoutSessionsInput[]
    upsert?: auditlogUpsertWithWhereUniqueWithoutSessionsInput | auditlogUpsertWithWhereUniqueWithoutSessionsInput[]
    createMany?: auditlogCreateManySessionsInputEnvelope
    set?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    disconnect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    delete?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    update?: auditlogUpdateWithWhereUniqueWithoutSessionsInput | auditlogUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: auditlogUpdateManyWithWhereWithoutSessionsInput | auditlogUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
  }

  export type usersUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput
    upsert?: usersUpsertWithoutSessionsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSessionsInput, usersUpdateWithoutSessionsInput>, usersUncheckedUpdateWithoutSessionsInput>
  }

  export type auditlogUncheckedUpdateManyWithoutSessionsNestedInput = {
    create?: XOR<auditlogCreateWithoutSessionsInput, auditlogUncheckedCreateWithoutSessionsInput> | auditlogCreateWithoutSessionsInput[] | auditlogUncheckedCreateWithoutSessionsInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutSessionsInput | auditlogCreateOrConnectWithoutSessionsInput[]
    upsert?: auditlogUpsertWithWhereUniqueWithoutSessionsInput | auditlogUpsertWithWhereUniqueWithoutSessionsInput[]
    createMany?: auditlogCreateManySessionsInputEnvelope
    set?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    disconnect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    delete?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    update?: auditlogUpdateWithWhereUniqueWithoutSessionsInput | auditlogUpdateWithWhereUniqueWithoutSessionsInput[]
    updateMany?: auditlogUpdateManyWithWhereWithoutSessionsInput | auditlogUpdateManyWithWhereWithoutSessionsInput[]
    deleteMany?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
  }

  export type badgeCreateNestedManyWithoutTourInput = {
    create?: XOR<badgeCreateWithoutTourInput, badgeUncheckedCreateWithoutTourInput> | badgeCreateWithoutTourInput[] | badgeUncheckedCreateWithoutTourInput[]
    connectOrCreate?: badgeCreateOrConnectWithoutTourInput | badgeCreateOrConnectWithoutTourInput[]
    createMany?: badgeCreateManyTourInputEnvelope
    connect?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
  }

  export type reviewCreateNestedManyWithoutTourInput = {
    create?: XOR<reviewCreateWithoutTourInput, reviewUncheckedCreateWithoutTourInput> | reviewCreateWithoutTourInput[] | reviewUncheckedCreateWithoutTourInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutTourInput | reviewCreateOrConnectWithoutTourInput[]
    createMany?: reviewCreateManyTourInputEnvelope
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
  }

  export type tourcheckpointCreateNestedManyWithoutTourInput = {
    create?: XOR<tourcheckpointCreateWithoutTourInput, tourcheckpointUncheckedCreateWithoutTourInput> | tourcheckpointCreateWithoutTourInput[] | tourcheckpointUncheckedCreateWithoutTourInput[]
    connectOrCreate?: tourcheckpointCreateOrConnectWithoutTourInput | tourcheckpointCreateOrConnectWithoutTourInput[]
    createMany?: tourcheckpointCreateManyTourInputEnvelope
    connect?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
  }

  export type usertourcompletionCreateNestedManyWithoutTourInput = {
    create?: XOR<usertourcompletionCreateWithoutTourInput, usertourcompletionUncheckedCreateWithoutTourInput> | usertourcompletionCreateWithoutTourInput[] | usertourcompletionUncheckedCreateWithoutTourInput[]
    connectOrCreate?: usertourcompletionCreateOrConnectWithoutTourInput | usertourcompletionCreateOrConnectWithoutTourInput[]
    createMany?: usertourcompletionCreateManyTourInputEnvelope
    connect?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
  }

  export type badgeUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<badgeCreateWithoutTourInput, badgeUncheckedCreateWithoutTourInput> | badgeCreateWithoutTourInput[] | badgeUncheckedCreateWithoutTourInput[]
    connectOrCreate?: badgeCreateOrConnectWithoutTourInput | badgeCreateOrConnectWithoutTourInput[]
    createMany?: badgeCreateManyTourInputEnvelope
    connect?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
  }

  export type reviewUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<reviewCreateWithoutTourInput, reviewUncheckedCreateWithoutTourInput> | reviewCreateWithoutTourInput[] | reviewUncheckedCreateWithoutTourInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutTourInput | reviewCreateOrConnectWithoutTourInput[]
    createMany?: reviewCreateManyTourInputEnvelope
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
  }

  export type tourcheckpointUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<tourcheckpointCreateWithoutTourInput, tourcheckpointUncheckedCreateWithoutTourInput> | tourcheckpointCreateWithoutTourInput[] | tourcheckpointUncheckedCreateWithoutTourInput[]
    connectOrCreate?: tourcheckpointCreateOrConnectWithoutTourInput | tourcheckpointCreateOrConnectWithoutTourInput[]
    createMany?: tourcheckpointCreateManyTourInputEnvelope
    connect?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
  }

  export type usertourcompletionUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<usertourcompletionCreateWithoutTourInput, usertourcompletionUncheckedCreateWithoutTourInput> | usertourcompletionCreateWithoutTourInput[] | usertourcompletionUncheckedCreateWithoutTourInput[]
    connectOrCreate?: usertourcompletionCreateOrConnectWithoutTourInput | usertourcompletionCreateOrConnectWithoutTourInput[]
    createMany?: usertourcompletionCreateManyTourInputEnvelope
    connect?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
  }

  export type badgeUpdateManyWithoutTourNestedInput = {
    create?: XOR<badgeCreateWithoutTourInput, badgeUncheckedCreateWithoutTourInput> | badgeCreateWithoutTourInput[] | badgeUncheckedCreateWithoutTourInput[]
    connectOrCreate?: badgeCreateOrConnectWithoutTourInput | badgeCreateOrConnectWithoutTourInput[]
    upsert?: badgeUpsertWithWhereUniqueWithoutTourInput | badgeUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: badgeCreateManyTourInputEnvelope
    set?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    disconnect?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    delete?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    connect?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    update?: badgeUpdateWithWhereUniqueWithoutTourInput | badgeUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: badgeUpdateManyWithWhereWithoutTourInput | badgeUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: badgeScalarWhereInput | badgeScalarWhereInput[]
  }

  export type reviewUpdateManyWithoutTourNestedInput = {
    create?: XOR<reviewCreateWithoutTourInput, reviewUncheckedCreateWithoutTourInput> | reviewCreateWithoutTourInput[] | reviewUncheckedCreateWithoutTourInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutTourInput | reviewCreateOrConnectWithoutTourInput[]
    upsert?: reviewUpsertWithWhereUniqueWithoutTourInput | reviewUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: reviewCreateManyTourInputEnvelope
    set?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    disconnect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    delete?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    update?: reviewUpdateWithWhereUniqueWithoutTourInput | reviewUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: reviewUpdateManyWithWhereWithoutTourInput | reviewUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: reviewScalarWhereInput | reviewScalarWhereInput[]
  }

  export type tourcheckpointUpdateManyWithoutTourNestedInput = {
    create?: XOR<tourcheckpointCreateWithoutTourInput, tourcheckpointUncheckedCreateWithoutTourInput> | tourcheckpointCreateWithoutTourInput[] | tourcheckpointUncheckedCreateWithoutTourInput[]
    connectOrCreate?: tourcheckpointCreateOrConnectWithoutTourInput | tourcheckpointCreateOrConnectWithoutTourInput[]
    upsert?: tourcheckpointUpsertWithWhereUniqueWithoutTourInput | tourcheckpointUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: tourcheckpointCreateManyTourInputEnvelope
    set?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    disconnect?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    delete?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    connect?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    update?: tourcheckpointUpdateWithWhereUniqueWithoutTourInput | tourcheckpointUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: tourcheckpointUpdateManyWithWhereWithoutTourInput | tourcheckpointUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: tourcheckpointScalarWhereInput | tourcheckpointScalarWhereInput[]
  }

  export type usertourcompletionUpdateManyWithoutTourNestedInput = {
    create?: XOR<usertourcompletionCreateWithoutTourInput, usertourcompletionUncheckedCreateWithoutTourInput> | usertourcompletionCreateWithoutTourInput[] | usertourcompletionUncheckedCreateWithoutTourInput[]
    connectOrCreate?: usertourcompletionCreateOrConnectWithoutTourInput | usertourcompletionCreateOrConnectWithoutTourInput[]
    upsert?: usertourcompletionUpsertWithWhereUniqueWithoutTourInput | usertourcompletionUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: usertourcompletionCreateManyTourInputEnvelope
    set?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    disconnect?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    delete?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    connect?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    update?: usertourcompletionUpdateWithWhereUniqueWithoutTourInput | usertourcompletionUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: usertourcompletionUpdateManyWithWhereWithoutTourInput | usertourcompletionUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: usertourcompletionScalarWhereInput | usertourcompletionScalarWhereInput[]
  }

  export type badgeUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<badgeCreateWithoutTourInput, badgeUncheckedCreateWithoutTourInput> | badgeCreateWithoutTourInput[] | badgeUncheckedCreateWithoutTourInput[]
    connectOrCreate?: badgeCreateOrConnectWithoutTourInput | badgeCreateOrConnectWithoutTourInput[]
    upsert?: badgeUpsertWithWhereUniqueWithoutTourInput | badgeUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: badgeCreateManyTourInputEnvelope
    set?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    disconnect?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    delete?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    connect?: badgeWhereUniqueInput | badgeWhereUniqueInput[]
    update?: badgeUpdateWithWhereUniqueWithoutTourInput | badgeUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: badgeUpdateManyWithWhereWithoutTourInput | badgeUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: badgeScalarWhereInput | badgeScalarWhereInput[]
  }

  export type reviewUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<reviewCreateWithoutTourInput, reviewUncheckedCreateWithoutTourInput> | reviewCreateWithoutTourInput[] | reviewUncheckedCreateWithoutTourInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutTourInput | reviewCreateOrConnectWithoutTourInput[]
    upsert?: reviewUpsertWithWhereUniqueWithoutTourInput | reviewUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: reviewCreateManyTourInputEnvelope
    set?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    disconnect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    delete?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    update?: reviewUpdateWithWhereUniqueWithoutTourInput | reviewUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: reviewUpdateManyWithWhereWithoutTourInput | reviewUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: reviewScalarWhereInput | reviewScalarWhereInput[]
  }

  export type tourcheckpointUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<tourcheckpointCreateWithoutTourInput, tourcheckpointUncheckedCreateWithoutTourInput> | tourcheckpointCreateWithoutTourInput[] | tourcheckpointUncheckedCreateWithoutTourInput[]
    connectOrCreate?: tourcheckpointCreateOrConnectWithoutTourInput | tourcheckpointCreateOrConnectWithoutTourInput[]
    upsert?: tourcheckpointUpsertWithWhereUniqueWithoutTourInput | tourcheckpointUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: tourcheckpointCreateManyTourInputEnvelope
    set?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    disconnect?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    delete?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    connect?: tourcheckpointWhereUniqueInput | tourcheckpointWhereUniqueInput[]
    update?: tourcheckpointUpdateWithWhereUniqueWithoutTourInput | tourcheckpointUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: tourcheckpointUpdateManyWithWhereWithoutTourInput | tourcheckpointUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: tourcheckpointScalarWhereInput | tourcheckpointScalarWhereInput[]
  }

  export type usertourcompletionUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<usertourcompletionCreateWithoutTourInput, usertourcompletionUncheckedCreateWithoutTourInput> | usertourcompletionCreateWithoutTourInput[] | usertourcompletionUncheckedCreateWithoutTourInput[]
    connectOrCreate?: usertourcompletionCreateOrConnectWithoutTourInput | usertourcompletionCreateOrConnectWithoutTourInput[]
    upsert?: usertourcompletionUpsertWithWhereUniqueWithoutTourInput | usertourcompletionUpsertWithWhereUniqueWithoutTourInput[]
    createMany?: usertourcompletionCreateManyTourInputEnvelope
    set?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    disconnect?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    delete?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    connect?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    update?: usertourcompletionUpdateWithWhereUniqueWithoutTourInput | usertourcompletionUpdateWithWhereUniqueWithoutTourInput[]
    updateMany?: usertourcompletionUpdateManyWithWhereWithoutTourInput | usertourcompletionUpdateManyWithWhereWithoutTourInput[]
    deleteMany?: usertourcompletionScalarWhereInput | usertourcompletionScalarWhereInput[]
  }

  export type checkpointCreateNestedOneWithoutTourcheckpointInput = {
    create?: XOR<checkpointCreateWithoutTourcheckpointInput, checkpointUncheckedCreateWithoutTourcheckpointInput>
    connectOrCreate?: checkpointCreateOrConnectWithoutTourcheckpointInput
    connect?: checkpointWhereUniqueInput
  }

  export type tourCreateNestedOneWithoutTourcheckpointInput = {
    create?: XOR<tourCreateWithoutTourcheckpointInput, tourUncheckedCreateWithoutTourcheckpointInput>
    connectOrCreate?: tourCreateOrConnectWithoutTourcheckpointInput
    connect?: tourWhereUniqueInput
  }

  export type checkpointUpdateOneRequiredWithoutTourcheckpointNestedInput = {
    create?: XOR<checkpointCreateWithoutTourcheckpointInput, checkpointUncheckedCreateWithoutTourcheckpointInput>
    connectOrCreate?: checkpointCreateOrConnectWithoutTourcheckpointInput
    upsert?: checkpointUpsertWithoutTourcheckpointInput
    connect?: checkpointWhereUniqueInput
    update?: XOR<XOR<checkpointUpdateToOneWithWhereWithoutTourcheckpointInput, checkpointUpdateWithoutTourcheckpointInput>, checkpointUncheckedUpdateWithoutTourcheckpointInput>
  }

  export type tourUpdateOneRequiredWithoutTourcheckpointNestedInput = {
    create?: XOR<tourCreateWithoutTourcheckpointInput, tourUncheckedCreateWithoutTourcheckpointInput>
    connectOrCreate?: tourCreateOrConnectWithoutTourcheckpointInput
    upsert?: tourUpsertWithoutTourcheckpointInput
    connect?: tourWhereUniqueInput
    update?: XOR<XOR<tourUpdateToOneWithWhereWithoutTourcheckpointInput, tourUpdateWithoutTourcheckpointInput>, tourUncheckedUpdateWithoutTourcheckpointInput>
  }

  export type badgeCreateNestedOneWithoutUserbadgeInput = {
    create?: XOR<badgeCreateWithoutUserbadgeInput, badgeUncheckedCreateWithoutUserbadgeInput>
    connectOrCreate?: badgeCreateOrConnectWithoutUserbadgeInput
    connect?: badgeWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUserbadgeInput = {
    create?: XOR<usersCreateWithoutUserbadgeInput, usersUncheckedCreateWithoutUserbadgeInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserbadgeInput
    connect?: usersWhereUniqueInput
  }

  export type badgeUpdateOneRequiredWithoutUserbadgeNestedInput = {
    create?: XOR<badgeCreateWithoutUserbadgeInput, badgeUncheckedCreateWithoutUserbadgeInput>
    connectOrCreate?: badgeCreateOrConnectWithoutUserbadgeInput
    upsert?: badgeUpsertWithoutUserbadgeInput
    connect?: badgeWhereUniqueInput
    update?: XOR<XOR<badgeUpdateToOneWithWhereWithoutUserbadgeInput, badgeUpdateWithoutUserbadgeInput>, badgeUncheckedUpdateWithoutUserbadgeInput>
  }

  export type usersUpdateOneRequiredWithoutUserbadgeNestedInput = {
    create?: XOR<usersCreateWithoutUserbadgeInput, usersUncheckedCreateWithoutUserbadgeInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserbadgeInput
    upsert?: usersUpsertWithoutUserbadgeInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUserbadgeInput, usersUpdateWithoutUserbadgeInput>, usersUncheckedUpdateWithoutUserbadgeInput>
  }

  export type checkpointCreateNestedOneWithoutUsercheckpointattemptInput = {
    create?: XOR<checkpointCreateWithoutUsercheckpointattemptInput, checkpointUncheckedCreateWithoutUsercheckpointattemptInput>
    connectOrCreate?: checkpointCreateOrConnectWithoutUsercheckpointattemptInput
    connect?: checkpointWhereUniqueInput
  }

  export type usertourcompletionCreateNestedOneWithoutUsercheckpointattemptInput = {
    create?: XOR<usertourcompletionCreateWithoutUsercheckpointattemptInput, usertourcompletionUncheckedCreateWithoutUsercheckpointattemptInput>
    connectOrCreate?: usertourcompletionCreateOrConnectWithoutUsercheckpointattemptInput
    connect?: usertourcompletionWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUsercheckpointattemptInput = {
    create?: XOR<usersCreateWithoutUsercheckpointattemptInput, usersUncheckedCreateWithoutUsercheckpointattemptInput>
    connectOrCreate?: usersCreateOrConnectWithoutUsercheckpointattemptInput
    connect?: usersWhereUniqueInput
  }

  export type checkpointUpdateOneWithoutUsercheckpointattemptNestedInput = {
    create?: XOR<checkpointCreateWithoutUsercheckpointattemptInput, checkpointUncheckedCreateWithoutUsercheckpointattemptInput>
    connectOrCreate?: checkpointCreateOrConnectWithoutUsercheckpointattemptInput
    upsert?: checkpointUpsertWithoutUsercheckpointattemptInput
    disconnect?: checkpointWhereInput | boolean
    delete?: checkpointWhereInput | boolean
    connect?: checkpointWhereUniqueInput
    update?: XOR<XOR<checkpointUpdateToOneWithWhereWithoutUsercheckpointattemptInput, checkpointUpdateWithoutUsercheckpointattemptInput>, checkpointUncheckedUpdateWithoutUsercheckpointattemptInput>
  }

  export type usertourcompletionUpdateOneRequiredWithoutUsercheckpointattemptNestedInput = {
    create?: XOR<usertourcompletionCreateWithoutUsercheckpointattemptInput, usertourcompletionUncheckedCreateWithoutUsercheckpointattemptInput>
    connectOrCreate?: usertourcompletionCreateOrConnectWithoutUsercheckpointattemptInput
    upsert?: usertourcompletionUpsertWithoutUsercheckpointattemptInput
    connect?: usertourcompletionWhereUniqueInput
    update?: XOR<XOR<usertourcompletionUpdateToOneWithWhereWithoutUsercheckpointattemptInput, usertourcompletionUpdateWithoutUsercheckpointattemptInput>, usertourcompletionUncheckedUpdateWithoutUsercheckpointattemptInput>
  }

  export type usersUpdateOneRequiredWithoutUsercheckpointattemptNestedInput = {
    create?: XOR<usersCreateWithoutUsercheckpointattemptInput, usersUncheckedCreateWithoutUsercheckpointattemptInput>
    connectOrCreate?: usersCreateOrConnectWithoutUsercheckpointattemptInput
    upsert?: usersUpsertWithoutUsercheckpointattemptInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUsercheckpointattemptInput, usersUpdateWithoutUsercheckpointattemptInput>, usersUncheckedUpdateWithoutUsercheckpointattemptInput>
  }

  export type usersCreateNestedOneWithoutUserprofileInput = {
    create?: XOR<usersCreateWithoutUserprofileInput, usersUncheckedCreateWithoutUserprofileInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserprofileInput
    connect?: usersWhereUniqueInput
  }

  export type Enumsec_levelFieldUpdateOperationsInput = {
    set?: $Enums.sec_level
  }

  export type usersUpdateOneRequiredWithoutUserprofileNestedInput = {
    create?: XOR<usersCreateWithoutUserprofileInput, usersUncheckedCreateWithoutUserprofileInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserprofileInput
    upsert?: usersUpsertWithoutUserprofileInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUserprofileInput, usersUpdateWithoutUserprofileInput>, usersUncheckedUpdateWithoutUserprofileInput>
  }

  export type quizCreateNestedOneWithoutUserquizcompletionInput = {
    create?: XOR<quizCreateWithoutUserquizcompletionInput, quizUncheckedCreateWithoutUserquizcompletionInput>
    connectOrCreate?: quizCreateOrConnectWithoutUserquizcompletionInput
    connect?: quizWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUserquizcompletionInput = {
    create?: XOR<usersCreateWithoutUserquizcompletionInput, usersUncheckedCreateWithoutUserquizcompletionInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserquizcompletionInput
    connect?: usersWhereUniqueInput
  }

  export type quizUpdateOneRequiredWithoutUserquizcompletionNestedInput = {
    create?: XOR<quizCreateWithoutUserquizcompletionInput, quizUncheckedCreateWithoutUserquizcompletionInput>
    connectOrCreate?: quizCreateOrConnectWithoutUserquizcompletionInput
    upsert?: quizUpsertWithoutUserquizcompletionInput
    connect?: quizWhereUniqueInput
    update?: XOR<XOR<quizUpdateToOneWithWhereWithoutUserquizcompletionInput, quizUpdateWithoutUserquizcompletionInput>, quizUncheckedUpdateWithoutUserquizcompletionInput>
  }

  export type usersUpdateOneRequiredWithoutUserquizcompletionNestedInput = {
    create?: XOR<usersCreateWithoutUserquizcompletionInput, usersUncheckedCreateWithoutUserquizcompletionInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserquizcompletionInput
    upsert?: usersUpsertWithoutUserquizcompletionInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUserquizcompletionInput, usersUpdateWithoutUserquizcompletionInput>, usersUncheckedUpdateWithoutUserquizcompletionInput>
  }

  export type roleCreateNestedOneWithoutUserroleInput = {
    create?: XOR<roleCreateWithoutUserroleInput, roleUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: roleCreateOrConnectWithoutUserroleInput
    connect?: roleWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUserroleInput = {
    create?: XOR<usersCreateWithoutUserroleInput, usersUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserroleInput
    connect?: usersWhereUniqueInput
  }

  export type roleUpdateOneRequiredWithoutUserroleNestedInput = {
    create?: XOR<roleCreateWithoutUserroleInput, roleUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: roleCreateOrConnectWithoutUserroleInput
    upsert?: roleUpsertWithoutUserroleInput
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutUserroleInput, roleUpdateWithoutUserroleInput>, roleUncheckedUpdateWithoutUserroleInput>
  }

  export type usersUpdateOneRequiredWithoutUserroleNestedInput = {
    create?: XOR<usersCreateWithoutUserroleInput, usersUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserroleInput
    upsert?: usersUpsertWithoutUserroleInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUserroleInput, usersUpdateWithoutUserroleInput>, usersUncheckedUpdateWithoutUserroleInput>
  }

  export type auditlogCreateNestedManyWithoutUsersInput = {
    create?: XOR<auditlogCreateWithoutUsersInput, auditlogUncheckedCreateWithoutUsersInput> | auditlogCreateWithoutUsersInput[] | auditlogUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutUsersInput | auditlogCreateOrConnectWithoutUsersInput[]
    createMany?: auditlogCreateManyUsersInputEnvelope
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
  }

  export type reviewCreateNestedManyWithoutUsersInput = {
    create?: XOR<reviewCreateWithoutUsersInput, reviewUncheckedCreateWithoutUsersInput> | reviewCreateWithoutUsersInput[] | reviewUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutUsersInput | reviewCreateOrConnectWithoutUsersInput[]
    createMany?: reviewCreateManyUsersInputEnvelope
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
  }

  export type sessionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type userbadgeCreateNestedManyWithoutUsersInput = {
    create?: XOR<userbadgeCreateWithoutUsersInput, userbadgeUncheckedCreateWithoutUsersInput> | userbadgeCreateWithoutUsersInput[] | userbadgeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userbadgeCreateOrConnectWithoutUsersInput | userbadgeCreateOrConnectWithoutUsersInput[]
    createMany?: userbadgeCreateManyUsersInputEnvelope
    connect?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
  }

  export type usercheckpointattemptCreateNestedManyWithoutUsersInput = {
    create?: XOR<usercheckpointattemptCreateWithoutUsersInput, usercheckpointattemptUncheckedCreateWithoutUsersInput> | usercheckpointattemptCreateWithoutUsersInput[] | usercheckpointattemptUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usercheckpointattemptCreateOrConnectWithoutUsersInput | usercheckpointattemptCreateOrConnectWithoutUsersInput[]
    createMany?: usercheckpointattemptCreateManyUsersInputEnvelope
    connect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
  }

  export type userprofileCreateNestedOneWithoutUsersInput = {
    create?: XOR<userprofileCreateWithoutUsersInput, userprofileUncheckedCreateWithoutUsersInput>
    connectOrCreate?: userprofileCreateOrConnectWithoutUsersInput
    connect?: userprofileWhereUniqueInput
  }

  export type userquizcompletionCreateNestedManyWithoutUsersInput = {
    create?: XOR<userquizcompletionCreateWithoutUsersInput, userquizcompletionUncheckedCreateWithoutUsersInput> | userquizcompletionCreateWithoutUsersInput[] | userquizcompletionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userquizcompletionCreateOrConnectWithoutUsersInput | userquizcompletionCreateOrConnectWithoutUsersInput[]
    createMany?: userquizcompletionCreateManyUsersInputEnvelope
    connect?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
  }

  export type userroleCreateNestedOneWithoutUsersInput = {
    create?: XOR<userroleCreateWithoutUsersInput, userroleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: userroleCreateOrConnectWithoutUsersInput
    connect?: userroleWhereUniqueInput
  }

  export type usertourcompletionCreateNestedManyWithoutUsersInput = {
    create?: XOR<usertourcompletionCreateWithoutUsersInput, usertourcompletionUncheckedCreateWithoutUsersInput> | usertourcompletionCreateWithoutUsersInput[] | usertourcompletionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usertourcompletionCreateOrConnectWithoutUsersInput | usertourcompletionCreateOrConnectWithoutUsersInput[]
    createMany?: usertourcompletionCreateManyUsersInputEnvelope
    connect?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
  }

  export type auditlogUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<auditlogCreateWithoutUsersInput, auditlogUncheckedCreateWithoutUsersInput> | auditlogCreateWithoutUsersInput[] | auditlogUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutUsersInput | auditlogCreateOrConnectWithoutUsersInput[]
    createMany?: auditlogCreateManyUsersInputEnvelope
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
  }

  export type reviewUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<reviewCreateWithoutUsersInput, reviewUncheckedCreateWithoutUsersInput> | reviewCreateWithoutUsersInput[] | reviewUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutUsersInput | reviewCreateOrConnectWithoutUsersInput[]
    createMany?: reviewCreateManyUsersInputEnvelope
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
  }

  export type sessionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type userbadgeUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<userbadgeCreateWithoutUsersInput, userbadgeUncheckedCreateWithoutUsersInput> | userbadgeCreateWithoutUsersInput[] | userbadgeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userbadgeCreateOrConnectWithoutUsersInput | userbadgeCreateOrConnectWithoutUsersInput[]
    createMany?: userbadgeCreateManyUsersInputEnvelope
    connect?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
  }

  export type usercheckpointattemptUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<usercheckpointattemptCreateWithoutUsersInput, usercheckpointattemptUncheckedCreateWithoutUsersInput> | usercheckpointattemptCreateWithoutUsersInput[] | usercheckpointattemptUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usercheckpointattemptCreateOrConnectWithoutUsersInput | usercheckpointattemptCreateOrConnectWithoutUsersInput[]
    createMany?: usercheckpointattemptCreateManyUsersInputEnvelope
    connect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
  }

  export type userprofileUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<userprofileCreateWithoutUsersInput, userprofileUncheckedCreateWithoutUsersInput>
    connectOrCreate?: userprofileCreateOrConnectWithoutUsersInput
    connect?: userprofileWhereUniqueInput
  }

  export type userquizcompletionUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<userquizcompletionCreateWithoutUsersInput, userquizcompletionUncheckedCreateWithoutUsersInput> | userquizcompletionCreateWithoutUsersInput[] | userquizcompletionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userquizcompletionCreateOrConnectWithoutUsersInput | userquizcompletionCreateOrConnectWithoutUsersInput[]
    createMany?: userquizcompletionCreateManyUsersInputEnvelope
    connect?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<userroleCreateWithoutUsersInput, userroleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: userroleCreateOrConnectWithoutUsersInput
    connect?: userroleWhereUniqueInput
  }

  export type usertourcompletionUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<usertourcompletionCreateWithoutUsersInput, usertourcompletionUncheckedCreateWithoutUsersInput> | usertourcompletionCreateWithoutUsersInput[] | usertourcompletionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usertourcompletionCreateOrConnectWithoutUsersInput | usertourcompletionCreateOrConnectWithoutUsersInput[]
    createMany?: usertourcompletionCreateManyUsersInputEnvelope
    connect?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
  }

  export type auditlogUpdateManyWithoutUsersNestedInput = {
    create?: XOR<auditlogCreateWithoutUsersInput, auditlogUncheckedCreateWithoutUsersInput> | auditlogCreateWithoutUsersInput[] | auditlogUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutUsersInput | auditlogCreateOrConnectWithoutUsersInput[]
    upsert?: auditlogUpsertWithWhereUniqueWithoutUsersInput | auditlogUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: auditlogCreateManyUsersInputEnvelope
    set?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    disconnect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    delete?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    update?: auditlogUpdateWithWhereUniqueWithoutUsersInput | auditlogUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: auditlogUpdateManyWithWhereWithoutUsersInput | auditlogUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
  }

  export type reviewUpdateManyWithoutUsersNestedInput = {
    create?: XOR<reviewCreateWithoutUsersInput, reviewUncheckedCreateWithoutUsersInput> | reviewCreateWithoutUsersInput[] | reviewUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutUsersInput | reviewCreateOrConnectWithoutUsersInput[]
    upsert?: reviewUpsertWithWhereUniqueWithoutUsersInput | reviewUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: reviewCreateManyUsersInputEnvelope
    set?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    disconnect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    delete?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    update?: reviewUpdateWithWhereUniqueWithoutUsersInput | reviewUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: reviewUpdateManyWithWhereWithoutUsersInput | reviewUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: reviewScalarWhereInput | reviewScalarWhereInput[]
  }

  export type sessionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutUsersInput | sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutUsersInput | sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutUsersInput | sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type userbadgeUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userbadgeCreateWithoutUsersInput, userbadgeUncheckedCreateWithoutUsersInput> | userbadgeCreateWithoutUsersInput[] | userbadgeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userbadgeCreateOrConnectWithoutUsersInput | userbadgeCreateOrConnectWithoutUsersInput[]
    upsert?: userbadgeUpsertWithWhereUniqueWithoutUsersInput | userbadgeUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userbadgeCreateManyUsersInputEnvelope
    set?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    disconnect?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    delete?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    connect?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    update?: userbadgeUpdateWithWhereUniqueWithoutUsersInput | userbadgeUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userbadgeUpdateManyWithWhereWithoutUsersInput | userbadgeUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userbadgeScalarWhereInput | userbadgeScalarWhereInput[]
  }

  export type usercheckpointattemptUpdateManyWithoutUsersNestedInput = {
    create?: XOR<usercheckpointattemptCreateWithoutUsersInput, usercheckpointattemptUncheckedCreateWithoutUsersInput> | usercheckpointattemptCreateWithoutUsersInput[] | usercheckpointattemptUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usercheckpointattemptCreateOrConnectWithoutUsersInput | usercheckpointattemptCreateOrConnectWithoutUsersInput[]
    upsert?: usercheckpointattemptUpsertWithWhereUniqueWithoutUsersInput | usercheckpointattemptUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: usercheckpointattemptCreateManyUsersInputEnvelope
    set?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    disconnect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    delete?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    connect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    update?: usercheckpointattemptUpdateWithWhereUniqueWithoutUsersInput | usercheckpointattemptUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: usercheckpointattemptUpdateManyWithWhereWithoutUsersInput | usercheckpointattemptUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: usercheckpointattemptScalarWhereInput | usercheckpointattemptScalarWhereInput[]
  }

  export type userprofileUpdateOneWithoutUsersNestedInput = {
    create?: XOR<userprofileCreateWithoutUsersInput, userprofileUncheckedCreateWithoutUsersInput>
    connectOrCreate?: userprofileCreateOrConnectWithoutUsersInput
    upsert?: userprofileUpsertWithoutUsersInput
    disconnect?: userprofileWhereInput | boolean
    delete?: userprofileWhereInput | boolean
    connect?: userprofileWhereUniqueInput
    update?: XOR<XOR<userprofileUpdateToOneWithWhereWithoutUsersInput, userprofileUpdateWithoutUsersInput>, userprofileUncheckedUpdateWithoutUsersInput>
  }

  export type userquizcompletionUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userquizcompletionCreateWithoutUsersInput, userquizcompletionUncheckedCreateWithoutUsersInput> | userquizcompletionCreateWithoutUsersInput[] | userquizcompletionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userquizcompletionCreateOrConnectWithoutUsersInput | userquizcompletionCreateOrConnectWithoutUsersInput[]
    upsert?: userquizcompletionUpsertWithWhereUniqueWithoutUsersInput | userquizcompletionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userquizcompletionCreateManyUsersInputEnvelope
    set?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    disconnect?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    delete?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    connect?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    update?: userquizcompletionUpdateWithWhereUniqueWithoutUsersInput | userquizcompletionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userquizcompletionUpdateManyWithWhereWithoutUsersInput | userquizcompletionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userquizcompletionScalarWhereInput | userquizcompletionScalarWhereInput[]
  }

  export type userroleUpdateOneWithoutUsersNestedInput = {
    create?: XOR<userroleCreateWithoutUsersInput, userroleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: userroleCreateOrConnectWithoutUsersInput
    upsert?: userroleUpsertWithoutUsersInput
    disconnect?: userroleWhereInput | boolean
    delete?: userroleWhereInput | boolean
    connect?: userroleWhereUniqueInput
    update?: XOR<XOR<userroleUpdateToOneWithWhereWithoutUsersInput, userroleUpdateWithoutUsersInput>, userroleUncheckedUpdateWithoutUsersInput>
  }

  export type usertourcompletionUpdateManyWithoutUsersNestedInput = {
    create?: XOR<usertourcompletionCreateWithoutUsersInput, usertourcompletionUncheckedCreateWithoutUsersInput> | usertourcompletionCreateWithoutUsersInput[] | usertourcompletionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usertourcompletionCreateOrConnectWithoutUsersInput | usertourcompletionCreateOrConnectWithoutUsersInput[]
    upsert?: usertourcompletionUpsertWithWhereUniqueWithoutUsersInput | usertourcompletionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: usertourcompletionCreateManyUsersInputEnvelope
    set?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    disconnect?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    delete?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    connect?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    update?: usertourcompletionUpdateWithWhereUniqueWithoutUsersInput | usertourcompletionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: usertourcompletionUpdateManyWithWhereWithoutUsersInput | usertourcompletionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: usertourcompletionScalarWhereInput | usertourcompletionScalarWhereInput[]
  }

  export type auditlogUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<auditlogCreateWithoutUsersInput, auditlogUncheckedCreateWithoutUsersInput> | auditlogCreateWithoutUsersInput[] | auditlogUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: auditlogCreateOrConnectWithoutUsersInput | auditlogCreateOrConnectWithoutUsersInput[]
    upsert?: auditlogUpsertWithWhereUniqueWithoutUsersInput | auditlogUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: auditlogCreateManyUsersInputEnvelope
    set?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    disconnect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    delete?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    connect?: auditlogWhereUniqueInput | auditlogWhereUniqueInput[]
    update?: auditlogUpdateWithWhereUniqueWithoutUsersInput | auditlogUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: auditlogUpdateManyWithWhereWithoutUsersInput | auditlogUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
  }

  export type reviewUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<reviewCreateWithoutUsersInput, reviewUncheckedCreateWithoutUsersInput> | reviewCreateWithoutUsersInput[] | reviewUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reviewCreateOrConnectWithoutUsersInput | reviewCreateOrConnectWithoutUsersInput[]
    upsert?: reviewUpsertWithWhereUniqueWithoutUsersInput | reviewUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: reviewCreateManyUsersInputEnvelope
    set?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    disconnect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    delete?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    connect?: reviewWhereUniqueInput | reviewWhereUniqueInput[]
    update?: reviewUpdateWithWhereUniqueWithoutUsersInput | reviewUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: reviewUpdateManyWithWhereWithoutUsersInput | reviewUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: reviewScalarWhereInput | reviewScalarWhereInput[]
  }

  export type sessionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutUsersInput | sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutUsersInput | sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutUsersInput | sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type userbadgeUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userbadgeCreateWithoutUsersInput, userbadgeUncheckedCreateWithoutUsersInput> | userbadgeCreateWithoutUsersInput[] | userbadgeUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userbadgeCreateOrConnectWithoutUsersInput | userbadgeCreateOrConnectWithoutUsersInput[]
    upsert?: userbadgeUpsertWithWhereUniqueWithoutUsersInput | userbadgeUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userbadgeCreateManyUsersInputEnvelope
    set?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    disconnect?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    delete?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    connect?: userbadgeWhereUniqueInput | userbadgeWhereUniqueInput[]
    update?: userbadgeUpdateWithWhereUniqueWithoutUsersInput | userbadgeUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userbadgeUpdateManyWithWhereWithoutUsersInput | userbadgeUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userbadgeScalarWhereInput | userbadgeScalarWhereInput[]
  }

  export type usercheckpointattemptUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<usercheckpointattemptCreateWithoutUsersInput, usercheckpointattemptUncheckedCreateWithoutUsersInput> | usercheckpointattemptCreateWithoutUsersInput[] | usercheckpointattemptUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usercheckpointattemptCreateOrConnectWithoutUsersInput | usercheckpointattemptCreateOrConnectWithoutUsersInput[]
    upsert?: usercheckpointattemptUpsertWithWhereUniqueWithoutUsersInput | usercheckpointattemptUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: usercheckpointattemptCreateManyUsersInputEnvelope
    set?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    disconnect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    delete?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    connect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    update?: usercheckpointattemptUpdateWithWhereUniqueWithoutUsersInput | usercheckpointattemptUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: usercheckpointattemptUpdateManyWithWhereWithoutUsersInput | usercheckpointattemptUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: usercheckpointattemptScalarWhereInput | usercheckpointattemptScalarWhereInput[]
  }

  export type userprofileUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<userprofileCreateWithoutUsersInput, userprofileUncheckedCreateWithoutUsersInput>
    connectOrCreate?: userprofileCreateOrConnectWithoutUsersInput
    upsert?: userprofileUpsertWithoutUsersInput
    disconnect?: userprofileWhereInput | boolean
    delete?: userprofileWhereInput | boolean
    connect?: userprofileWhereUniqueInput
    update?: XOR<XOR<userprofileUpdateToOneWithWhereWithoutUsersInput, userprofileUpdateWithoutUsersInput>, userprofileUncheckedUpdateWithoutUsersInput>
  }

  export type userquizcompletionUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userquizcompletionCreateWithoutUsersInput, userquizcompletionUncheckedCreateWithoutUsersInput> | userquizcompletionCreateWithoutUsersInput[] | userquizcompletionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userquizcompletionCreateOrConnectWithoutUsersInput | userquizcompletionCreateOrConnectWithoutUsersInput[]
    upsert?: userquizcompletionUpsertWithWhereUniqueWithoutUsersInput | userquizcompletionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userquizcompletionCreateManyUsersInputEnvelope
    set?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    disconnect?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    delete?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    connect?: userquizcompletionWhereUniqueInput | userquizcompletionWhereUniqueInput[]
    update?: userquizcompletionUpdateWithWhereUniqueWithoutUsersInput | userquizcompletionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userquizcompletionUpdateManyWithWhereWithoutUsersInput | userquizcompletionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userquizcompletionScalarWhereInput | userquizcompletionScalarWhereInput[]
  }

  export type userroleUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<userroleCreateWithoutUsersInput, userroleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: userroleCreateOrConnectWithoutUsersInput
    upsert?: userroleUpsertWithoutUsersInput
    disconnect?: userroleWhereInput | boolean
    delete?: userroleWhereInput | boolean
    connect?: userroleWhereUniqueInput
    update?: XOR<XOR<userroleUpdateToOneWithWhereWithoutUsersInput, userroleUpdateWithoutUsersInput>, userroleUncheckedUpdateWithoutUsersInput>
  }

  export type usertourcompletionUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<usertourcompletionCreateWithoutUsersInput, usertourcompletionUncheckedCreateWithoutUsersInput> | usertourcompletionCreateWithoutUsersInput[] | usertourcompletionUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: usertourcompletionCreateOrConnectWithoutUsersInput | usertourcompletionCreateOrConnectWithoutUsersInput[]
    upsert?: usertourcompletionUpsertWithWhereUniqueWithoutUsersInput | usertourcompletionUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: usertourcompletionCreateManyUsersInputEnvelope
    set?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    disconnect?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    delete?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    connect?: usertourcompletionWhereUniqueInput | usertourcompletionWhereUniqueInput[]
    update?: usertourcompletionUpdateWithWhereUniqueWithoutUsersInput | usertourcompletionUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: usertourcompletionUpdateManyWithWhereWithoutUsersInput | usertourcompletionUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: usertourcompletionScalarWhereInput | usertourcompletionScalarWhereInput[]
  }

  export type usercheckpointattemptCreateNestedManyWithoutUsertourcompletionInput = {
    create?: XOR<usercheckpointattemptCreateWithoutUsertourcompletionInput, usercheckpointattemptUncheckedCreateWithoutUsertourcompletionInput> | usercheckpointattemptCreateWithoutUsertourcompletionInput[] | usercheckpointattemptUncheckedCreateWithoutUsertourcompletionInput[]
    connectOrCreate?: usercheckpointattemptCreateOrConnectWithoutUsertourcompletionInput | usercheckpointattemptCreateOrConnectWithoutUsertourcompletionInput[]
    createMany?: usercheckpointattemptCreateManyUsertourcompletionInputEnvelope
    connect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
  }

  export type tourCreateNestedOneWithoutUsertourcompletionInput = {
    create?: XOR<tourCreateWithoutUsertourcompletionInput, tourUncheckedCreateWithoutUsertourcompletionInput>
    connectOrCreate?: tourCreateOrConnectWithoutUsertourcompletionInput
    connect?: tourWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUsertourcompletionInput = {
    create?: XOR<usersCreateWithoutUsertourcompletionInput, usersUncheckedCreateWithoutUsertourcompletionInput>
    connectOrCreate?: usersCreateOrConnectWithoutUsertourcompletionInput
    connect?: usersWhereUniqueInput
  }

  export type usercheckpointattemptUncheckedCreateNestedManyWithoutUsertourcompletionInput = {
    create?: XOR<usercheckpointattemptCreateWithoutUsertourcompletionInput, usercheckpointattemptUncheckedCreateWithoutUsertourcompletionInput> | usercheckpointattemptCreateWithoutUsertourcompletionInput[] | usercheckpointattemptUncheckedCreateWithoutUsertourcompletionInput[]
    connectOrCreate?: usercheckpointattemptCreateOrConnectWithoutUsertourcompletionInput | usercheckpointattemptCreateOrConnectWithoutUsertourcompletionInput[]
    createMany?: usercheckpointattemptCreateManyUsertourcompletionInputEnvelope
    connect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
  }

  export type usercheckpointattemptUpdateManyWithoutUsertourcompletionNestedInput = {
    create?: XOR<usercheckpointattemptCreateWithoutUsertourcompletionInput, usercheckpointattemptUncheckedCreateWithoutUsertourcompletionInput> | usercheckpointattemptCreateWithoutUsertourcompletionInput[] | usercheckpointattemptUncheckedCreateWithoutUsertourcompletionInput[]
    connectOrCreate?: usercheckpointattemptCreateOrConnectWithoutUsertourcompletionInput | usercheckpointattemptCreateOrConnectWithoutUsertourcompletionInput[]
    upsert?: usercheckpointattemptUpsertWithWhereUniqueWithoutUsertourcompletionInput | usercheckpointattemptUpsertWithWhereUniqueWithoutUsertourcompletionInput[]
    createMany?: usercheckpointattemptCreateManyUsertourcompletionInputEnvelope
    set?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    disconnect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    delete?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    connect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    update?: usercheckpointattemptUpdateWithWhereUniqueWithoutUsertourcompletionInput | usercheckpointattemptUpdateWithWhereUniqueWithoutUsertourcompletionInput[]
    updateMany?: usercheckpointattemptUpdateManyWithWhereWithoutUsertourcompletionInput | usercheckpointattemptUpdateManyWithWhereWithoutUsertourcompletionInput[]
    deleteMany?: usercheckpointattemptScalarWhereInput | usercheckpointattemptScalarWhereInput[]
  }

  export type tourUpdateOneWithoutUsertourcompletionNestedInput = {
    create?: XOR<tourCreateWithoutUsertourcompletionInput, tourUncheckedCreateWithoutUsertourcompletionInput>
    connectOrCreate?: tourCreateOrConnectWithoutUsertourcompletionInput
    upsert?: tourUpsertWithoutUsertourcompletionInput
    disconnect?: tourWhereInput | boolean
    delete?: tourWhereInput | boolean
    connect?: tourWhereUniqueInput
    update?: XOR<XOR<tourUpdateToOneWithWhereWithoutUsertourcompletionInput, tourUpdateWithoutUsertourcompletionInput>, tourUncheckedUpdateWithoutUsertourcompletionInput>
  }

  export type usersUpdateOneRequiredWithoutUsertourcompletionNestedInput = {
    create?: XOR<usersCreateWithoutUsertourcompletionInput, usersUncheckedCreateWithoutUsertourcompletionInput>
    connectOrCreate?: usersCreateOrConnectWithoutUsertourcompletionInput
    upsert?: usersUpsertWithoutUsertourcompletionInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUsertourcompletionInput, usersUpdateWithoutUsertourcompletionInput>, usersUncheckedUpdateWithoutUsertourcompletionInput>
  }

  export type usercheckpointattemptUncheckedUpdateManyWithoutUsertourcompletionNestedInput = {
    create?: XOR<usercheckpointattemptCreateWithoutUsertourcompletionInput, usercheckpointattemptUncheckedCreateWithoutUsertourcompletionInput> | usercheckpointattemptCreateWithoutUsertourcompletionInput[] | usercheckpointattemptUncheckedCreateWithoutUsertourcompletionInput[]
    connectOrCreate?: usercheckpointattemptCreateOrConnectWithoutUsertourcompletionInput | usercheckpointattemptCreateOrConnectWithoutUsertourcompletionInput[]
    upsert?: usercheckpointattemptUpsertWithWhereUniqueWithoutUsertourcompletionInput | usercheckpointattemptUpsertWithWhereUniqueWithoutUsertourcompletionInput[]
    createMany?: usercheckpointattemptCreateManyUsertourcompletionInputEnvelope
    set?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    disconnect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    delete?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    connect?: usercheckpointattemptWhereUniqueInput | usercheckpointattemptWhereUniqueInput[]
    update?: usercheckpointattemptUpdateWithWhereUniqueWithoutUsertourcompletionInput | usercheckpointattemptUpdateWithWhereUniqueWithoutUsertourcompletionInput[]
    updateMany?: usercheckpointattemptUpdateManyWithWhereWithoutUsertourcompletionInput | usercheckpointattemptUpdateManyWithWhereWithoutUsertourcompletionInput[]
    deleteMany?: usercheckpointattemptScalarWhereInput | usercheckpointattemptScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumsec_levelFilter<$PrismaModel = never> = {
    equals?: $Enums.sec_level | Enumsec_levelFieldRefInput<$PrismaModel>
    in?: $Enums.sec_level[] | ListEnumsec_levelFieldRefInput<$PrismaModel>
    notIn?: $Enums.sec_level[] | ListEnumsec_levelFieldRefInput<$PrismaModel>
    not?: NestedEnumsec_levelFilter<$PrismaModel> | $Enums.sec_level
  }

  export type NestedEnumsec_levelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.sec_level | Enumsec_levelFieldRefInput<$PrismaModel>
    in?: $Enums.sec_level[] | ListEnumsec_levelFieldRefInput<$PrismaModel>
    notIn?: $Enums.sec_level[] | ListEnumsec_levelFieldRefInput<$PrismaModel>
    not?: NestedEnumsec_levelWithAggregatesFilter<$PrismaModel> | $Enums.sec_level
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsec_levelFilter<$PrismaModel>
    _max?: NestedEnumsec_levelFilter<$PrismaModel>
  }

  export type auditlogCreateWithoutAuditactionInput = {
    target_id: number
    target_entity?: string | null
    timestamp?: Date | string | null
    sessions?: sessionsCreateNestedOneWithoutAuditlogInput
    users?: usersCreateNestedOneWithoutAuditlogInput
  }

  export type auditlogUncheckedCreateWithoutAuditactionInput = {
    log_id?: number
    user_id?: number | null
    session_id?: number | null
    target_id: number
    target_entity?: string | null
    timestamp?: Date | string | null
  }

  export type auditlogCreateOrConnectWithoutAuditactionInput = {
    where: auditlogWhereUniqueInput
    create: XOR<auditlogCreateWithoutAuditactionInput, auditlogUncheckedCreateWithoutAuditactionInput>
  }

  export type auditlogCreateManyAuditactionInputEnvelope = {
    data: auditlogCreateManyAuditactionInput | auditlogCreateManyAuditactionInput[]
    skipDuplicates?: boolean
  }

  export type auditlogUpsertWithWhereUniqueWithoutAuditactionInput = {
    where: auditlogWhereUniqueInput
    update: XOR<auditlogUpdateWithoutAuditactionInput, auditlogUncheckedUpdateWithoutAuditactionInput>
    create: XOR<auditlogCreateWithoutAuditactionInput, auditlogUncheckedCreateWithoutAuditactionInput>
  }

  export type auditlogUpdateWithWhereUniqueWithoutAuditactionInput = {
    where: auditlogWhereUniqueInput
    data: XOR<auditlogUpdateWithoutAuditactionInput, auditlogUncheckedUpdateWithoutAuditactionInput>
  }

  export type auditlogUpdateManyWithWhereWithoutAuditactionInput = {
    where: auditlogScalarWhereInput
    data: XOR<auditlogUpdateManyMutationInput, auditlogUncheckedUpdateManyWithoutAuditactionInput>
  }

  export type auditlogScalarWhereInput = {
    AND?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
    OR?: auditlogScalarWhereInput[]
    NOT?: auditlogScalarWhereInput | auditlogScalarWhereInput[]
    log_id?: IntFilter<"auditlog"> | number
    user_id?: IntNullableFilter<"auditlog"> | number | null
    session_id?: IntNullableFilter<"auditlog"> | number | null
    action_id?: StringNullableFilter<"auditlog"> | string | null
    target_id?: IntFilter<"auditlog"> | number
    target_entity?: StringNullableFilter<"auditlog"> | string | null
    timestamp?: DateTimeNullableFilter<"auditlog"> | Date | string | null
  }

  export type auditactionCreateWithoutAuditlogInput = {
    action_id: string
    description?: string | null
  }

  export type auditactionUncheckedCreateWithoutAuditlogInput = {
    action_id: string
    description?: string | null
  }

  export type auditactionCreateOrConnectWithoutAuditlogInput = {
    where: auditactionWhereUniqueInput
    create: XOR<auditactionCreateWithoutAuditlogInput, auditactionUncheckedCreateWithoutAuditlogInput>
  }

  export type sessionsCreateWithoutAuditlogInput = {
    access_token?: string | null
    is_active?: boolean | null
    login_at?: Date | string | null
    logout_at?: Date | string | null
    users?: usersCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutAuditlogInput = {
    session_id?: number
    user_id?: number | null
    access_token?: string | null
    is_active?: boolean | null
    login_at?: Date | string | null
    logout_at?: Date | string | null
  }

  export type sessionsCreateOrConnectWithoutAuditlogInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutAuditlogInput, sessionsUncheckedCreateWithoutAuditlogInput>
  }

  export type usersCreateWithoutAuditlogInput = {
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    review?: reviewCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutUsersInput
    userprofile?: userprofileCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAuditlogInput = {
    user_id?: number
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeUncheckedCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutUsersInput
    userprofile?: userprofileUncheckedCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAuditlogInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAuditlogInput, usersUncheckedCreateWithoutAuditlogInput>
  }

  export type auditactionUpsertWithoutAuditlogInput = {
    update: XOR<auditactionUpdateWithoutAuditlogInput, auditactionUncheckedUpdateWithoutAuditlogInput>
    create: XOR<auditactionCreateWithoutAuditlogInput, auditactionUncheckedCreateWithoutAuditlogInput>
    where?: auditactionWhereInput
  }

  export type auditactionUpdateToOneWithWhereWithoutAuditlogInput = {
    where?: auditactionWhereInput
    data: XOR<auditactionUpdateWithoutAuditlogInput, auditactionUncheckedUpdateWithoutAuditlogInput>
  }

  export type auditactionUpdateWithoutAuditlogInput = {
    action_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditactionUncheckedUpdateWithoutAuditlogInput = {
    action_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sessionsUpsertWithoutAuditlogInput = {
    update: XOR<sessionsUpdateWithoutAuditlogInput, sessionsUncheckedUpdateWithoutAuditlogInput>
    create: XOR<sessionsCreateWithoutAuditlogInput, sessionsUncheckedCreateWithoutAuditlogInput>
    where?: sessionsWhereInput
  }

  export type sessionsUpdateToOneWithWhereWithoutAuditlogInput = {
    where?: sessionsWhereInput
    data: XOR<sessionsUpdateWithoutAuditlogInput, sessionsUncheckedUpdateWithoutAuditlogInput>
  }

  export type sessionsUpdateWithoutAuditlogInput = {
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logout_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutAuditlogInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logout_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpsertWithoutAuditlogInput = {
    update: XOR<usersUpdateWithoutAuditlogInput, usersUncheckedUpdateWithoutAuditlogInput>
    create: XOR<usersCreateWithoutAuditlogInput, usersUncheckedCreateWithoutAuditlogInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAuditlogInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAuditlogInput, usersUncheckedUpdateWithoutAuditlogInput>
  }

  export type usersUpdateWithoutAuditlogInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review?: reviewUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAuditlogInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUncheckedUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUncheckedUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type tourCreateWithoutBadgeInput = {
    tour_name: string
    description?: string | null
    created_at?: Date | string | null
    review?: reviewCreateNestedManyWithoutTourInput
    tourcheckpoint?: tourcheckpointCreateNestedManyWithoutTourInput
    usertourcompletion?: usertourcompletionCreateNestedManyWithoutTourInput
  }

  export type tourUncheckedCreateWithoutBadgeInput = {
    tour_id?: number
    tour_name: string
    description?: string | null
    created_at?: Date | string | null
    review?: reviewUncheckedCreateNestedManyWithoutTourInput
    tourcheckpoint?: tourcheckpointUncheckedCreateNestedManyWithoutTourInput
    usertourcompletion?: usertourcompletionUncheckedCreateNestedManyWithoutTourInput
  }

  export type tourCreateOrConnectWithoutBadgeInput = {
    where: tourWhereUniqueInput
    create: XOR<tourCreateWithoutBadgeInput, tourUncheckedCreateWithoutBadgeInput>
  }

  export type userbadgeCreateWithoutBadgeInput = {
    created_at?: Date | string | null
    users: usersCreateNestedOneWithoutUserbadgeInput
  }

  export type userbadgeUncheckedCreateWithoutBadgeInput = {
    user_id: number
    created_at?: Date | string | null
  }

  export type userbadgeCreateOrConnectWithoutBadgeInput = {
    where: userbadgeWhereUniqueInput
    create: XOR<userbadgeCreateWithoutBadgeInput, userbadgeUncheckedCreateWithoutBadgeInput>
  }

  export type userbadgeCreateManyBadgeInputEnvelope = {
    data: userbadgeCreateManyBadgeInput | userbadgeCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type tourUpsertWithoutBadgeInput = {
    update: XOR<tourUpdateWithoutBadgeInput, tourUncheckedUpdateWithoutBadgeInput>
    create: XOR<tourCreateWithoutBadgeInput, tourUncheckedCreateWithoutBadgeInput>
    where?: tourWhereInput
  }

  export type tourUpdateToOneWithWhereWithoutBadgeInput = {
    where?: tourWhereInput
    data: XOR<tourUpdateWithoutBadgeInput, tourUncheckedUpdateWithoutBadgeInput>
  }

  export type tourUpdateWithoutBadgeInput = {
    tour_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review?: reviewUpdateManyWithoutTourNestedInput
    tourcheckpoint?: tourcheckpointUpdateManyWithoutTourNestedInput
    usertourcompletion?: usertourcompletionUpdateManyWithoutTourNestedInput
  }

  export type tourUncheckedUpdateWithoutBadgeInput = {
    tour_id?: IntFieldUpdateOperationsInput | number
    tour_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    review?: reviewUncheckedUpdateManyWithoutTourNestedInput
    tourcheckpoint?: tourcheckpointUncheckedUpdateManyWithoutTourNestedInput
    usertourcompletion?: usertourcompletionUncheckedUpdateManyWithoutTourNestedInput
  }

  export type userbadgeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: userbadgeWhereUniqueInput
    update: XOR<userbadgeUpdateWithoutBadgeInput, userbadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<userbadgeCreateWithoutBadgeInput, userbadgeUncheckedCreateWithoutBadgeInput>
  }

  export type userbadgeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: userbadgeWhereUniqueInput
    data: XOR<userbadgeUpdateWithoutBadgeInput, userbadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type userbadgeUpdateManyWithWhereWithoutBadgeInput = {
    where: userbadgeScalarWhereInput
    data: XOR<userbadgeUpdateManyMutationInput, userbadgeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type userbadgeScalarWhereInput = {
    AND?: userbadgeScalarWhereInput | userbadgeScalarWhereInput[]
    OR?: userbadgeScalarWhereInput[]
    NOT?: userbadgeScalarWhereInput | userbadgeScalarWhereInput[]
    badge_id?: IntFilter<"userbadge"> | number
    user_id?: IntFilter<"userbadge"> | number
    created_at?: DateTimeNullableFilter<"userbadge"> | Date | string | null
  }

  export type locationCreateWithoutCheckpointInput = {
    location_name: string
    description?: string | null
    created_at?: Date | string | null
    locationtype?: locationtypeCreateNestedOneWithoutLocationInput
  }

  export type locationUncheckedCreateWithoutCheckpointInput = {
    location_id?: number
    location_name: string
    locationtype_id?: string | null
    description?: string | null
    created_at?: Date | string | null
  }

  export type locationCreateOrConnectWithoutCheckpointInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutCheckpointInput, locationUncheckedCreateWithoutCheckpointInput>
  }

  export type quizCreateWithoutCheckpointInput = {
    quiz_title: string
    description?: string | null
    question?: questionCreateNestedManyWithoutQuizInput
    userquizcompletion?: userquizcompletionCreateNestedManyWithoutQuizInput
  }

  export type quizUncheckedCreateWithoutCheckpointInput = {
    quiz_id?: number
    quiz_title: string
    description?: string | null
    question?: questionUncheckedCreateNestedManyWithoutQuizInput
    userquizcompletion?: userquizcompletionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type quizCreateOrConnectWithoutCheckpointInput = {
    where: quizWhereUniqueInput
    create: XOR<quizCreateWithoutCheckpointInput, quizUncheckedCreateWithoutCheckpointInput>
  }

  export type tourcheckpointCreateWithoutCheckpointInput = {
    checkpoint_order: number
    tour: tourCreateNestedOneWithoutTourcheckpointInput
  }

  export type tourcheckpointUncheckedCreateWithoutCheckpointInput = {
    tour_id: number
    checkpoint_order: number
  }

  export type tourcheckpointCreateOrConnectWithoutCheckpointInput = {
    where: tourcheckpointWhereUniqueInput
    create: XOR<tourcheckpointCreateWithoutCheckpointInput, tourcheckpointUncheckedCreateWithoutCheckpointInput>
  }

  export type tourcheckpointCreateManyCheckpointInputEnvelope = {
    data: tourcheckpointCreateManyCheckpointInput | tourcheckpointCreateManyCheckpointInput[]
    skipDuplicates?: boolean
  }

  export type usercheckpointattemptCreateWithoutCheckpointInput = {
    created_at?: Date | string | null
    usertourcompletion: usertourcompletionCreateNestedOneWithoutUsercheckpointattemptInput
    users: usersCreateNestedOneWithoutUsercheckpointattemptInput
  }

  export type usercheckpointattemptUncheckedCreateWithoutCheckpointInput = {
    checkpointattempt_id?: number
    user_id: number
    tourcompletion_id: number
    created_at?: Date | string | null
  }

  export type usercheckpointattemptCreateOrConnectWithoutCheckpointInput = {
    where: usercheckpointattemptWhereUniqueInput
    create: XOR<usercheckpointattemptCreateWithoutCheckpointInput, usercheckpointattemptUncheckedCreateWithoutCheckpointInput>
  }

  export type usercheckpointattemptCreateManyCheckpointInputEnvelope = {
    data: usercheckpointattemptCreateManyCheckpointInput | usercheckpointattemptCreateManyCheckpointInput[]
    skipDuplicates?: boolean
  }

  export type locationUpsertWithoutCheckpointInput = {
    update: XOR<locationUpdateWithoutCheckpointInput, locationUncheckedUpdateWithoutCheckpointInput>
    create: XOR<locationCreateWithoutCheckpointInput, locationUncheckedCreateWithoutCheckpointInput>
    where?: locationWhereInput
  }

  export type locationUpdateToOneWithWhereWithoutCheckpointInput = {
    where?: locationWhereInput
    data: XOR<locationUpdateWithoutCheckpointInput, locationUncheckedUpdateWithoutCheckpointInput>
  }

  export type locationUpdateWithoutCheckpointInput = {
    location_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    locationtype?: locationtypeUpdateOneWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateWithoutCheckpointInput = {
    location_id?: IntFieldUpdateOperationsInput | number
    location_name?: StringFieldUpdateOperationsInput | string
    locationtype_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type quizUpsertWithoutCheckpointInput = {
    update: XOR<quizUpdateWithoutCheckpointInput, quizUncheckedUpdateWithoutCheckpointInput>
    create: XOR<quizCreateWithoutCheckpointInput, quizUncheckedCreateWithoutCheckpointInput>
    where?: quizWhereInput
  }

  export type quizUpdateToOneWithWhereWithoutCheckpointInput = {
    where?: quizWhereInput
    data: XOR<quizUpdateWithoutCheckpointInput, quizUncheckedUpdateWithoutCheckpointInput>
  }

  export type quizUpdateWithoutCheckpointInput = {
    quiz_title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    question?: questionUpdateManyWithoutQuizNestedInput
    userquizcompletion?: userquizcompletionUpdateManyWithoutQuizNestedInput
  }

  export type quizUncheckedUpdateWithoutCheckpointInput = {
    quiz_id?: IntFieldUpdateOperationsInput | number
    quiz_title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    question?: questionUncheckedUpdateManyWithoutQuizNestedInput
    userquizcompletion?: userquizcompletionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type tourcheckpointUpsertWithWhereUniqueWithoutCheckpointInput = {
    where: tourcheckpointWhereUniqueInput
    update: XOR<tourcheckpointUpdateWithoutCheckpointInput, tourcheckpointUncheckedUpdateWithoutCheckpointInput>
    create: XOR<tourcheckpointCreateWithoutCheckpointInput, tourcheckpointUncheckedCreateWithoutCheckpointInput>
  }

  export type tourcheckpointUpdateWithWhereUniqueWithoutCheckpointInput = {
    where: tourcheckpointWhereUniqueInput
    data: XOR<tourcheckpointUpdateWithoutCheckpointInput, tourcheckpointUncheckedUpdateWithoutCheckpointInput>
  }

  export type tourcheckpointUpdateManyWithWhereWithoutCheckpointInput = {
    where: tourcheckpointScalarWhereInput
    data: XOR<tourcheckpointUpdateManyMutationInput, tourcheckpointUncheckedUpdateManyWithoutCheckpointInput>
  }

  export type tourcheckpointScalarWhereInput = {
    AND?: tourcheckpointScalarWhereInput | tourcheckpointScalarWhereInput[]
    OR?: tourcheckpointScalarWhereInput[]
    NOT?: tourcheckpointScalarWhereInput | tourcheckpointScalarWhereInput[]
    tour_id?: IntFilter<"tourcheckpoint"> | number
    checkpoint_id?: IntFilter<"tourcheckpoint"> | number
    checkpoint_order?: IntFilter<"tourcheckpoint"> | number
  }

  export type usercheckpointattemptUpsertWithWhereUniqueWithoutCheckpointInput = {
    where: usercheckpointattemptWhereUniqueInput
    update: XOR<usercheckpointattemptUpdateWithoutCheckpointInput, usercheckpointattemptUncheckedUpdateWithoutCheckpointInput>
    create: XOR<usercheckpointattemptCreateWithoutCheckpointInput, usercheckpointattemptUncheckedCreateWithoutCheckpointInput>
  }

  export type usercheckpointattemptUpdateWithWhereUniqueWithoutCheckpointInput = {
    where: usercheckpointattemptWhereUniqueInput
    data: XOR<usercheckpointattemptUpdateWithoutCheckpointInput, usercheckpointattemptUncheckedUpdateWithoutCheckpointInput>
  }

  export type usercheckpointattemptUpdateManyWithWhereWithoutCheckpointInput = {
    where: usercheckpointattemptScalarWhereInput
    data: XOR<usercheckpointattemptUpdateManyMutationInput, usercheckpointattemptUncheckedUpdateManyWithoutCheckpointInput>
  }

  export type usercheckpointattemptScalarWhereInput = {
    AND?: usercheckpointattemptScalarWhereInput | usercheckpointattemptScalarWhereInput[]
    OR?: usercheckpointattemptScalarWhereInput[]
    NOT?: usercheckpointattemptScalarWhereInput | usercheckpointattemptScalarWhereInput[]
    checkpointattempt_id?: IntFilter<"usercheckpointattempt"> | number
    user_id?: IntFilter<"usercheckpointattempt"> | number
    checkpoint_id?: IntNullableFilter<"usercheckpointattempt"> | number | null
    tourcompletion_id?: IntFilter<"usercheckpointattempt"> | number
    created_at?: DateTimeNullableFilter<"usercheckpointattempt"> | Date | string | null
  }

  export type checkpointCreateWithoutLocationInput = {
    points_reward: number
    created_at?: Date | string | null
    quiz?: quizCreateNestedOneWithoutCheckpointInput
    tourcheckpoint?: tourcheckpointCreateNestedManyWithoutCheckpointInput
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointUncheckedCreateWithoutLocationInput = {
    checkpoint_id?: number
    quiz_id?: number | null
    points_reward: number
    created_at?: Date | string | null
    tourcheckpoint?: tourcheckpointUncheckedCreateNestedManyWithoutCheckpointInput
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointCreateOrConnectWithoutLocationInput = {
    where: checkpointWhereUniqueInput
    create: XOR<checkpointCreateWithoutLocationInput, checkpointUncheckedCreateWithoutLocationInput>
  }

  export type checkpointCreateManyLocationInputEnvelope = {
    data: checkpointCreateManyLocationInput | checkpointCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type locationtypeCreateWithoutLocationInput = {
    locationtype_id: string
    description?: string | null
  }

  export type locationtypeUncheckedCreateWithoutLocationInput = {
    locationtype_id: string
    description?: string | null
  }

  export type locationtypeCreateOrConnectWithoutLocationInput = {
    where: locationtypeWhereUniqueInput
    create: XOR<locationtypeCreateWithoutLocationInput, locationtypeUncheckedCreateWithoutLocationInput>
  }

  export type checkpointUpsertWithWhereUniqueWithoutLocationInput = {
    where: checkpointWhereUniqueInput
    update: XOR<checkpointUpdateWithoutLocationInput, checkpointUncheckedUpdateWithoutLocationInput>
    create: XOR<checkpointCreateWithoutLocationInput, checkpointUncheckedCreateWithoutLocationInput>
  }

  export type checkpointUpdateWithWhereUniqueWithoutLocationInput = {
    where: checkpointWhereUniqueInput
    data: XOR<checkpointUpdateWithoutLocationInput, checkpointUncheckedUpdateWithoutLocationInput>
  }

  export type checkpointUpdateManyWithWhereWithoutLocationInput = {
    where: checkpointScalarWhereInput
    data: XOR<checkpointUpdateManyMutationInput, checkpointUncheckedUpdateManyWithoutLocationInput>
  }

  export type checkpointScalarWhereInput = {
    AND?: checkpointScalarWhereInput | checkpointScalarWhereInput[]
    OR?: checkpointScalarWhereInput[]
    NOT?: checkpointScalarWhereInput | checkpointScalarWhereInput[]
    checkpoint_id?: IntFilter<"checkpoint"> | number
    quiz_id?: IntNullableFilter<"checkpoint"> | number | null
    location_id?: IntFilter<"checkpoint"> | number
    points_reward?: IntFilter<"checkpoint"> | number
    created_at?: DateTimeNullableFilter<"checkpoint"> | Date | string | null
  }

  export type locationtypeUpsertWithoutLocationInput = {
    update: XOR<locationtypeUpdateWithoutLocationInput, locationtypeUncheckedUpdateWithoutLocationInput>
    create: XOR<locationtypeCreateWithoutLocationInput, locationtypeUncheckedCreateWithoutLocationInput>
    where?: locationtypeWhereInput
  }

  export type locationtypeUpdateToOneWithWhereWithoutLocationInput = {
    where?: locationtypeWhereInput
    data: XOR<locationtypeUpdateWithoutLocationInput, locationtypeUncheckedUpdateWithoutLocationInput>
  }

  export type locationtypeUpdateWithoutLocationInput = {
    locationtype_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locationtypeUncheckedUpdateWithoutLocationInput = {
    locationtype_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type locationCreateWithoutLocationtypeInput = {
    location_name: string
    description?: string | null
    created_at?: Date | string | null
    checkpoint?: checkpointCreateNestedManyWithoutLocationInput
  }

  export type locationUncheckedCreateWithoutLocationtypeInput = {
    location_id?: number
    location_name: string
    description?: string | null
    created_at?: Date | string | null
    checkpoint?: checkpointUncheckedCreateNestedManyWithoutLocationInput
  }

  export type locationCreateOrConnectWithoutLocationtypeInput = {
    where: locationWhereUniqueInput
    create: XOR<locationCreateWithoutLocationtypeInput, locationUncheckedCreateWithoutLocationtypeInput>
  }

  export type locationCreateManyLocationtypeInputEnvelope = {
    data: locationCreateManyLocationtypeInput | locationCreateManyLocationtypeInput[]
    skipDuplicates?: boolean
  }

  export type locationUpsertWithWhereUniqueWithoutLocationtypeInput = {
    where: locationWhereUniqueInput
    update: XOR<locationUpdateWithoutLocationtypeInput, locationUncheckedUpdateWithoutLocationtypeInput>
    create: XOR<locationCreateWithoutLocationtypeInput, locationUncheckedCreateWithoutLocationtypeInput>
  }

  export type locationUpdateWithWhereUniqueWithoutLocationtypeInput = {
    where: locationWhereUniqueInput
    data: XOR<locationUpdateWithoutLocationtypeInput, locationUncheckedUpdateWithoutLocationtypeInput>
  }

  export type locationUpdateManyWithWhereWithoutLocationtypeInput = {
    where: locationScalarWhereInput
    data: XOR<locationUpdateManyMutationInput, locationUncheckedUpdateManyWithoutLocationtypeInput>
  }

  export type locationScalarWhereInput = {
    AND?: locationScalarWhereInput | locationScalarWhereInput[]
    OR?: locationScalarWhereInput[]
    NOT?: locationScalarWhereInput | locationScalarWhereInput[]
    location_id?: IntFilter<"location"> | number
    location_name?: StringFilter<"location"> | string
    locationtype_id?: StringNullableFilter<"location"> | string | null
    description?: StringNullableFilter<"location"> | string | null
    created_at?: DateTimeNullableFilter<"location"> | Date | string | null
  }

  export type rolepermissionCreateWithoutPermissionInput = {
    created_at?: Date | string | null
    role: roleCreateNestedOneWithoutRolepermissionInput
  }

  export type rolepermissionUncheckedCreateWithoutPermissionInput = {
    role_id: number
    created_at?: Date | string | null
  }

  export type rolepermissionCreateOrConnectWithoutPermissionInput = {
    where: rolepermissionWhereUniqueInput
    create: XOR<rolepermissionCreateWithoutPermissionInput, rolepermissionUncheckedCreateWithoutPermissionInput>
  }

  export type rolepermissionCreateManyPermissionInputEnvelope = {
    data: rolepermissionCreateManyPermissionInput | rolepermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type rolepermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: rolepermissionWhereUniqueInput
    update: XOR<rolepermissionUpdateWithoutPermissionInput, rolepermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<rolepermissionCreateWithoutPermissionInput, rolepermissionUncheckedCreateWithoutPermissionInput>
  }

  export type rolepermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: rolepermissionWhereUniqueInput
    data: XOR<rolepermissionUpdateWithoutPermissionInput, rolepermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type rolepermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: rolepermissionScalarWhereInput
    data: XOR<rolepermissionUpdateManyMutationInput, rolepermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type rolepermissionScalarWhereInput = {
    AND?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
    OR?: rolepermissionScalarWhereInput[]
    NOT?: rolepermissionScalarWhereInput | rolepermissionScalarWhereInput[]
    role_id?: IntFilter<"rolepermission"> | number
    permission_id?: IntFilter<"rolepermission"> | number
    created_at?: DateTimeNullableFilter<"rolepermission"> | Date | string | null
  }

  export type quizCreateWithoutQuestionInput = {
    quiz_title: string
    description?: string | null
    checkpoint?: checkpointCreateNestedManyWithoutQuizInput
    userquizcompletion?: userquizcompletionCreateNestedManyWithoutQuizInput
  }

  export type quizUncheckedCreateWithoutQuestionInput = {
    quiz_id?: number
    quiz_title: string
    description?: string | null
    checkpoint?: checkpointUncheckedCreateNestedManyWithoutQuizInput
    userquizcompletion?: userquizcompletionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type quizCreateOrConnectWithoutQuestionInput = {
    where: quizWhereUniqueInput
    create: XOR<quizCreateWithoutQuestionInput, quizUncheckedCreateWithoutQuestionInput>
  }

  export type questionoptionCreateWithoutQuestionInput = {
    option: string
    is_correct: boolean
  }

  export type questionoptionUncheckedCreateWithoutQuestionInput = {
    option_id?: number
    option: string
    is_correct: boolean
  }

  export type questionoptionCreateOrConnectWithoutQuestionInput = {
    where: questionoptionWhereUniqueInput
    create: XOR<questionoptionCreateWithoutQuestionInput, questionoptionUncheckedCreateWithoutQuestionInput>
  }

  export type questionoptionCreateManyQuestionInputEnvelope = {
    data: questionoptionCreateManyQuestionInput | questionoptionCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type quizUpsertWithoutQuestionInput = {
    update: XOR<quizUpdateWithoutQuestionInput, quizUncheckedUpdateWithoutQuestionInput>
    create: XOR<quizCreateWithoutQuestionInput, quizUncheckedCreateWithoutQuestionInput>
    where?: quizWhereInput
  }

  export type quizUpdateToOneWithWhereWithoutQuestionInput = {
    where?: quizWhereInput
    data: XOR<quizUpdateWithoutQuestionInput, quizUncheckedUpdateWithoutQuestionInput>
  }

  export type quizUpdateWithoutQuestionInput = {
    quiz_title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoint?: checkpointUpdateManyWithoutQuizNestedInput
    userquizcompletion?: userquizcompletionUpdateManyWithoutQuizNestedInput
  }

  export type quizUncheckedUpdateWithoutQuestionInput = {
    quiz_id?: IntFieldUpdateOperationsInput | number
    quiz_title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoint?: checkpointUncheckedUpdateManyWithoutQuizNestedInput
    userquizcompletion?: userquizcompletionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type questionoptionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: questionoptionWhereUniqueInput
    update: XOR<questionoptionUpdateWithoutQuestionInput, questionoptionUncheckedUpdateWithoutQuestionInput>
    create: XOR<questionoptionCreateWithoutQuestionInput, questionoptionUncheckedCreateWithoutQuestionInput>
  }

  export type questionoptionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: questionoptionWhereUniqueInput
    data: XOR<questionoptionUpdateWithoutQuestionInput, questionoptionUncheckedUpdateWithoutQuestionInput>
  }

  export type questionoptionUpdateManyWithWhereWithoutQuestionInput = {
    where: questionoptionScalarWhereInput
    data: XOR<questionoptionUpdateManyMutationInput, questionoptionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type questionoptionScalarWhereInput = {
    AND?: questionoptionScalarWhereInput | questionoptionScalarWhereInput[]
    OR?: questionoptionScalarWhereInput[]
    NOT?: questionoptionScalarWhereInput | questionoptionScalarWhereInput[]
    option_id?: IntFilter<"questionoption"> | number
    option?: StringFilter<"questionoption"> | string
    is_correct?: BoolFilter<"questionoption"> | boolean
    question_id?: IntFilter<"questionoption"> | number
  }

  export type questionCreateWithoutQuestionoptionInput = {
    question: string
    quiz?: quizCreateNestedOneWithoutQuestionInput
  }

  export type questionUncheckedCreateWithoutQuestionoptionInput = {
    question_id?: number
    question: string
    quiz_id?: number | null
  }

  export type questionCreateOrConnectWithoutQuestionoptionInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutQuestionoptionInput, questionUncheckedCreateWithoutQuestionoptionInput>
  }

  export type questionUpsertWithoutQuestionoptionInput = {
    update: XOR<questionUpdateWithoutQuestionoptionInput, questionUncheckedUpdateWithoutQuestionoptionInput>
    create: XOR<questionCreateWithoutQuestionoptionInput, questionUncheckedCreateWithoutQuestionoptionInput>
    where?: questionWhereInput
  }

  export type questionUpdateToOneWithWhereWithoutQuestionoptionInput = {
    where?: questionWhereInput
    data: XOR<questionUpdateWithoutQuestionoptionInput, questionUncheckedUpdateWithoutQuestionoptionInput>
  }

  export type questionUpdateWithoutQuestionoptionInput = {
    question?: StringFieldUpdateOperationsInput | string
    quiz?: quizUpdateOneWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateWithoutQuestionoptionInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    quiz_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type checkpointCreateWithoutQuizInput = {
    points_reward: number
    created_at?: Date | string | null
    location: locationCreateNestedOneWithoutCheckpointInput
    tourcheckpoint?: tourcheckpointCreateNestedManyWithoutCheckpointInput
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointUncheckedCreateWithoutQuizInput = {
    checkpoint_id?: number
    location_id: number
    points_reward: number
    created_at?: Date | string | null
    tourcheckpoint?: tourcheckpointUncheckedCreateNestedManyWithoutCheckpointInput
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointCreateOrConnectWithoutQuizInput = {
    where: checkpointWhereUniqueInput
    create: XOR<checkpointCreateWithoutQuizInput, checkpointUncheckedCreateWithoutQuizInput>
  }

  export type checkpointCreateManyQuizInputEnvelope = {
    data: checkpointCreateManyQuizInput | checkpointCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type questionCreateWithoutQuizInput = {
    question: string
    questionoption?: questionoptionCreateNestedManyWithoutQuestionInput
  }

  export type questionUncheckedCreateWithoutQuizInput = {
    question_id?: number
    question: string
    questionoption?: questionoptionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionCreateOrConnectWithoutQuizInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutQuizInput, questionUncheckedCreateWithoutQuizInput>
  }

  export type questionCreateManyQuizInputEnvelope = {
    data: questionCreateManyQuizInput | questionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type userquizcompletionCreateWithoutQuizInput = {
    score: number
    created_at?: Date | string | null
    users: usersCreateNestedOneWithoutUserquizcompletionInput
  }

  export type userquizcompletionUncheckedCreateWithoutQuizInput = {
    quizcompletion_id?: number
    user_id: number
    score: number
    created_at?: Date | string | null
  }

  export type userquizcompletionCreateOrConnectWithoutQuizInput = {
    where: userquizcompletionWhereUniqueInput
    create: XOR<userquizcompletionCreateWithoutQuizInput, userquizcompletionUncheckedCreateWithoutQuizInput>
  }

  export type userquizcompletionCreateManyQuizInputEnvelope = {
    data: userquizcompletionCreateManyQuizInput | userquizcompletionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type checkpointUpsertWithWhereUniqueWithoutQuizInput = {
    where: checkpointWhereUniqueInput
    update: XOR<checkpointUpdateWithoutQuizInput, checkpointUncheckedUpdateWithoutQuizInput>
    create: XOR<checkpointCreateWithoutQuizInput, checkpointUncheckedCreateWithoutQuizInput>
  }

  export type checkpointUpdateWithWhereUniqueWithoutQuizInput = {
    where: checkpointWhereUniqueInput
    data: XOR<checkpointUpdateWithoutQuizInput, checkpointUncheckedUpdateWithoutQuizInput>
  }

  export type checkpointUpdateManyWithWhereWithoutQuizInput = {
    where: checkpointScalarWhereInput
    data: XOR<checkpointUpdateManyMutationInput, checkpointUncheckedUpdateManyWithoutQuizInput>
  }

  export type questionUpsertWithWhereUniqueWithoutQuizInput = {
    where: questionWhereUniqueInput
    update: XOR<questionUpdateWithoutQuizInput, questionUncheckedUpdateWithoutQuizInput>
    create: XOR<questionCreateWithoutQuizInput, questionUncheckedCreateWithoutQuizInput>
  }

  export type questionUpdateWithWhereUniqueWithoutQuizInput = {
    where: questionWhereUniqueInput
    data: XOR<questionUpdateWithoutQuizInput, questionUncheckedUpdateWithoutQuizInput>
  }

  export type questionUpdateManyWithWhereWithoutQuizInput = {
    where: questionScalarWhereInput
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyWithoutQuizInput>
  }

  export type questionScalarWhereInput = {
    AND?: questionScalarWhereInput | questionScalarWhereInput[]
    OR?: questionScalarWhereInput[]
    NOT?: questionScalarWhereInput | questionScalarWhereInput[]
    question_id?: IntFilter<"question"> | number
    question?: StringFilter<"question"> | string
    quiz_id?: IntNullableFilter<"question"> | number | null
  }

  export type userquizcompletionUpsertWithWhereUniqueWithoutQuizInput = {
    where: userquizcompletionWhereUniqueInput
    update: XOR<userquizcompletionUpdateWithoutQuizInput, userquizcompletionUncheckedUpdateWithoutQuizInput>
    create: XOR<userquizcompletionCreateWithoutQuizInput, userquizcompletionUncheckedCreateWithoutQuizInput>
  }

  export type userquizcompletionUpdateWithWhereUniqueWithoutQuizInput = {
    where: userquizcompletionWhereUniqueInput
    data: XOR<userquizcompletionUpdateWithoutQuizInput, userquizcompletionUncheckedUpdateWithoutQuizInput>
  }

  export type userquizcompletionUpdateManyWithWhereWithoutQuizInput = {
    where: userquizcompletionScalarWhereInput
    data: XOR<userquizcompletionUpdateManyMutationInput, userquizcompletionUncheckedUpdateManyWithoutQuizInput>
  }

  export type userquizcompletionScalarWhereInput = {
    AND?: userquizcompletionScalarWhereInput | userquizcompletionScalarWhereInput[]
    OR?: userquizcompletionScalarWhereInput[]
    NOT?: userquizcompletionScalarWhereInput | userquizcompletionScalarWhereInput[]
    quizcompletion_id?: IntFilter<"userquizcompletion"> | number
    quiz_id?: IntFilter<"userquizcompletion"> | number
    user_id?: IntFilter<"userquizcompletion"> | number
    score?: IntFilter<"userquizcompletion"> | number
    created_at?: DateTimeNullableFilter<"userquizcompletion"> | Date | string | null
  }

  export type tourCreateWithoutReviewInput = {
    tour_name: string
    description?: string | null
    created_at?: Date | string | null
    badge?: badgeCreateNestedManyWithoutTourInput
    tourcheckpoint?: tourcheckpointCreateNestedManyWithoutTourInput
    usertourcompletion?: usertourcompletionCreateNestedManyWithoutTourInput
  }

  export type tourUncheckedCreateWithoutReviewInput = {
    tour_id?: number
    tour_name: string
    description?: string | null
    created_at?: Date | string | null
    badge?: badgeUncheckedCreateNestedManyWithoutTourInput
    tourcheckpoint?: tourcheckpointUncheckedCreateNestedManyWithoutTourInput
    usertourcompletion?: usertourcompletionUncheckedCreateNestedManyWithoutTourInput
  }

  export type tourCreateOrConnectWithoutReviewInput = {
    where: tourWhereUniqueInput
    create: XOR<tourCreateWithoutReviewInput, tourUncheckedCreateWithoutReviewInput>
  }

  export type usersCreateWithoutReviewInput = {
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutUsersInput
    userprofile?: userprofileCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReviewInput = {
    user_id?: number
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeUncheckedCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutUsersInput
    userprofile?: userprofileUncheckedCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReviewInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReviewInput, usersUncheckedCreateWithoutReviewInput>
  }

  export type tourUpsertWithoutReviewInput = {
    update: XOR<tourUpdateWithoutReviewInput, tourUncheckedUpdateWithoutReviewInput>
    create: XOR<tourCreateWithoutReviewInput, tourUncheckedCreateWithoutReviewInput>
    where?: tourWhereInput
  }

  export type tourUpdateToOneWithWhereWithoutReviewInput = {
    where?: tourWhereInput
    data: XOR<tourUpdateWithoutReviewInput, tourUncheckedUpdateWithoutReviewInput>
  }

  export type tourUpdateWithoutReviewInput = {
    tour_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUpdateManyWithoutTourNestedInput
    tourcheckpoint?: tourcheckpointUpdateManyWithoutTourNestedInput
    usertourcompletion?: usertourcompletionUpdateManyWithoutTourNestedInput
  }

  export type tourUncheckedUpdateWithoutReviewInput = {
    tour_id?: IntFieldUpdateOperationsInput | number
    tour_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUncheckedUpdateManyWithoutTourNestedInput
    tourcheckpoint?: tourcheckpointUncheckedUpdateManyWithoutTourNestedInput
    usertourcompletion?: usertourcompletionUncheckedUpdateManyWithoutTourNestedInput
  }

  export type usersUpsertWithoutReviewInput = {
    update: XOR<usersUpdateWithoutReviewInput, usersUncheckedUpdateWithoutReviewInput>
    create: XOR<usersCreateWithoutReviewInput, usersUncheckedCreateWithoutReviewInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutReviewInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutReviewInput, usersUncheckedUpdateWithoutReviewInput>
  }

  export type usersUpdateWithoutReviewInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReviewInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUncheckedUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUncheckedUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type rolepermissionCreateWithoutRoleInput = {
    created_at?: Date | string | null
    permission: permissionCreateNestedOneWithoutRolepermissionInput
  }

  export type rolepermissionUncheckedCreateWithoutRoleInput = {
    permission_id: number
    created_at?: Date | string | null
  }

  export type rolepermissionCreateOrConnectWithoutRoleInput = {
    where: rolepermissionWhereUniqueInput
    create: XOR<rolepermissionCreateWithoutRoleInput, rolepermissionUncheckedCreateWithoutRoleInput>
  }

  export type rolepermissionCreateManyRoleInputEnvelope = {
    data: rolepermissionCreateManyRoleInput | rolepermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type userroleCreateWithoutRoleInput = {
    created_at?: Date | string | null
    users: usersCreateNestedOneWithoutUserroleInput
  }

  export type userroleUncheckedCreateWithoutRoleInput = {
    user_id: number
    created_at?: Date | string | null
  }

  export type userroleCreateOrConnectWithoutRoleInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput>
  }

  export type userroleCreateManyRoleInputEnvelope = {
    data: userroleCreateManyRoleInput | userroleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type rolepermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: rolepermissionWhereUniqueInput
    update: XOR<rolepermissionUpdateWithoutRoleInput, rolepermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<rolepermissionCreateWithoutRoleInput, rolepermissionUncheckedCreateWithoutRoleInput>
  }

  export type rolepermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: rolepermissionWhereUniqueInput
    data: XOR<rolepermissionUpdateWithoutRoleInput, rolepermissionUncheckedUpdateWithoutRoleInput>
  }

  export type rolepermissionUpdateManyWithWhereWithoutRoleInput = {
    where: rolepermissionScalarWhereInput
    data: XOR<rolepermissionUpdateManyMutationInput, rolepermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type userroleUpsertWithWhereUniqueWithoutRoleInput = {
    where: userroleWhereUniqueInput
    update: XOR<userroleUpdateWithoutRoleInput, userroleUncheckedUpdateWithoutRoleInput>
    create: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput>
  }

  export type userroleUpdateWithWhereUniqueWithoutRoleInput = {
    where: userroleWhereUniqueInput
    data: XOR<userroleUpdateWithoutRoleInput, userroleUncheckedUpdateWithoutRoleInput>
  }

  export type userroleUpdateManyWithWhereWithoutRoleInput = {
    where: userroleScalarWhereInput
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyWithoutRoleInput>
  }

  export type userroleScalarWhereInput = {
    AND?: userroleScalarWhereInput | userroleScalarWhereInput[]
    OR?: userroleScalarWhereInput[]
    NOT?: userroleScalarWhereInput | userroleScalarWhereInput[]
    user_id?: IntFilter<"userrole"> | number
    role_id?: IntFilter<"userrole"> | number
    created_at?: DateTimeNullableFilter<"userrole"> | Date | string | null
  }

  export type permissionCreateWithoutRolepermissionInput = {
    permission_id: number
    permission_name: string
    description?: string | null
  }

  export type permissionUncheckedCreateWithoutRolepermissionInput = {
    permission_id: number
    permission_name: string
    description?: string | null
  }

  export type permissionCreateOrConnectWithoutRolepermissionInput = {
    where: permissionWhereUniqueInput
    create: XOR<permissionCreateWithoutRolepermissionInput, permissionUncheckedCreateWithoutRolepermissionInput>
  }

  export type roleCreateWithoutRolepermissionInput = {
    role_id: number
    role_name: string
    description?: string | null
    userrole?: userroleCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutRolepermissionInput = {
    role_id: number
    role_name: string
    description?: string | null
    userrole?: userroleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutRolepermissionInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutRolepermissionInput, roleUncheckedCreateWithoutRolepermissionInput>
  }

  export type permissionUpsertWithoutRolepermissionInput = {
    update: XOR<permissionUpdateWithoutRolepermissionInput, permissionUncheckedUpdateWithoutRolepermissionInput>
    create: XOR<permissionCreateWithoutRolepermissionInput, permissionUncheckedCreateWithoutRolepermissionInput>
    where?: permissionWhereInput
  }

  export type permissionUpdateToOneWithWhereWithoutRolepermissionInput = {
    where?: permissionWhereInput
    data: XOR<permissionUpdateWithoutRolepermissionInput, permissionUncheckedUpdateWithoutRolepermissionInput>
  }

  export type permissionUpdateWithoutRolepermissionInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    permission_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissionUncheckedUpdateWithoutRolepermissionInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    permission_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roleUpsertWithoutRolepermissionInput = {
    update: XOR<roleUpdateWithoutRolepermissionInput, roleUncheckedUpdateWithoutRolepermissionInput>
    create: XOR<roleCreateWithoutRolepermissionInput, roleUncheckedCreateWithoutRolepermissionInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutRolepermissionInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutRolepermissionInput, roleUncheckedUpdateWithoutRolepermissionInput>
  }

  export type roleUpdateWithoutRolepermissionInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userrole?: userroleUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutRolepermissionInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userrole?: userroleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type auditlogCreateWithoutSessionsInput = {
    target_id: number
    target_entity?: string | null
    timestamp?: Date | string | null
    auditaction?: auditactionCreateNestedOneWithoutAuditlogInput
    users?: usersCreateNestedOneWithoutAuditlogInput
  }

  export type auditlogUncheckedCreateWithoutSessionsInput = {
    log_id?: number
    user_id?: number | null
    action_id?: string | null
    target_id: number
    target_entity?: string | null
    timestamp?: Date | string | null
  }

  export type auditlogCreateOrConnectWithoutSessionsInput = {
    where: auditlogWhereUniqueInput
    create: XOR<auditlogCreateWithoutSessionsInput, auditlogUncheckedCreateWithoutSessionsInput>
  }

  export type auditlogCreateManySessionsInputEnvelope = {
    data: auditlogCreateManySessionsInput | auditlogCreateManySessionsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutSessionsInput = {
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutUsersInput
    userprofile?: userprofileCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSessionsInput = {
    user_id?: number
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeUncheckedCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutUsersInput
    userprofile?: userprofileUncheckedCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSessionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
  }

  export type auditlogUpsertWithWhereUniqueWithoutSessionsInput = {
    where: auditlogWhereUniqueInput
    update: XOR<auditlogUpdateWithoutSessionsInput, auditlogUncheckedUpdateWithoutSessionsInput>
    create: XOR<auditlogCreateWithoutSessionsInput, auditlogUncheckedCreateWithoutSessionsInput>
  }

  export type auditlogUpdateWithWhereUniqueWithoutSessionsInput = {
    where: auditlogWhereUniqueInput
    data: XOR<auditlogUpdateWithoutSessionsInput, auditlogUncheckedUpdateWithoutSessionsInput>
  }

  export type auditlogUpdateManyWithWhereWithoutSessionsInput = {
    where: auditlogScalarWhereInput
    data: XOR<auditlogUpdateManyMutationInput, auditlogUncheckedUpdateManyWithoutSessionsInput>
  }

  export type usersUpsertWithoutSessionsInput = {
    update: XOR<usersUpdateWithoutSessionsInput, usersUncheckedUpdateWithoutSessionsInput>
    create: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSessionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSessionsInput, usersUncheckedUpdateWithoutSessionsInput>
  }

  export type usersUpdateWithoutSessionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSessionsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUncheckedUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUncheckedUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type badgeCreateWithoutTourInput = {
    badge_title: string
    description: string
    image_url: string
    userbadge?: userbadgeCreateNestedManyWithoutBadgeInput
  }

  export type badgeUncheckedCreateWithoutTourInput = {
    badge_id?: number
    badge_title: string
    description: string
    image_url: string
    userbadge?: userbadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type badgeCreateOrConnectWithoutTourInput = {
    where: badgeWhereUniqueInput
    create: XOR<badgeCreateWithoutTourInput, badgeUncheckedCreateWithoutTourInput>
  }

  export type badgeCreateManyTourInputEnvelope = {
    data: badgeCreateManyTourInput | badgeCreateManyTourInput[]
    skipDuplicates?: boolean
  }

  export type reviewCreateWithoutTourInput = {
    review_text: string
    rating: number
    created_at?: Date | string | null
    users?: usersCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutTourInput = {
    review_id?: number
    user_id?: number | null
    review_text: string
    rating: number
    created_at?: Date | string | null
  }

  export type reviewCreateOrConnectWithoutTourInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutTourInput, reviewUncheckedCreateWithoutTourInput>
  }

  export type reviewCreateManyTourInputEnvelope = {
    data: reviewCreateManyTourInput | reviewCreateManyTourInput[]
    skipDuplicates?: boolean
  }

  export type tourcheckpointCreateWithoutTourInput = {
    checkpoint_order: number
    checkpoint: checkpointCreateNestedOneWithoutTourcheckpointInput
  }

  export type tourcheckpointUncheckedCreateWithoutTourInput = {
    checkpoint_id: number
    checkpoint_order: number
  }

  export type tourcheckpointCreateOrConnectWithoutTourInput = {
    where: tourcheckpointWhereUniqueInput
    create: XOR<tourcheckpointCreateWithoutTourInput, tourcheckpointUncheckedCreateWithoutTourInput>
  }

  export type tourcheckpointCreateManyTourInputEnvelope = {
    data: tourcheckpointCreateManyTourInput | tourcheckpointCreateManyTourInput[]
    skipDuplicates?: boolean
  }

  export type usertourcompletionCreateWithoutTourInput = {
    completed?: boolean | null
    completed_at?: Date | string | null
    created_at?: Date | string | null
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutUsertourcompletionInput
    users: usersCreateNestedOneWithoutUsertourcompletionInput
  }

  export type usertourcompletionUncheckedCreateWithoutTourInput = {
    tourcompletion_id?: number
    user_id: number
    completed?: boolean | null
    completed_at?: Date | string | null
    created_at?: Date | string | null
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutUsertourcompletionInput
  }

  export type usertourcompletionCreateOrConnectWithoutTourInput = {
    where: usertourcompletionWhereUniqueInput
    create: XOR<usertourcompletionCreateWithoutTourInput, usertourcompletionUncheckedCreateWithoutTourInput>
  }

  export type usertourcompletionCreateManyTourInputEnvelope = {
    data: usertourcompletionCreateManyTourInput | usertourcompletionCreateManyTourInput[]
    skipDuplicates?: boolean
  }

  export type badgeUpsertWithWhereUniqueWithoutTourInput = {
    where: badgeWhereUniqueInput
    update: XOR<badgeUpdateWithoutTourInput, badgeUncheckedUpdateWithoutTourInput>
    create: XOR<badgeCreateWithoutTourInput, badgeUncheckedCreateWithoutTourInput>
  }

  export type badgeUpdateWithWhereUniqueWithoutTourInput = {
    where: badgeWhereUniqueInput
    data: XOR<badgeUpdateWithoutTourInput, badgeUncheckedUpdateWithoutTourInput>
  }

  export type badgeUpdateManyWithWhereWithoutTourInput = {
    where: badgeScalarWhereInput
    data: XOR<badgeUpdateManyMutationInput, badgeUncheckedUpdateManyWithoutTourInput>
  }

  export type badgeScalarWhereInput = {
    AND?: badgeScalarWhereInput | badgeScalarWhereInput[]
    OR?: badgeScalarWhereInput[]
    NOT?: badgeScalarWhereInput | badgeScalarWhereInput[]
    badge_id?: IntFilter<"badge"> | number
    tour_id?: IntNullableFilter<"badge"> | number | null
    badge_title?: StringFilter<"badge"> | string
    description?: StringFilter<"badge"> | string
    image_url?: StringFilter<"badge"> | string
  }

  export type reviewUpsertWithWhereUniqueWithoutTourInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutTourInput, reviewUncheckedUpdateWithoutTourInput>
    create: XOR<reviewCreateWithoutTourInput, reviewUncheckedCreateWithoutTourInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutTourInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutTourInput, reviewUncheckedUpdateWithoutTourInput>
  }

  export type reviewUpdateManyWithWhereWithoutTourInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutTourInput>
  }

  export type reviewScalarWhereInput = {
    AND?: reviewScalarWhereInput | reviewScalarWhereInput[]
    OR?: reviewScalarWhereInput[]
    NOT?: reviewScalarWhereInput | reviewScalarWhereInput[]
    review_id?: IntFilter<"review"> | number
    user_id?: IntNullableFilter<"review"> | number | null
    tour_id?: IntFilter<"review"> | number
    review_text?: StringFilter<"review"> | string
    rating?: IntFilter<"review"> | number
    created_at?: DateTimeNullableFilter<"review"> | Date | string | null
  }

  export type tourcheckpointUpsertWithWhereUniqueWithoutTourInput = {
    where: tourcheckpointWhereUniqueInput
    update: XOR<tourcheckpointUpdateWithoutTourInput, tourcheckpointUncheckedUpdateWithoutTourInput>
    create: XOR<tourcheckpointCreateWithoutTourInput, tourcheckpointUncheckedCreateWithoutTourInput>
  }

  export type tourcheckpointUpdateWithWhereUniqueWithoutTourInput = {
    where: tourcheckpointWhereUniqueInput
    data: XOR<tourcheckpointUpdateWithoutTourInput, tourcheckpointUncheckedUpdateWithoutTourInput>
  }

  export type tourcheckpointUpdateManyWithWhereWithoutTourInput = {
    where: tourcheckpointScalarWhereInput
    data: XOR<tourcheckpointUpdateManyMutationInput, tourcheckpointUncheckedUpdateManyWithoutTourInput>
  }

  export type usertourcompletionUpsertWithWhereUniqueWithoutTourInput = {
    where: usertourcompletionWhereUniqueInput
    update: XOR<usertourcompletionUpdateWithoutTourInput, usertourcompletionUncheckedUpdateWithoutTourInput>
    create: XOR<usertourcompletionCreateWithoutTourInput, usertourcompletionUncheckedCreateWithoutTourInput>
  }

  export type usertourcompletionUpdateWithWhereUniqueWithoutTourInput = {
    where: usertourcompletionWhereUniqueInput
    data: XOR<usertourcompletionUpdateWithoutTourInput, usertourcompletionUncheckedUpdateWithoutTourInput>
  }

  export type usertourcompletionUpdateManyWithWhereWithoutTourInput = {
    where: usertourcompletionScalarWhereInput
    data: XOR<usertourcompletionUpdateManyMutationInput, usertourcompletionUncheckedUpdateManyWithoutTourInput>
  }

  export type usertourcompletionScalarWhereInput = {
    AND?: usertourcompletionScalarWhereInput | usertourcompletionScalarWhereInput[]
    OR?: usertourcompletionScalarWhereInput[]
    NOT?: usertourcompletionScalarWhereInput | usertourcompletionScalarWhereInput[]
    tourcompletion_id?: IntFilter<"usertourcompletion"> | number
    user_id?: IntFilter<"usertourcompletion"> | number
    tour_id?: IntNullableFilter<"usertourcompletion"> | number | null
    completed?: BoolNullableFilter<"usertourcompletion"> | boolean | null
    completed_at?: DateTimeNullableFilter<"usertourcompletion"> | Date | string | null
    created_at?: DateTimeNullableFilter<"usertourcompletion"> | Date | string | null
  }

  export type checkpointCreateWithoutTourcheckpointInput = {
    points_reward: number
    created_at?: Date | string | null
    location: locationCreateNestedOneWithoutCheckpointInput
    quiz?: quizCreateNestedOneWithoutCheckpointInput
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointUncheckedCreateWithoutTourcheckpointInput = {
    checkpoint_id?: number
    quiz_id?: number | null
    location_id: number
    points_reward: number
    created_at?: Date | string | null
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointCreateOrConnectWithoutTourcheckpointInput = {
    where: checkpointWhereUniqueInput
    create: XOR<checkpointCreateWithoutTourcheckpointInput, checkpointUncheckedCreateWithoutTourcheckpointInput>
  }

  export type tourCreateWithoutTourcheckpointInput = {
    tour_name: string
    description?: string | null
    created_at?: Date | string | null
    badge?: badgeCreateNestedManyWithoutTourInput
    review?: reviewCreateNestedManyWithoutTourInput
    usertourcompletion?: usertourcompletionCreateNestedManyWithoutTourInput
  }

  export type tourUncheckedCreateWithoutTourcheckpointInput = {
    tour_id?: number
    tour_name: string
    description?: string | null
    created_at?: Date | string | null
    badge?: badgeUncheckedCreateNestedManyWithoutTourInput
    review?: reviewUncheckedCreateNestedManyWithoutTourInput
    usertourcompletion?: usertourcompletionUncheckedCreateNestedManyWithoutTourInput
  }

  export type tourCreateOrConnectWithoutTourcheckpointInput = {
    where: tourWhereUniqueInput
    create: XOR<tourCreateWithoutTourcheckpointInput, tourUncheckedCreateWithoutTourcheckpointInput>
  }

  export type checkpointUpsertWithoutTourcheckpointInput = {
    update: XOR<checkpointUpdateWithoutTourcheckpointInput, checkpointUncheckedUpdateWithoutTourcheckpointInput>
    create: XOR<checkpointCreateWithoutTourcheckpointInput, checkpointUncheckedCreateWithoutTourcheckpointInput>
    where?: checkpointWhereInput
  }

  export type checkpointUpdateToOneWithWhereWithoutTourcheckpointInput = {
    where?: checkpointWhereInput
    data: XOR<checkpointUpdateWithoutTourcheckpointInput, checkpointUncheckedUpdateWithoutTourcheckpointInput>
  }

  export type checkpointUpdateWithoutTourcheckpointInput = {
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: locationUpdateOneRequiredWithoutCheckpointNestedInput
    quiz?: quizUpdateOneWithoutCheckpointNestedInput
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutCheckpointNestedInput
  }

  export type checkpointUncheckedUpdateWithoutTourcheckpointInput = {
    checkpoint_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: NullableIntFieldUpdateOperationsInput | number | null
    location_id?: IntFieldUpdateOperationsInput | number
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutCheckpointNestedInput
  }

  export type tourUpsertWithoutTourcheckpointInput = {
    update: XOR<tourUpdateWithoutTourcheckpointInput, tourUncheckedUpdateWithoutTourcheckpointInput>
    create: XOR<tourCreateWithoutTourcheckpointInput, tourUncheckedCreateWithoutTourcheckpointInput>
    where?: tourWhereInput
  }

  export type tourUpdateToOneWithWhereWithoutTourcheckpointInput = {
    where?: tourWhereInput
    data: XOR<tourUpdateWithoutTourcheckpointInput, tourUncheckedUpdateWithoutTourcheckpointInput>
  }

  export type tourUpdateWithoutTourcheckpointInput = {
    tour_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUpdateManyWithoutTourNestedInput
    review?: reviewUpdateManyWithoutTourNestedInput
    usertourcompletion?: usertourcompletionUpdateManyWithoutTourNestedInput
  }

  export type tourUncheckedUpdateWithoutTourcheckpointInput = {
    tour_id?: IntFieldUpdateOperationsInput | number
    tour_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUncheckedUpdateManyWithoutTourNestedInput
    review?: reviewUncheckedUpdateManyWithoutTourNestedInput
    usertourcompletion?: usertourcompletionUncheckedUpdateManyWithoutTourNestedInput
  }

  export type badgeCreateWithoutUserbadgeInput = {
    badge_title: string
    description: string
    image_url: string
    tour?: tourCreateNestedOneWithoutBadgeInput
  }

  export type badgeUncheckedCreateWithoutUserbadgeInput = {
    badge_id?: number
    tour_id?: number | null
    badge_title: string
    description: string
    image_url: string
  }

  export type badgeCreateOrConnectWithoutUserbadgeInput = {
    where: badgeWhereUniqueInput
    create: XOR<badgeCreateWithoutUserbadgeInput, badgeUncheckedCreateWithoutUserbadgeInput>
  }

  export type usersCreateWithoutUserbadgeInput = {
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutUsersInput
    userprofile?: userprofileCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUserbadgeInput = {
    user_id?: number
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutUsersInput
    userprofile?: userprofileUncheckedCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUserbadgeInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUserbadgeInput, usersUncheckedCreateWithoutUserbadgeInput>
  }

  export type badgeUpsertWithoutUserbadgeInput = {
    update: XOR<badgeUpdateWithoutUserbadgeInput, badgeUncheckedUpdateWithoutUserbadgeInput>
    create: XOR<badgeCreateWithoutUserbadgeInput, badgeUncheckedCreateWithoutUserbadgeInput>
    where?: badgeWhereInput
  }

  export type badgeUpdateToOneWithWhereWithoutUserbadgeInput = {
    where?: badgeWhereInput
    data: XOR<badgeUpdateWithoutUserbadgeInput, badgeUncheckedUpdateWithoutUserbadgeInput>
  }

  export type badgeUpdateWithoutUserbadgeInput = {
    badge_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    tour?: tourUpdateOneWithoutBadgeNestedInput
  }

  export type badgeUncheckedUpdateWithoutUserbadgeInput = {
    badge_id?: IntFieldUpdateOperationsInput | number
    tour_id?: NullableIntFieldUpdateOperationsInput | number | null
    badge_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type usersUpsertWithoutUserbadgeInput = {
    update: XOR<usersUpdateWithoutUserbadgeInput, usersUncheckedUpdateWithoutUserbadgeInput>
    create: XOR<usersCreateWithoutUserbadgeInput, usersUncheckedCreateWithoutUserbadgeInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUserbadgeInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUserbadgeInput, usersUncheckedUpdateWithoutUserbadgeInput>
  }

  export type usersUpdateWithoutUserbadgeInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUserbadgeInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUncheckedUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type checkpointCreateWithoutUsercheckpointattemptInput = {
    points_reward: number
    created_at?: Date | string | null
    location: locationCreateNestedOneWithoutCheckpointInput
    quiz?: quizCreateNestedOneWithoutCheckpointInput
    tourcheckpoint?: tourcheckpointCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointUncheckedCreateWithoutUsercheckpointattemptInput = {
    checkpoint_id?: number
    quiz_id?: number | null
    location_id: number
    points_reward: number
    created_at?: Date | string | null
    tourcheckpoint?: tourcheckpointUncheckedCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointCreateOrConnectWithoutUsercheckpointattemptInput = {
    where: checkpointWhereUniqueInput
    create: XOR<checkpointCreateWithoutUsercheckpointattemptInput, checkpointUncheckedCreateWithoutUsercheckpointattemptInput>
  }

  export type usertourcompletionCreateWithoutUsercheckpointattemptInput = {
    completed?: boolean | null
    completed_at?: Date | string | null
    created_at?: Date | string | null
    tour?: tourCreateNestedOneWithoutUsertourcompletionInput
    users: usersCreateNestedOneWithoutUsertourcompletionInput
  }

  export type usertourcompletionUncheckedCreateWithoutUsercheckpointattemptInput = {
    tourcompletion_id?: number
    user_id: number
    tour_id?: number | null
    completed?: boolean | null
    completed_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type usertourcompletionCreateOrConnectWithoutUsercheckpointattemptInput = {
    where: usertourcompletionWhereUniqueInput
    create: XOR<usertourcompletionCreateWithoutUsercheckpointattemptInput, usertourcompletionUncheckedCreateWithoutUsercheckpointattemptInput>
  }

  export type usersCreateWithoutUsercheckpointattemptInput = {
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeCreateNestedManyWithoutUsersInput
    userprofile?: userprofileCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUsercheckpointattemptInput = {
    user_id?: number
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeUncheckedCreateNestedManyWithoutUsersInput
    userprofile?: userprofileUncheckedCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUsercheckpointattemptInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUsercheckpointattemptInput, usersUncheckedCreateWithoutUsercheckpointattemptInput>
  }

  export type checkpointUpsertWithoutUsercheckpointattemptInput = {
    update: XOR<checkpointUpdateWithoutUsercheckpointattemptInput, checkpointUncheckedUpdateWithoutUsercheckpointattemptInput>
    create: XOR<checkpointCreateWithoutUsercheckpointattemptInput, checkpointUncheckedCreateWithoutUsercheckpointattemptInput>
    where?: checkpointWhereInput
  }

  export type checkpointUpdateToOneWithWhereWithoutUsercheckpointattemptInput = {
    where?: checkpointWhereInput
    data: XOR<checkpointUpdateWithoutUsercheckpointattemptInput, checkpointUncheckedUpdateWithoutUsercheckpointattemptInput>
  }

  export type checkpointUpdateWithoutUsercheckpointattemptInput = {
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: locationUpdateOneRequiredWithoutCheckpointNestedInput
    quiz?: quizUpdateOneWithoutCheckpointNestedInput
    tourcheckpoint?: tourcheckpointUpdateManyWithoutCheckpointNestedInput
  }

  export type checkpointUncheckedUpdateWithoutUsercheckpointattemptInput = {
    checkpoint_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: NullableIntFieldUpdateOperationsInput | number | null
    location_id?: IntFieldUpdateOperationsInput | number
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tourcheckpoint?: tourcheckpointUncheckedUpdateManyWithoutCheckpointNestedInput
  }

  export type usertourcompletionUpsertWithoutUsercheckpointattemptInput = {
    update: XOR<usertourcompletionUpdateWithoutUsercheckpointattemptInput, usertourcompletionUncheckedUpdateWithoutUsercheckpointattemptInput>
    create: XOR<usertourcompletionCreateWithoutUsercheckpointattemptInput, usertourcompletionUncheckedCreateWithoutUsercheckpointattemptInput>
    where?: usertourcompletionWhereInput
  }

  export type usertourcompletionUpdateToOneWithWhereWithoutUsercheckpointattemptInput = {
    where?: usertourcompletionWhereInput
    data: XOR<usertourcompletionUpdateWithoutUsercheckpointattemptInput, usertourcompletionUncheckedUpdateWithoutUsercheckpointattemptInput>
  }

  export type usertourcompletionUpdateWithoutUsercheckpointattemptInput = {
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tour?: tourUpdateOneWithoutUsertourcompletionNestedInput
    users?: usersUpdateOneRequiredWithoutUsertourcompletionNestedInput
  }

  export type usertourcompletionUncheckedUpdateWithoutUsercheckpointattemptInput = {
    tourcompletion_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    tour_id?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpsertWithoutUsercheckpointattemptInput = {
    update: XOR<usersUpdateWithoutUsercheckpointattemptInput, usersUncheckedUpdateWithoutUsercheckpointattemptInput>
    create: XOR<usersCreateWithoutUsercheckpointattemptInput, usersUncheckedCreateWithoutUsercheckpointattemptInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUsercheckpointattemptInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUsercheckpointattemptInput, usersUncheckedUpdateWithoutUsercheckpointattemptInput>
  }

  export type usersUpdateWithoutUsercheckpointattemptInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUsercheckpointattemptInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUncheckedUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUncheckedUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutUserprofileInput = {
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutUsersInput
    userquizcompletion?: userquizcompletionCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUserprofileInput = {
    user_id?: number
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeUncheckedCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutUsersInput
    userquizcompletion?: userquizcompletionUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUserprofileInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUserprofileInput, usersUncheckedCreateWithoutUserprofileInput>
  }

  export type usersUpsertWithoutUserprofileInput = {
    update: XOR<usersUpdateWithoutUserprofileInput, usersUncheckedUpdateWithoutUserprofileInput>
    create: XOR<usersCreateWithoutUserprofileInput, usersUncheckedCreateWithoutUserprofileInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUserprofileInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUserprofileInput, usersUncheckedUpdateWithoutUserprofileInput>
  }

  export type usersUpdateWithoutUserprofileInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUserprofileInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUncheckedUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type quizCreateWithoutUserquizcompletionInput = {
    quiz_title: string
    description?: string | null
    checkpoint?: checkpointCreateNestedManyWithoutQuizInput
    question?: questionCreateNestedManyWithoutQuizInput
  }

  export type quizUncheckedCreateWithoutUserquizcompletionInput = {
    quiz_id?: number
    quiz_title: string
    description?: string | null
    checkpoint?: checkpointUncheckedCreateNestedManyWithoutQuizInput
    question?: questionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type quizCreateOrConnectWithoutUserquizcompletionInput = {
    where: quizWhereUniqueInput
    create: XOR<quizCreateWithoutUserquizcompletionInput, quizUncheckedCreateWithoutUserquizcompletionInput>
  }

  export type usersCreateWithoutUserquizcompletionInput = {
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutUsersInput
    userprofile?: userprofileCreateNestedOneWithoutUsersInput
    userrole?: userroleCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUserquizcompletionInput = {
    user_id?: number
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeUncheckedCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutUsersInput
    userprofile?: userprofileUncheckedCreateNestedOneWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedOneWithoutUsersInput
    usertourcompletion?: usertourcompletionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUserquizcompletionInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUserquizcompletionInput, usersUncheckedCreateWithoutUserquizcompletionInput>
  }

  export type quizUpsertWithoutUserquizcompletionInput = {
    update: XOR<quizUpdateWithoutUserquizcompletionInput, quizUncheckedUpdateWithoutUserquizcompletionInput>
    create: XOR<quizCreateWithoutUserquizcompletionInput, quizUncheckedCreateWithoutUserquizcompletionInput>
    where?: quizWhereInput
  }

  export type quizUpdateToOneWithWhereWithoutUserquizcompletionInput = {
    where?: quizWhereInput
    data: XOR<quizUpdateWithoutUserquizcompletionInput, quizUncheckedUpdateWithoutUserquizcompletionInput>
  }

  export type quizUpdateWithoutUserquizcompletionInput = {
    quiz_title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoint?: checkpointUpdateManyWithoutQuizNestedInput
    question?: questionUpdateManyWithoutQuizNestedInput
  }

  export type quizUncheckedUpdateWithoutUserquizcompletionInput = {
    quiz_id?: IntFieldUpdateOperationsInput | number
    quiz_title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkpoint?: checkpointUncheckedUpdateManyWithoutQuizNestedInput
    question?: questionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type usersUpsertWithoutUserquizcompletionInput = {
    update: XOR<usersUpdateWithoutUserquizcompletionInput, usersUncheckedUpdateWithoutUserquizcompletionInput>
    create: XOR<usersCreateWithoutUserquizcompletionInput, usersUncheckedCreateWithoutUserquizcompletionInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUserquizcompletionInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUserquizcompletionInput, usersUncheckedUpdateWithoutUserquizcompletionInput>
  }

  export type usersUpdateWithoutUserquizcompletionInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUpdateOneWithoutUsersNestedInput
    userrole?: userroleUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUserquizcompletionInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUncheckedUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUncheckedUpdateOneWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateOneWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type roleCreateWithoutUserroleInput = {
    role_id: number
    role_name: string
    description?: string | null
    rolepermission?: rolepermissionCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateWithoutUserroleInput = {
    role_id: number
    role_name: string
    description?: string | null
    rolepermission?: rolepermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleCreateOrConnectWithoutUserroleInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutUserroleInput, roleUncheckedCreateWithoutUserroleInput>
  }

  export type usersCreateWithoutUserroleInput = {
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutUsersInput
    userprofile?: userprofileCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionCreateNestedManyWithoutUsersInput
    usertourcompletion?: usertourcompletionCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUserroleInput = {
    user_id?: number
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeUncheckedCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutUsersInput
    userprofile?: userprofileUncheckedCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionUncheckedCreateNestedManyWithoutUsersInput
    usertourcompletion?: usertourcompletionUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUserroleInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUserroleInput, usersUncheckedCreateWithoutUserroleInput>
  }

  export type roleUpsertWithoutUserroleInput = {
    update: XOR<roleUpdateWithoutUserroleInput, roleUncheckedUpdateWithoutUserroleInput>
    create: XOR<roleCreateWithoutUserroleInput, roleUncheckedCreateWithoutUserroleInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutUserroleInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutUserroleInput, roleUncheckedUpdateWithoutUserroleInput>
  }

  export type roleUpdateWithoutUserroleInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rolepermission?: rolepermissionUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateWithoutUserroleInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rolepermission?: rolepermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type usersUpsertWithoutUserroleInput = {
    update: XOR<usersUpdateWithoutUserroleInput, usersUncheckedUpdateWithoutUserroleInput>
    create: XOR<usersCreateWithoutUserroleInput, usersUncheckedCreateWithoutUserroleInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUserroleInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUserroleInput, usersUncheckedUpdateWithoutUserroleInput>
  }

  export type usersUpdateWithoutUserroleInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUpdateManyWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUserroleInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUncheckedUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUncheckedUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUncheckedUpdateManyWithoutUsersNestedInput
    usertourcompletion?: usertourcompletionUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type auditlogCreateWithoutUsersInput = {
    target_id: number
    target_entity?: string | null
    timestamp?: Date | string | null
    auditaction?: auditactionCreateNestedOneWithoutAuditlogInput
    sessions?: sessionsCreateNestedOneWithoutAuditlogInput
  }

  export type auditlogUncheckedCreateWithoutUsersInput = {
    log_id?: number
    session_id?: number | null
    action_id?: string | null
    target_id: number
    target_entity?: string | null
    timestamp?: Date | string | null
  }

  export type auditlogCreateOrConnectWithoutUsersInput = {
    where: auditlogWhereUniqueInput
    create: XOR<auditlogCreateWithoutUsersInput, auditlogUncheckedCreateWithoutUsersInput>
  }

  export type auditlogCreateManyUsersInputEnvelope = {
    data: auditlogCreateManyUsersInput | auditlogCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type reviewCreateWithoutUsersInput = {
    review_text: string
    rating: number
    created_at?: Date | string | null
    tour: tourCreateNestedOneWithoutReviewInput
  }

  export type reviewUncheckedCreateWithoutUsersInput = {
    review_id?: number
    tour_id: number
    review_text: string
    rating: number
    created_at?: Date | string | null
  }

  export type reviewCreateOrConnectWithoutUsersInput = {
    where: reviewWhereUniqueInput
    create: XOR<reviewCreateWithoutUsersInput, reviewUncheckedCreateWithoutUsersInput>
  }

  export type reviewCreateManyUsersInputEnvelope = {
    data: reviewCreateManyUsersInput | reviewCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type sessionsCreateWithoutUsersInput = {
    access_token?: string | null
    is_active?: boolean | null
    login_at?: Date | string | null
    logout_at?: Date | string | null
    auditlog?: auditlogCreateNestedManyWithoutSessionsInput
  }

  export type sessionsUncheckedCreateWithoutUsersInput = {
    session_id?: number
    access_token?: string | null
    is_active?: boolean | null
    login_at?: Date | string | null
    logout_at?: Date | string | null
    auditlog?: auditlogUncheckedCreateNestedManyWithoutSessionsInput
  }

  export type sessionsCreateOrConnectWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput>
  }

  export type sessionsCreateManyUsersInputEnvelope = {
    data: sessionsCreateManyUsersInput | sessionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type userbadgeCreateWithoutUsersInput = {
    created_at?: Date | string | null
    badge: badgeCreateNestedOneWithoutUserbadgeInput
  }

  export type userbadgeUncheckedCreateWithoutUsersInput = {
    badge_id: number
    created_at?: Date | string | null
  }

  export type userbadgeCreateOrConnectWithoutUsersInput = {
    where: userbadgeWhereUniqueInput
    create: XOR<userbadgeCreateWithoutUsersInput, userbadgeUncheckedCreateWithoutUsersInput>
  }

  export type userbadgeCreateManyUsersInputEnvelope = {
    data: userbadgeCreateManyUsersInput | userbadgeCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type usercheckpointattemptCreateWithoutUsersInput = {
    created_at?: Date | string | null
    checkpoint?: checkpointCreateNestedOneWithoutUsercheckpointattemptInput
    usertourcompletion: usertourcompletionCreateNestedOneWithoutUsercheckpointattemptInput
  }

  export type usercheckpointattemptUncheckedCreateWithoutUsersInput = {
    checkpointattempt_id?: number
    checkpoint_id?: number | null
    tourcompletion_id: number
    created_at?: Date | string | null
  }

  export type usercheckpointattemptCreateOrConnectWithoutUsersInput = {
    where: usercheckpointattemptWhereUniqueInput
    create: XOR<usercheckpointattemptCreateWithoutUsersInput, usercheckpointattemptUncheckedCreateWithoutUsersInput>
  }

  export type usercheckpointattemptCreateManyUsersInputEnvelope = {
    data: usercheckpointattemptCreateManyUsersInput | usercheckpointattemptCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type userprofileCreateWithoutUsersInput = {
    points?: number | null
    level?: number | null
    first_name: string
    last_name: string
    school?: string | null
    sec_level: $Enums.sec_level
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type userprofileUncheckedCreateWithoutUsersInput = {
    profile_id?: number
    points?: number | null
    level?: number | null
    first_name: string
    last_name: string
    school?: string | null
    sec_level: $Enums.sec_level
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type userprofileCreateOrConnectWithoutUsersInput = {
    where: userprofileWhereUniqueInput
    create: XOR<userprofileCreateWithoutUsersInput, userprofileUncheckedCreateWithoutUsersInput>
  }

  export type userquizcompletionCreateWithoutUsersInput = {
    score: number
    created_at?: Date | string | null
    quiz: quizCreateNestedOneWithoutUserquizcompletionInput
  }

  export type userquizcompletionUncheckedCreateWithoutUsersInput = {
    quizcompletion_id?: number
    quiz_id: number
    score: number
    created_at?: Date | string | null
  }

  export type userquizcompletionCreateOrConnectWithoutUsersInput = {
    where: userquizcompletionWhereUniqueInput
    create: XOR<userquizcompletionCreateWithoutUsersInput, userquizcompletionUncheckedCreateWithoutUsersInput>
  }

  export type userquizcompletionCreateManyUsersInputEnvelope = {
    data: userquizcompletionCreateManyUsersInput | userquizcompletionCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type userroleCreateWithoutUsersInput = {
    created_at?: Date | string | null
    role?: roleCreateNestedOneWithoutUserroleInput
  }

  export type userroleUncheckedCreateWithoutUsersInput = {
    role_id?: number
    created_at?: Date | string | null
  }

  export type userroleCreateOrConnectWithoutUsersInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutUsersInput, userroleUncheckedCreateWithoutUsersInput>
  }

  export type usertourcompletionCreateWithoutUsersInput = {
    completed?: boolean | null
    completed_at?: Date | string | null
    created_at?: Date | string | null
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutUsertourcompletionInput
    tour?: tourCreateNestedOneWithoutUsertourcompletionInput
  }

  export type usertourcompletionUncheckedCreateWithoutUsersInput = {
    tourcompletion_id?: number
    tour_id?: number | null
    completed?: boolean | null
    completed_at?: Date | string | null
    created_at?: Date | string | null
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutUsertourcompletionInput
  }

  export type usertourcompletionCreateOrConnectWithoutUsersInput = {
    where: usertourcompletionWhereUniqueInput
    create: XOR<usertourcompletionCreateWithoutUsersInput, usertourcompletionUncheckedCreateWithoutUsersInput>
  }

  export type usertourcompletionCreateManyUsersInputEnvelope = {
    data: usertourcompletionCreateManyUsersInput | usertourcompletionCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type auditlogUpsertWithWhereUniqueWithoutUsersInput = {
    where: auditlogWhereUniqueInput
    update: XOR<auditlogUpdateWithoutUsersInput, auditlogUncheckedUpdateWithoutUsersInput>
    create: XOR<auditlogCreateWithoutUsersInput, auditlogUncheckedCreateWithoutUsersInput>
  }

  export type auditlogUpdateWithWhereUniqueWithoutUsersInput = {
    where: auditlogWhereUniqueInput
    data: XOR<auditlogUpdateWithoutUsersInput, auditlogUncheckedUpdateWithoutUsersInput>
  }

  export type auditlogUpdateManyWithWhereWithoutUsersInput = {
    where: auditlogScalarWhereInput
    data: XOR<auditlogUpdateManyMutationInput, auditlogUncheckedUpdateManyWithoutUsersInput>
  }

  export type reviewUpsertWithWhereUniqueWithoutUsersInput = {
    where: reviewWhereUniqueInput
    update: XOR<reviewUpdateWithoutUsersInput, reviewUncheckedUpdateWithoutUsersInput>
    create: XOR<reviewCreateWithoutUsersInput, reviewUncheckedCreateWithoutUsersInput>
  }

  export type reviewUpdateWithWhereUniqueWithoutUsersInput = {
    where: reviewWhereUniqueInput
    data: XOR<reviewUpdateWithoutUsersInput, reviewUncheckedUpdateWithoutUsersInput>
  }

  export type reviewUpdateManyWithWhereWithoutUsersInput = {
    where: reviewScalarWhereInput
    data: XOR<reviewUpdateManyMutationInput, reviewUncheckedUpdateManyWithoutUsersInput>
  }

  export type sessionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    update: XOR<sessionsUpdateWithoutUsersInput, sessionsUncheckedUpdateWithoutUsersInput>
    create: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput>
  }

  export type sessionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    data: XOR<sessionsUpdateWithoutUsersInput, sessionsUncheckedUpdateWithoutUsersInput>
  }

  export type sessionsUpdateManyWithWhereWithoutUsersInput = {
    where: sessionsScalarWhereInput
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type sessionsScalarWhereInput = {
    AND?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    OR?: sessionsScalarWhereInput[]
    NOT?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    session_id?: IntFilter<"sessions"> | number
    user_id?: IntNullableFilter<"sessions"> | number | null
    access_token?: StringNullableFilter<"sessions"> | string | null
    is_active?: BoolNullableFilter<"sessions"> | boolean | null
    login_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    logout_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
  }

  export type userbadgeUpsertWithWhereUniqueWithoutUsersInput = {
    where: userbadgeWhereUniqueInput
    update: XOR<userbadgeUpdateWithoutUsersInput, userbadgeUncheckedUpdateWithoutUsersInput>
    create: XOR<userbadgeCreateWithoutUsersInput, userbadgeUncheckedCreateWithoutUsersInput>
  }

  export type userbadgeUpdateWithWhereUniqueWithoutUsersInput = {
    where: userbadgeWhereUniqueInput
    data: XOR<userbadgeUpdateWithoutUsersInput, userbadgeUncheckedUpdateWithoutUsersInput>
  }

  export type userbadgeUpdateManyWithWhereWithoutUsersInput = {
    where: userbadgeScalarWhereInput
    data: XOR<userbadgeUpdateManyMutationInput, userbadgeUncheckedUpdateManyWithoutUsersInput>
  }

  export type usercheckpointattemptUpsertWithWhereUniqueWithoutUsersInput = {
    where: usercheckpointattemptWhereUniqueInput
    update: XOR<usercheckpointattemptUpdateWithoutUsersInput, usercheckpointattemptUncheckedUpdateWithoutUsersInput>
    create: XOR<usercheckpointattemptCreateWithoutUsersInput, usercheckpointattemptUncheckedCreateWithoutUsersInput>
  }

  export type usercheckpointattemptUpdateWithWhereUniqueWithoutUsersInput = {
    where: usercheckpointattemptWhereUniqueInput
    data: XOR<usercheckpointattemptUpdateWithoutUsersInput, usercheckpointattemptUncheckedUpdateWithoutUsersInput>
  }

  export type usercheckpointattemptUpdateManyWithWhereWithoutUsersInput = {
    where: usercheckpointattemptScalarWhereInput
    data: XOR<usercheckpointattemptUpdateManyMutationInput, usercheckpointattemptUncheckedUpdateManyWithoutUsersInput>
  }

  export type userprofileUpsertWithoutUsersInput = {
    update: XOR<userprofileUpdateWithoutUsersInput, userprofileUncheckedUpdateWithoutUsersInput>
    create: XOR<userprofileCreateWithoutUsersInput, userprofileUncheckedCreateWithoutUsersInput>
    where?: userprofileWhereInput
  }

  export type userprofileUpdateToOneWithWhereWithoutUsersInput = {
    where?: userprofileWhereInput
    data: XOR<userprofileUpdateWithoutUsersInput, userprofileUncheckedUpdateWithoutUsersInput>
  }

  export type userprofileUpdateWithoutUsersInput = {
    points?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    school?: NullableStringFieldUpdateOperationsInput | string | null
    sec_level?: Enumsec_levelFieldUpdateOperationsInput | $Enums.sec_level
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userprofileUncheckedUpdateWithoutUsersInput = {
    profile_id?: IntFieldUpdateOperationsInput | number
    points?: NullableIntFieldUpdateOperationsInput | number | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    school?: NullableStringFieldUpdateOperationsInput | string | null
    sec_level?: Enumsec_levelFieldUpdateOperationsInput | $Enums.sec_level
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userquizcompletionUpsertWithWhereUniqueWithoutUsersInput = {
    where: userquizcompletionWhereUniqueInput
    update: XOR<userquizcompletionUpdateWithoutUsersInput, userquizcompletionUncheckedUpdateWithoutUsersInput>
    create: XOR<userquizcompletionCreateWithoutUsersInput, userquizcompletionUncheckedCreateWithoutUsersInput>
  }

  export type userquizcompletionUpdateWithWhereUniqueWithoutUsersInput = {
    where: userquizcompletionWhereUniqueInput
    data: XOR<userquizcompletionUpdateWithoutUsersInput, userquizcompletionUncheckedUpdateWithoutUsersInput>
  }

  export type userquizcompletionUpdateManyWithWhereWithoutUsersInput = {
    where: userquizcompletionScalarWhereInput
    data: XOR<userquizcompletionUpdateManyMutationInput, userquizcompletionUncheckedUpdateManyWithoutUsersInput>
  }

  export type userroleUpsertWithoutUsersInput = {
    update: XOR<userroleUpdateWithoutUsersInput, userroleUncheckedUpdateWithoutUsersInput>
    create: XOR<userroleCreateWithoutUsersInput, userroleUncheckedCreateWithoutUsersInput>
    where?: userroleWhereInput
  }

  export type userroleUpdateToOneWithWhereWithoutUsersInput = {
    where?: userroleWhereInput
    data: XOR<userroleUpdateWithoutUsersInput, userroleUncheckedUpdateWithoutUsersInput>
  }

  export type userroleUpdateWithoutUsersInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: roleUpdateOneRequiredWithoutUserroleNestedInput
  }

  export type userroleUncheckedUpdateWithoutUsersInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usertourcompletionUpsertWithWhereUniqueWithoutUsersInput = {
    where: usertourcompletionWhereUniqueInput
    update: XOR<usertourcompletionUpdateWithoutUsersInput, usertourcompletionUncheckedUpdateWithoutUsersInput>
    create: XOR<usertourcompletionCreateWithoutUsersInput, usertourcompletionUncheckedCreateWithoutUsersInput>
  }

  export type usertourcompletionUpdateWithWhereUniqueWithoutUsersInput = {
    where: usertourcompletionWhereUniqueInput
    data: XOR<usertourcompletionUpdateWithoutUsersInput, usertourcompletionUncheckedUpdateWithoutUsersInput>
  }

  export type usertourcompletionUpdateManyWithWhereWithoutUsersInput = {
    where: usertourcompletionScalarWhereInput
    data: XOR<usertourcompletionUpdateManyMutationInput, usertourcompletionUncheckedUpdateManyWithoutUsersInput>
  }

  export type usercheckpointattemptCreateWithoutUsertourcompletionInput = {
    created_at?: Date | string | null
    checkpoint?: checkpointCreateNestedOneWithoutUsercheckpointattemptInput
    users: usersCreateNestedOneWithoutUsercheckpointattemptInput
  }

  export type usercheckpointattemptUncheckedCreateWithoutUsertourcompletionInput = {
    checkpointattempt_id?: number
    user_id: number
    checkpoint_id?: number | null
    created_at?: Date | string | null
  }

  export type usercheckpointattemptCreateOrConnectWithoutUsertourcompletionInput = {
    where: usercheckpointattemptWhereUniqueInput
    create: XOR<usercheckpointattemptCreateWithoutUsertourcompletionInput, usercheckpointattemptUncheckedCreateWithoutUsertourcompletionInput>
  }

  export type usercheckpointattemptCreateManyUsertourcompletionInputEnvelope = {
    data: usercheckpointattemptCreateManyUsertourcompletionInput | usercheckpointattemptCreateManyUsertourcompletionInput[]
    skipDuplicates?: boolean
  }

  export type tourCreateWithoutUsertourcompletionInput = {
    tour_name: string
    description?: string | null
    created_at?: Date | string | null
    badge?: badgeCreateNestedManyWithoutTourInput
    review?: reviewCreateNestedManyWithoutTourInput
    tourcheckpoint?: tourcheckpointCreateNestedManyWithoutTourInput
  }

  export type tourUncheckedCreateWithoutUsertourcompletionInput = {
    tour_id?: number
    tour_name: string
    description?: string | null
    created_at?: Date | string | null
    badge?: badgeUncheckedCreateNestedManyWithoutTourInput
    review?: reviewUncheckedCreateNestedManyWithoutTourInput
    tourcheckpoint?: tourcheckpointUncheckedCreateNestedManyWithoutTourInput
  }

  export type tourCreateOrConnectWithoutUsertourcompletionInput = {
    where: tourWhereUniqueInput
    create: XOR<tourCreateWithoutUsertourcompletionInput, tourUncheckedCreateWithoutUsertourcompletionInput>
  }

  export type usersCreateWithoutUsertourcompletionInput = {
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogCreateNestedManyWithoutUsersInput
    review?: reviewCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptCreateNestedManyWithoutUsersInput
    userprofile?: userprofileCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionCreateNestedManyWithoutUsersInput
    userrole?: userroleCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUsertourcompletionInput = {
    user_id?: number
    username: string
    email: string
    password: string
    is_verified?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    auditlog?: auditlogUncheckedCreateNestedManyWithoutUsersInput
    review?: reviewUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    userbadge?: userbadgeUncheckedCreateNestedManyWithoutUsersInput
    usercheckpointattempt?: usercheckpointattemptUncheckedCreateNestedManyWithoutUsersInput
    userprofile?: userprofileUncheckedCreateNestedOneWithoutUsersInput
    userquizcompletion?: userquizcompletionUncheckedCreateNestedManyWithoutUsersInput
    userrole?: userroleUncheckedCreateNestedOneWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUsertourcompletionInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUsertourcompletionInput, usersUncheckedCreateWithoutUsertourcompletionInput>
  }

  export type usercheckpointattemptUpsertWithWhereUniqueWithoutUsertourcompletionInput = {
    where: usercheckpointattemptWhereUniqueInput
    update: XOR<usercheckpointattemptUpdateWithoutUsertourcompletionInput, usercheckpointattemptUncheckedUpdateWithoutUsertourcompletionInput>
    create: XOR<usercheckpointattemptCreateWithoutUsertourcompletionInput, usercheckpointattemptUncheckedCreateWithoutUsertourcompletionInput>
  }

  export type usercheckpointattemptUpdateWithWhereUniqueWithoutUsertourcompletionInput = {
    where: usercheckpointattemptWhereUniqueInput
    data: XOR<usercheckpointattemptUpdateWithoutUsertourcompletionInput, usercheckpointattemptUncheckedUpdateWithoutUsertourcompletionInput>
  }

  export type usercheckpointattemptUpdateManyWithWhereWithoutUsertourcompletionInput = {
    where: usercheckpointattemptScalarWhereInput
    data: XOR<usercheckpointattemptUpdateManyMutationInput, usercheckpointattemptUncheckedUpdateManyWithoutUsertourcompletionInput>
  }

  export type tourUpsertWithoutUsertourcompletionInput = {
    update: XOR<tourUpdateWithoutUsertourcompletionInput, tourUncheckedUpdateWithoutUsertourcompletionInput>
    create: XOR<tourCreateWithoutUsertourcompletionInput, tourUncheckedCreateWithoutUsertourcompletionInput>
    where?: tourWhereInput
  }

  export type tourUpdateToOneWithWhereWithoutUsertourcompletionInput = {
    where?: tourWhereInput
    data: XOR<tourUpdateWithoutUsertourcompletionInput, tourUncheckedUpdateWithoutUsertourcompletionInput>
  }

  export type tourUpdateWithoutUsertourcompletionInput = {
    tour_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUpdateManyWithoutTourNestedInput
    review?: reviewUpdateManyWithoutTourNestedInput
    tourcheckpoint?: tourcheckpointUpdateManyWithoutTourNestedInput
  }

  export type tourUncheckedUpdateWithoutUsertourcompletionInput = {
    tour_id?: IntFieldUpdateOperationsInput | number
    tour_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUncheckedUpdateManyWithoutTourNestedInput
    review?: reviewUncheckedUpdateManyWithoutTourNestedInput
    tourcheckpoint?: tourcheckpointUncheckedUpdateManyWithoutTourNestedInput
  }

  export type usersUpsertWithoutUsertourcompletionInput = {
    update: XOR<usersUpdateWithoutUsertourcompletionInput, usersUncheckedUpdateWithoutUsertourcompletionInput>
    create: XOR<usersCreateWithoutUsertourcompletionInput, usersUncheckedCreateWithoutUsertourcompletionInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUsertourcompletionInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUsertourcompletionInput, usersUncheckedUpdateWithoutUsertourcompletionInput>
  }

  export type usersUpdateWithoutUsertourcompletionInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUpdateManyWithoutUsersNestedInput
    review?: reviewUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUpdateManyWithoutUsersNestedInput
    userrole?: userroleUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUsertourcompletionInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUncheckedUpdateManyWithoutUsersNestedInput
    review?: reviewUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    userbadge?: userbadgeUncheckedUpdateManyWithoutUsersNestedInput
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutUsersNestedInput
    userprofile?: userprofileUncheckedUpdateOneWithoutUsersNestedInput
    userquizcompletion?: userquizcompletionUncheckedUpdateManyWithoutUsersNestedInput
    userrole?: userroleUncheckedUpdateOneWithoutUsersNestedInput
  }

  export type auditlogCreateManyAuditactionInput = {
    log_id?: number
    user_id?: number | null
    session_id?: number | null
    target_id: number
    target_entity?: string | null
    timestamp?: Date | string | null
  }

  export type auditlogUpdateWithoutAuditactionInput = {
    target_id?: IntFieldUpdateOperationsInput | number
    target_entity?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: sessionsUpdateOneWithoutAuditlogNestedInput
    users?: usersUpdateOneWithoutAuditlogNestedInput
  }

  export type auditlogUncheckedUpdateWithoutAuditactionInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    session_id?: NullableIntFieldUpdateOperationsInput | number | null
    target_id?: IntFieldUpdateOperationsInput | number
    target_entity?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auditlogUncheckedUpdateManyWithoutAuditactionInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    session_id?: NullableIntFieldUpdateOperationsInput | number | null
    target_id?: IntFieldUpdateOperationsInput | number
    target_entity?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userbadgeCreateManyBadgeInput = {
    user_id: number
    created_at?: Date | string | null
  }

  export type userbadgeUpdateWithoutBadgeInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutUserbadgeNestedInput
  }

  export type userbadgeUncheckedUpdateWithoutBadgeInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userbadgeUncheckedUpdateManyWithoutBadgeInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tourcheckpointCreateManyCheckpointInput = {
    tour_id: number
    checkpoint_order: number
  }

  export type usercheckpointattemptCreateManyCheckpointInput = {
    checkpointattempt_id?: number
    user_id: number
    tourcompletion_id: number
    created_at?: Date | string | null
  }

  export type tourcheckpointUpdateWithoutCheckpointInput = {
    checkpoint_order?: IntFieldUpdateOperationsInput | number
    tour?: tourUpdateOneRequiredWithoutTourcheckpointNestedInput
  }

  export type tourcheckpointUncheckedUpdateWithoutCheckpointInput = {
    tour_id?: IntFieldUpdateOperationsInput | number
    checkpoint_order?: IntFieldUpdateOperationsInput | number
  }

  export type tourcheckpointUncheckedUpdateManyWithoutCheckpointInput = {
    tour_id?: IntFieldUpdateOperationsInput | number
    checkpoint_order?: IntFieldUpdateOperationsInput | number
  }

  export type usercheckpointattemptUpdateWithoutCheckpointInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usertourcompletion?: usertourcompletionUpdateOneRequiredWithoutUsercheckpointattemptNestedInput
    users?: usersUpdateOneRequiredWithoutUsercheckpointattemptNestedInput
  }

  export type usercheckpointattemptUncheckedUpdateWithoutCheckpointInput = {
    checkpointattempt_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    tourcompletion_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usercheckpointattemptUncheckedUpdateManyWithoutCheckpointInput = {
    checkpointattempt_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    tourcompletion_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type checkpointCreateManyLocationInput = {
    checkpoint_id?: number
    quiz_id?: number | null
    points_reward: number
    created_at?: Date | string | null
  }

  export type checkpointUpdateWithoutLocationInput = {
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiz?: quizUpdateOneWithoutCheckpointNestedInput
    tourcheckpoint?: tourcheckpointUpdateManyWithoutCheckpointNestedInput
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutCheckpointNestedInput
  }

  export type checkpointUncheckedUpdateWithoutLocationInput = {
    checkpoint_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: NullableIntFieldUpdateOperationsInput | number | null
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tourcheckpoint?: tourcheckpointUncheckedUpdateManyWithoutCheckpointNestedInput
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutCheckpointNestedInput
  }

  export type checkpointUncheckedUpdateManyWithoutLocationInput = {
    checkpoint_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: NullableIntFieldUpdateOperationsInput | number | null
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type locationCreateManyLocationtypeInput = {
    location_id?: number
    location_name: string
    description?: string | null
    created_at?: Date | string | null
  }

  export type locationUpdateWithoutLocationtypeInput = {
    location_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpoint?: checkpointUpdateManyWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateWithoutLocationtypeInput = {
    location_id?: IntFieldUpdateOperationsInput | number
    location_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpoint?: checkpointUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type locationUncheckedUpdateManyWithoutLocationtypeInput = {
    location_id?: IntFieldUpdateOperationsInput | number
    location_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionCreateManyPermissionInput = {
    role_id: number
    created_at?: Date | string | null
  }

  export type rolepermissionUpdateWithoutPermissionInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: roleUpdateOneRequiredWithoutRolepermissionNestedInput
  }

  export type rolepermissionUncheckedUpdateWithoutPermissionInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionUncheckedUpdateManyWithoutPermissionInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionoptionCreateManyQuestionInput = {
    option_id?: number
    option: string
    is_correct: boolean
  }

  export type questionoptionUpdateWithoutQuestionInput = {
    option?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
  }

  export type questionoptionUncheckedUpdateWithoutQuestionInput = {
    option_id?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
  }

  export type questionoptionUncheckedUpdateManyWithoutQuestionInput = {
    option_id?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    is_correct?: BoolFieldUpdateOperationsInput | boolean
  }

  export type checkpointCreateManyQuizInput = {
    checkpoint_id?: number
    location_id: number
    points_reward: number
    created_at?: Date | string | null
  }

  export type questionCreateManyQuizInput = {
    question_id?: number
    question: string
  }

  export type userquizcompletionCreateManyQuizInput = {
    quizcompletion_id?: number
    user_id: number
    score: number
    created_at?: Date | string | null
  }

  export type checkpointUpdateWithoutQuizInput = {
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: locationUpdateOneRequiredWithoutCheckpointNestedInput
    tourcheckpoint?: tourcheckpointUpdateManyWithoutCheckpointNestedInput
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutCheckpointNestedInput
  }

  export type checkpointUncheckedUpdateWithoutQuizInput = {
    checkpoint_id?: IntFieldUpdateOperationsInput | number
    location_id?: IntFieldUpdateOperationsInput | number
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tourcheckpoint?: tourcheckpointUncheckedUpdateManyWithoutCheckpointNestedInput
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutCheckpointNestedInput
  }

  export type checkpointUncheckedUpdateManyWithoutQuizInput = {
    checkpoint_id?: IntFieldUpdateOperationsInput | number
    location_id?: IntFieldUpdateOperationsInput | number
    points_reward?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionUpdateWithoutQuizInput = {
    question?: StringFieldUpdateOperationsInput | string
    questionoption?: questionoptionUpdateManyWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateWithoutQuizInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    questionoption?: questionoptionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateManyWithoutQuizInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
  }

  export type userquizcompletionUpdateWithoutQuizInput = {
    score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutUserquizcompletionNestedInput
  }

  export type userquizcompletionUncheckedUpdateWithoutQuizInput = {
    quizcompletion_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userquizcompletionUncheckedUpdateManyWithoutQuizInput = {
    quizcompletion_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionCreateManyRoleInput = {
    permission_id: number
    created_at?: Date | string | null
  }

  export type userroleCreateManyRoleInput = {
    user_id: number
    created_at?: Date | string | null
  }

  export type rolepermissionUpdateWithoutRoleInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permission?: permissionUpdateOneRequiredWithoutRolepermissionNestedInput
  }

  export type rolepermissionUncheckedUpdateWithoutRoleInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolepermissionUncheckedUpdateManyWithoutRoleInput = {
    permission_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleUpdateWithoutRoleInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutUserroleNestedInput
  }

  export type userroleUncheckedUpdateWithoutRoleInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userroleUncheckedUpdateManyWithoutRoleInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auditlogCreateManySessionsInput = {
    log_id?: number
    user_id?: number | null
    action_id?: string | null
    target_id: number
    target_entity?: string | null
    timestamp?: Date | string | null
  }

  export type auditlogUpdateWithoutSessionsInput = {
    target_id?: IntFieldUpdateOperationsInput | number
    target_entity?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditaction?: auditactionUpdateOneWithoutAuditlogNestedInput
    users?: usersUpdateOneWithoutAuditlogNestedInput
  }

  export type auditlogUncheckedUpdateWithoutSessionsInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    action_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: IntFieldUpdateOperationsInput | number
    target_entity?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auditlogUncheckedUpdateManyWithoutSessionsInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    action_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: IntFieldUpdateOperationsInput | number
    target_entity?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type badgeCreateManyTourInput = {
    badge_id?: number
    badge_title: string
    description: string
    image_url: string
  }

  export type reviewCreateManyTourInput = {
    review_id?: number
    user_id?: number | null
    review_text: string
    rating: number
    created_at?: Date | string | null
  }

  export type tourcheckpointCreateManyTourInput = {
    checkpoint_id: number
    checkpoint_order: number
  }

  export type usertourcompletionCreateManyTourInput = {
    tourcompletion_id?: number
    user_id: number
    completed?: boolean | null
    completed_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type badgeUpdateWithoutTourInput = {
    badge_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    userbadge?: userbadgeUpdateManyWithoutBadgeNestedInput
  }

  export type badgeUncheckedUpdateWithoutTourInput = {
    badge_id?: IntFieldUpdateOperationsInput | number
    badge_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    userbadge?: userbadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type badgeUncheckedUpdateManyWithoutTourInput = {
    badge_id?: IntFieldUpdateOperationsInput | number
    badge_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
  }

  export type reviewUpdateWithoutTourInput = {
    review_text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateWithoutTourInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    review_text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewUncheckedUpdateManyWithoutTourInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    review_text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tourcheckpointUpdateWithoutTourInput = {
    checkpoint_order?: IntFieldUpdateOperationsInput | number
    checkpoint?: checkpointUpdateOneRequiredWithoutTourcheckpointNestedInput
  }

  export type tourcheckpointUncheckedUpdateWithoutTourInput = {
    checkpoint_id?: IntFieldUpdateOperationsInput | number
    checkpoint_order?: IntFieldUpdateOperationsInput | number
  }

  export type tourcheckpointUncheckedUpdateManyWithoutTourInput = {
    checkpoint_id?: IntFieldUpdateOperationsInput | number
    checkpoint_order?: IntFieldUpdateOperationsInput | number
  }

  export type usertourcompletionUpdateWithoutTourInput = {
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutUsertourcompletionNestedInput
    users?: usersUpdateOneRequiredWithoutUsertourcompletionNestedInput
  }

  export type usertourcompletionUncheckedUpdateWithoutTourInput = {
    tourcompletion_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutUsertourcompletionNestedInput
  }

  export type usertourcompletionUncheckedUpdateManyWithoutTourInput = {
    tourcompletion_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auditlogCreateManyUsersInput = {
    log_id?: number
    session_id?: number | null
    action_id?: string | null
    target_id: number
    target_entity?: string | null
    timestamp?: Date | string | null
  }

  export type reviewCreateManyUsersInput = {
    review_id?: number
    tour_id: number
    review_text: string
    rating: number
    created_at?: Date | string | null
  }

  export type sessionsCreateManyUsersInput = {
    session_id?: number
    access_token?: string | null
    is_active?: boolean | null
    login_at?: Date | string | null
    logout_at?: Date | string | null
  }

  export type userbadgeCreateManyUsersInput = {
    badge_id: number
    created_at?: Date | string | null
  }

  export type usercheckpointattemptCreateManyUsersInput = {
    checkpointattempt_id?: number
    checkpoint_id?: number | null
    tourcompletion_id: number
    created_at?: Date | string | null
  }

  export type userquizcompletionCreateManyUsersInput = {
    quizcompletion_id?: number
    quiz_id: number
    score: number
    created_at?: Date | string | null
  }

  export type usertourcompletionCreateManyUsersInput = {
    tourcompletion_id?: number
    tour_id?: number | null
    completed?: boolean | null
    completed_at?: Date | string | null
    created_at?: Date | string | null
  }

  export type auditlogUpdateWithoutUsersInput = {
    target_id?: IntFieldUpdateOperationsInput | number
    target_entity?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditaction?: auditactionUpdateOneWithoutAuditlogNestedInput
    sessions?: sessionsUpdateOneWithoutAuditlogNestedInput
  }

  export type auditlogUncheckedUpdateWithoutUsersInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    session_id?: NullableIntFieldUpdateOperationsInput | number | null
    action_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: IntFieldUpdateOperationsInput | number
    target_entity?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type auditlogUncheckedUpdateManyWithoutUsersInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    session_id?: NullableIntFieldUpdateOperationsInput | number | null
    action_id?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: IntFieldUpdateOperationsInput | number
    target_entity?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewUpdateWithoutUsersInput = {
    review_text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tour?: tourUpdateOneRequiredWithoutReviewNestedInput
  }

  export type reviewUncheckedUpdateWithoutUsersInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    tour_id?: IntFieldUpdateOperationsInput | number
    review_text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewUncheckedUpdateManyWithoutUsersInput = {
    review_id?: IntFieldUpdateOperationsInput | number
    tour_id?: IntFieldUpdateOperationsInput | number
    review_text?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionsUpdateWithoutUsersInput = {
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logout_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUpdateManyWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateWithoutUsersInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logout_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditlog?: auditlogUncheckedUpdateManyWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateManyWithoutUsersInput = {
    session_id?: IntFieldUpdateOperationsInput | number
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    login_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logout_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userbadgeUpdateWithoutUsersInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    badge?: badgeUpdateOneRequiredWithoutUserbadgeNestedInput
  }

  export type userbadgeUncheckedUpdateWithoutUsersInput = {
    badge_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userbadgeUncheckedUpdateManyWithoutUsersInput = {
    badge_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usercheckpointattemptUpdateWithoutUsersInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpoint?: checkpointUpdateOneWithoutUsercheckpointattemptNestedInput
    usertourcompletion?: usertourcompletionUpdateOneRequiredWithoutUsercheckpointattemptNestedInput
  }

  export type usercheckpointattemptUncheckedUpdateWithoutUsersInput = {
    checkpointattempt_id?: IntFieldUpdateOperationsInput | number
    checkpoint_id?: NullableIntFieldUpdateOperationsInput | number | null
    tourcompletion_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usercheckpointattemptUncheckedUpdateManyWithoutUsersInput = {
    checkpointattempt_id?: IntFieldUpdateOperationsInput | number
    checkpoint_id?: NullableIntFieldUpdateOperationsInput | number | null
    tourcompletion_id?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userquizcompletionUpdateWithoutUsersInput = {
    score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiz?: quizUpdateOneRequiredWithoutUserquizcompletionNestedInput
  }

  export type userquizcompletionUncheckedUpdateWithoutUsersInput = {
    quizcompletion_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userquizcompletionUncheckedUpdateManyWithoutUsersInput = {
    quizcompletion_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usertourcompletionUpdateWithoutUsersInput = {
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usercheckpointattempt?: usercheckpointattemptUpdateManyWithoutUsertourcompletionNestedInput
    tour?: tourUpdateOneWithoutUsertourcompletionNestedInput
  }

  export type usertourcompletionUncheckedUpdateWithoutUsersInput = {
    tourcompletion_id?: IntFieldUpdateOperationsInput | number
    tour_id?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usercheckpointattempt?: usercheckpointattemptUncheckedUpdateManyWithoutUsertourcompletionNestedInput
  }

  export type usertourcompletionUncheckedUpdateManyWithoutUsersInput = {
    tourcompletion_id?: IntFieldUpdateOperationsInput | number
    tour_id?: NullableIntFieldUpdateOperationsInput | number | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usercheckpointattemptCreateManyUsertourcompletionInput = {
    checkpointattempt_id?: number
    user_id: number
    checkpoint_id?: number | null
    created_at?: Date | string | null
  }

  export type usercheckpointattemptUpdateWithoutUsertourcompletionInput = {
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpoint?: checkpointUpdateOneWithoutUsercheckpointattemptNestedInput
    users?: usersUpdateOneRequiredWithoutUsercheckpointattemptNestedInput
  }

  export type usercheckpointattemptUncheckedUpdateWithoutUsertourcompletionInput = {
    checkpointattempt_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    checkpoint_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usercheckpointattemptUncheckedUpdateManyWithoutUsertourcompletionInput = {
    checkpointattempt_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    checkpoint_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}